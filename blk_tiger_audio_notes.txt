*****************************************************************************************
* GENERAL NOTES:                                                                        *
*****************************************************************************************

HOW TO: TEST AUDIO CLIPS
0) Start MAME debugger for blktiger (mame -debug blktiger)
1) set bp 1b4 in maincpu
2) CTRL+M. Set watch to E150
3) F5 (continue)
4) set pc=1ac when bp 1b4 is hit
5) F5 (continue). This puts Black Tiger into test mode.
6) Put values from 0h to 43h into E151 (in memory watch window). 0, 1F, and 38 will not play sounds. They stop the current sound.
7) Change byte at E162 to 51 (in memory watch window). Voila. Sound plays.

PLAN FOR PORTING AUDIO:

1) Rip YM2203 data from sound rom
2) Interpret YM2203 data: find instruments, wavelets, etc...
3) Put each sound/song into an intermediate format
4) Translate that intermediate format into something protracker can play on the Amiga hardware

traceover blktiger.tr,1
traceover off

wp 5448,CB,r,1,{tracelog "BT COMMAND AT %04X (PC=%04X) %02X\n",wpaddr,pc,wpdata; g}
wp f7f,55,r,1,{tracelog "BT COMMAND AT %04X (PC=%04X) %02X\n",wpaddr,pc,wpdata; g}
wp fd4,2a,r,1,{tracelog "BT COMMAND AT %04X (PC=%04X) %02X\n",wpaddr,pc,wpdata; g}

you can now use BambooTracker to make YM2203 music


LOCS TO REMEMBER:

0x218           - GENERAL BP FOR SOUNDS
0x433           - WORKHORSE METHOD FOR FM


TODO:

INVESTIGATE
  2FE           - sound data done(?)
  8C0           - COMMAND 0xF (loop?)
  8CE           - SEE HOW CHANNEL DATA ENDS

BT VARIABLES (C000-C0FF)
------------------------

01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0F 0F



4F 8D 63 9F 63 B1 63 C3 63 D6 63 EA 63 00 0A 07 00 02 C8 03 3B 30 81 30 88 30 87 21 CD CD 0F 00 0A 07 00 02 C8 03 2F 30 81 30 88 30 87 21 CD AD 0F 00 0A 07 00 02 C8 03 23 30 81 30 88 30 87 21 CD AD 0F 00 0A 07 15 02 C8 03 2F A0 30 81 30 88 30 87 21 AD AD 0F 00 0A 07 15 02 C8 03 23 A0 30 81 30 88 30 87 21 AD AD 0F 00 0A 07 15 02 C8 03 17 A0 30 81 30 88 30 87 21 AD AD 0F
4F 1D 1B 2F 1B 41 1B 53 1B 66 1B 79 1B 00 05 07 0D 02 C8 03 3B 30 81 30 88 30 87 21 CD CD 0F 00 05 07 0D 02 C8 03 2F 30 81 30 88 30 87 21 CD AD 0F 00 05 07 0D 02 C8 03 23 30 81 30 88 30 87 21 CD AD 0F 00 05 07 15 02 C8 03 2F A0 30 81 30 88 30 87 21 AD AD 0F 00 05 07 15 02 C8 03 23 A0 30 81 30 88 30 87 21 AD AD 0F 00 05 07 15 02 C8 03 17 A0 30 81 30 88 30 87 21 AD AD 0F



BT FM CHANNEL STRUCTS (0x30) (C100-C220; C300-C420)
---------------------------------------------------
IX+0x0/1    => PTR TO CHANNEL SOUND DATA (MSB/LSB)
IX+0x2      => SHORT NOTE DURATION HI
IX+0x3      => SHORT NOTE DURATION LO
IX+0x4      => LONG NOTE DURATION OFFSET                    (CMD 0x00)
IX+0x6/7    =>                                              (CMD 0x01)
IX+0x8/9    => LONG NOTE DURATION (WORD)
IX+0xa      => (?SOMETHING TO DO WITH DURATION COMPUTATION) (CMD 0x02)
IX+0xb      => x....... DOUBLE THE SHORT DURATION FLAG      (CMD 0x3_)
               .......x HOLD NOTE                           (CMD 0x05)
IX+0xc      => ....xxxx SHORT NOTE DURATION. n=....xxxx     (CMD 0x2n)
IX+0xd      => MAYBE OCTAVE                                 (CMD 0x03)
IX+0xe      => NOTE OFFSET
IX+0x17     => CHANNEL OP ROM SETTINGS OFFSET               (CMD 0x07)
IX+0x18/19  => PTR TO ROM SETTINGS for channel
IX+0x1a     => FEEDBACK LVL & OP CONNECT ALGORITHM
IX+0x2d     => INNER REPEAT COUNT
IX+0x2e     => OUTER REPEAT COUNT
IX+0x2f     => PROGRAM REPEAT COUNT


BT SSG CHANNEL STRUCTS (0x30) (C500 & C530)
-------------------------------------------
IX+0x0      => FLAG(?) (FF = PLAYING?)
IX+0x1      => CH A TONE PERIOD (FINE)
IX+0x2      => CH A TONE PERIOD (COARSE)
IX+0x3      => CH B TONE PERIOD (FINE)
IX+0x4      => CH B TONE PERIOD (COARSE)
IX+0x5      => CH C TONE PERIOD (FINE)
IX+0x6      => CH C TONE PERIOD (COARSE)
IX+0x7      => NOISE PERIOD
IX+0x8      => NOISE ENABLE
IX+0x9      => CH A AMPLITUDE << 4
IX+0xa      => CH B AMPLITUDE << 4
IX+0xb      => CH C AMPLITUDE << 4
IX+0xc      => CH A TONE PERIOD DATA
IX+0xd      => CH B TONE PERIOD DATA
IX+0xe      => CH C TONE PERIOD DATA
IX+0xf      => CH A AMPLITUDE DATA
IX+0x10     => CH B AMPLITUDE DATA
IX+0x11     => CH C AMPLITUDE DATA
IX+0x12     => NOISE PERIOD DATA
IX+0x13/14  => DURATION
IX+0x15/16  => PTR TO NEXT SSG DATA BYTE
IX+0x17/18  => PTR TO PREVIOUS SSG DATA BYTE
IX+0x19     => (RESET BY CMD 01)
IX+0x1a     => CURRENT SSG BYTE
IX+0x1b     => NEXT SSG BYTE
IX+0x1d     =>
IX+0x1e     =>
IX+0x1f     => MAIN CMD BYTE


SOUND 00: RESETS SOUND AND BUFFERED CHANNELS
SOUND 1F: RESETS SOUND (SSG ONLY?)
SOUND 38: STOPS SOUND AND LOADS ANY BUFFERED CHANNELS (SOUND)


BLACK TIGER COMMANDS:
=====================
        ram:0219 cb 7f           BIT        0x7,A

    FIRST BYTE:     x.......            : HAS CHANNEL DATA (0=true; 1=false) or IS SSG (0=false; 1=true)
                    .x......            ; WHICH SSG CHIP (0=YM1/1=YM2) (03,04,08,09,0A,0C,0F,13,15,16,18,19,3D,3E,41,42,43)
                    ...x....            ; ?? (3F)
                    ....xxxx            ; SOUND CANCEL MASK
                                            0: 3F;
                                            1: 11,14,3B,3C;
                                            6: 21,22,23,24,25,26,27,28,29,2A,2B,2C,2D,2E,2F,30,31,32,33,34,35,36,37,39
                                            8: 05,06,07,08,09,0A,0B,0C,0E,0F,10,12,13,15,16,18,19,1A,1B,1C,1D,1E,3A,3D,3E,40,41,42,43
                                            F: 01,02,03,04,0D,17,20

    (BREAKPOINT (PC=0219)/08F7)
    FM SOUNDS
    0x06        - (21,22,23,24,25,26,27,28,29,2A,2B,2C,2D,2E,2F,30,31,32,33,34,35,36,37,39)
    0x4F        - (20)

TESTED: 20,21,29,2A,2B,2C,2D,2E,2F,30,31,32,33,34,35,36,37,39

    (BREAKPOINT (PC=0219)/0B4D)
    SSG SOUNDS
    0x90        - (3F)      DRAGON_DIE

    0x81        - (11,14)   TIME_EXPIRING/UNKNOWN_ALARM_(LOOPS)
    0xC1        - (3B,3C)   FALLING/BOUNCING_(LOOPS)

    0x88        - (05,06,07,0B,0E,10,12,1A,1B,1C,1D,1E,3A,40)
                            ITEM_TAKEN/PLAYER_TAKES_ZENNY_COIN/FIRE_PILLAR_WARNING
                            WEAPON_CLASH_METALLIC_BATTLE/POT_BREAKS/BIG_BOSS_HIT/PLAYER_GETS_ITEM_FROM_OLD_MAN
                            PLAYER_CLIMB/FLAIL_EMPTY_HIT/PLAYER_LANDS_ON_PLATFORM/PLAYER_ASCENDS_DURING_CUTSCENE/PLAYER_GRABS_LADDER

    0xC8        - (08,09,0A,0C,0F,13,15,16,18,19,3D,3E,41,42,43)

    0x8F        - (01,02,0D,17)     PLAYER_LOSES_VITALITY/PLAYER_DEATH/PLAYER_EARNS_EXTRA_LIFE/PLAYER_LOSES_ARMOR
    0xCF        - (03,04)           ENEMY_INJURED_BLOOP/ENEMY_DEFEATED

YM1 TESTED: 01,02,05,06,07,0B,0D,0E,10,11,12,14,17,1A,1B,1C,1D,1E,3A,3F,40
YM2 TESTED: 03,04,08,09,0A,0C,0F,13,15,16,18,19,3B,3C,3D,3E,41,42,43
   =================================================================================================================================
    (BREAKPOINT (SUB-SOUND LEVEL (PC=08F7)))

FM COMMANDS:
------------
    0x00        =>  00 xx           SET CHANNEL LARGE DURATION OFFSET = xx
                                    (SETS IX+0x04 = xx)
        07      -
        08      -
        09      -
    0x01        =>  01 xx           UNKNOWN FUNCTION
                                    (SETS IX+0x06 = xx and clears IX+0x7)
    0x02        =>  02 xx           SET DURATION COMPUTATION OFFSET = xx
                                    (SETS IX+0x0a = xx)
        C8
    0x03        =>  03 xx           MAYBE SET CHANNEL OCTAVE OFFSET
            2F                      (SETS IX+0x0d = xx)
            23
            17
    0x04        =>  04 xx           SEEMS TO BE UNUSED (SETS IX+0x12 = xx)
    0x05        =>  05 xx           SET NOTE HOLD. xx = 0 = off; xx > 0? on
                                    (SETS BIT 0 of IX+0x0b = (xx > 0) ? 1 : 0))
    0x06        =>  06 xx
    0x07        =>  07 xx           SET CHANNEL OP ROM SETTINGS OFFSET. If not buffering, SetChannelOperatorsFromTable.
                                    (SETS IX+0x17 = xx).
    0x08        =>  08              (NO OPERATION)
    0x0B        =>  0B              (NO OPERATION)
    0x0C        =>  0C xx ll hh     xx = 0? set data pointer to ll hh. Repeat infinite loop
                                    xx > 0? 
                                       Repeats (IX+0x2d) done? End. 
                                       Else set data pointer to ll hh.
                                    (AFFECTS IX+0x2d)
    0x0D        =>  0D xx ll hh     xx = 0? set data pointer to ll hh. Repeat infinite loop
                                    xx > 0? 
                                       Repeats (IX+0x2e) done? End. 
                                       Else set data pointer to ll hh.
                                    (AFFECTS IX+0x2e)
    0x0E        =>  0E xx ll hh     xx = 0? set data pointer to ll hh. Repeat infinite loop
                                    xx > 0? 
                                       Repeats (IX+0x2f) done? End. 
                                       Else set data pointer to ll hh.
                                    (AFFECTS IX+0x2f)
    0x0F        =>  0F              end of sound channel data
    0x2_        =>  2n xx           Set short note duration and send note
                                    2n where n = short note duration
                                    (IX+0xc = 0)
                                    Send a note to HW(?) -- (xx is translated into a note plus duration and then sent)
                                    (IX+0xc = (2_ & 0x0F))
    0x3_        =>  3_ xx           Double xx's duration
                                    (SET 0x7,(IX+0xb)) - doubles the following note duration
                                    Send a note to HW(?) -- (xx is translated into a note plus duration and then sent)

    0x10-1F     =>  xx              Untranslated FM note
    0x40-FF     =>  xx              Untranslated FM note

SSG FIRST COMMANDS:
------------------
    CMD BYTE:   => 1y.xxxxx         (MASK 0x1F); y = WHICH YM CHIP (0 = YM1; 1 = YM2)
    00-03:      => ...000.. aa      SET DURATION: THIS BYTE (HI) PLUS aa
                                    (x13) = THIS BYTE (x14)= aa
                                    RUN SECONDARY COMMAND
    04-07:      => ...001..         RESET REPEATS AND UPDATE BOOKMARKS
                                    CLEARS 0x19; UPDATES BOOKMARKS 18/19 = 15/16; IMMEDIATELY LOAD NEXT CMD 
    08-0B:      => ...010.. aa      REPEAT UNTIL aa == 0x19
                                    if 0x19 != aa, loop back to previous bookmark and repeat                                
    0C-0F:      => ...011..         Maybe not used?
    10-13:      => ...100..         Maybe not used?
    14-17:      => ...101..         Maybe not used?
    18-1B:      => ...110..         Maybe not used?
    1C-1F:      => ...111..         END SSG CLIP

SSG SECOND COMMANDS:
-------------------
    0n-1n:      => ........ 
    2n-3n:      => ....xxxx aa bb   SETS CHANNEL A TONE PERIOD (FINE) (00) = aa; SETS CHANNEL A TONE PERIOD (COARSE) (01) = (CMD &0f)
                                    DE = (CMD &0xf << 8) + aa; VAL=DE << 4; SETS IX+0x1=VAL.LO; SETS IX+0x2=VAL.HI; 0xC = bb
    2F/3F:      =>                  SKIPS SETTING TONE PERIOD; 0xC = bb
    4n-5n:      => ....xxxx aa bb   SETS CHANNEL B TONE PERIOD (FINE) (02) = aa; SETS CHANNEL B TONE PERIOD (COARSE) (03) = (CMD &0f)
                                    DE = (CMD &0xf << 8) + aa; VAL=DE << 4; SETS IX+0x3=VAL.LO; SETS IX+0x4=VAL.HI; 0xD = bb
    4F/5F:      =>                  SKIPS SETTING TONE PERIOD; 0xD = bb
    6n-7n:      => ....xxxx aa bb   SETS CHANNEL C TONE PERIOD (FINE) (04) = aa; SETS CHANNEL C TONE PERIOD (COARSE) (05) = (CMD &0f)
                                    DE = (CMD &0xf << 8) + aa; VAL=DE << 4; SETS IX+0x5=VAL.LO; SETS IX+0x6=VAL.HI; 0xE = bb
    6F/7F:      =>                  SKIPS SETTING TONE PERIOD; 0xE = bb
    8n-9E:      => ....xxxx aa      SETS CHANNEL A AMPLITUDE = (CMD & 0xF)
                                    SETS IX+0x9 = (CMD & 0xF) << 4; SETS IX+0xf = aa
       9F:      => ....xxxx aa      SKIPS SETTING CH A AMPLITUDE; SETS IX+0xf = aa
    An-Bn:      => ....xxxx aa      SETS CHANNEL B AMPLITUDE = (CMD & 0xF)
                                    SETS IX+0xA = (CMD & 0xF) << 4; SETS IX+0x10 = aa
       BF:      => ....xxxx aa      SKIPS SETTING CH B AMPLITUDE; SETS IX+0x10 = aa
    Cn-Dn:      => ....xxxx aa      SETS CHANNEL C AMPLITUDE = (CMD & 0xF)
                                    SETS IX+0xB = (CMD & 0xF) << 4; SETS IX+0x11 = aa
       DF:      => ....xxxx aa      SKIPS SETTING CH C AMPLITUDE; SETS IX+0x11 = aa
    En-Fn:      => ...xxxxx aa bb   SETS NOISE PERIOD (06) AND NOISE ENABLE/DISABLE (07) 
                                    SENDS YM CMDS 06 & 07; (CAN RUN ONE COMMAND AFTER ANOTHER IN SAME FRAME)
                                    SETS x7/8
                                    SET IX+0x7 = (...xxxxx & 1Fh) << 3; SET IX+0x8 = (aa & 38h) + (IX+0x8 & C7h)
                                    SENDS YMn => 06 IX+0x7 / 07 IX+0x8
                                    SETS x12 = bb

OTHER COMMANDS:
---------------

    0x10-1F     =>  xx              Untranslated note
    0x40-FF     =>  xx              Untranslated note

   =================================================================================================================================

    0x69 (note 440h)
    0x6D (note 55Bh)
    0x6E (note 2D6h)
    0x70 (note 32Fh)
    0x72 (note 393h)
    0x75 (note 440h)
    0x77 (note 4C6h)
    0x79 (note 55Bh)
    0x8F (note 301h)
    0x91 (note 360h)
    0x92 (note 393h)
    0x93 (note 3C9h)
    0x96 (note 481h)
    0x97 (no notes)
    0x97 (note 4C6h)
    0x9A (no notes)
    0x9A (note 2D6h)
    0x9C (note 32Fh)
    0xA0 (no notes)
    0xAD (note 55Bh)
    0xB2 (note 393h)
    0xB9 (note 55Bh)
    0xD0 (note 32Fh)
    0xD2 (note 393h)
    0xD5 (note 440h)
    0xD6 (note 481h)
    0xD9 (note 55Bh)
    0xDE (note 393h)
    0xE6 (note 393h)
    0xF6 (no notes)
    0xF9 (no notes)
    0xF9 (note 55Bh)
    0xFE (no notes)


    (20) 0x4F:

EXAMPLE OF "GAME OVER" COMMANDS AND ASSOCIATED NOTES

0110 1001 / 0111 0101 / 1101 0101
0x69 (note 440h) 0x75 (note 440h) 0xD5 (note 440h)

0110 1101 / 0111 1001 / 1010 1101 / 1011 1001/ 1101 1001/ 1111 1001
0x6D (note 55Bh) 0x79 (note 55Bh) 0xAD (note 55Bh) 0xB9 (note 55Bh) 0xD9 (note 55Bh) 0xF9 (note 55Bh)

0110 1110 / 1001 1010
0x6E (note 2D6h) 0x9A (note 2D6h)

0111 0000 / 1001 1100 / 1101 0000
0x70 (note 32Fh) 0x9C (note 32Fh) 0xD0 (note 32Fh)

0111 0010 / 1001 0010 / 1011 0010 / 1101 0010 / 1101 1110 / 1110 0110
0x72 (note 393h) 0x92 (note 393h) 0xB2 (note 393h) 0xD2 (note 393h) 0xDE (note 393h) 0xE6 (note 393h)

0111 0111 / 1001 0111
0x77 (note 4C6h) 0x97 (note 4C6h)

1000 1111
0x8F (note 301h)

1001 0001
0x91 (note 360h)

1001 0011
0x93 (note 3C9h)

1001 0110 / 1101 0110
0x96 (note 481h) 0xD6 (note 481h)

1001 0111
0x97 (no notes)

1001 1010
0x9A (no notes)

1010 0000
0xA0 (no notes)

1111 0110
0xF6 (no notes)

1111 1001
0xF9 (no notes)

1111 1110
0xFE (no notes)

    static constexpr uint32_t OUTPUTS = 1;
    static constexpr uint32_t CHANNELS = 3;
    static constexpr uint32_t ALL_CHANNELS = (1 << CHANNELS) - 1; (7)
    static constexpr uint32_t OPERATORS = CHANNELS * 4; (12)
    static constexpr uint32_t WAVEFORMS = 1;
    static constexpr uint32_t REGISTERS = 0x100;
    static constexpr uint32_t REG_MODE = 0x27;
    static constexpr uint32_t DEFAULT_PRESCALE = 6;
    static constexpr uint32_t EG_CLOCK_DIVIDER = 3;
    static constexpr bool EG_HAS_SSG = true;
    static constexpr bool MODULATOR_DELAY = false;
    static constexpr uint32_t CSM_TRIGGER_MASK = 1 << 2;
    static constexpr uint8_t STATUS_TIMERA = 0x01;
    static constexpr uint8_t STATUS_TIMERB = 0x02;
    static constexpr uint8_t STATUS_BUSY = 0x80;
    static constexpr uint8_t STATUS_IRQ = 0;
template<bool IsOpnA>
bool opn_registers_base<IsOpnA>::write(uint16_t index, uint8_t data, uint32_t &channel, uint32_t &opmask)
{
    assert(index < REGISTERS);

    // writes in the 0xa0-af/0x1a0-af region are handled as latched pairs
    // borrow unused registers 0xb8-bf/0x1b8-bf as temporary holding locations
    if ((index & 0xf0) == 0xa0)
    {
        uint32_t latchindex = 0xb8 | (bitfield(index, 3) << 2) | bitfield(index, 0, 2);
        if (IsOpnA)
            latchindex |= index & 0x100;

        // writes to the upper half just latch (only low 6 bits matter)
        if (bitfield(index, 2))
            m_regdata[latchindex] = data | 0x80;

        // writes to the lower half only commit if the latch is there
        else if (bitfield(m_regdata[latchindex], 7))
        {
            m_regdata[index | 4] = m_regdata[latchindex] & 0x3f;
            m_regdata[latchindex] = 0;
        }
    }

    // everything else is normal
    m_regdata[index] = data;

    // handle writes to the key on index
    if (index == 0x28)
    {
        channel = bitfield(data, 0, 2);
        if (channel == 3)
            return false;
        if (IsOpnA)
            channel += bitfield(data, 2, 1) * 3;
        opmask = bitfield(data, 4, 4);
        return true;
    }
    return false;
}

    LOG_FM_WRITES = true

        operator_list(  0,  6,  3,  9 ),  // Channel 0 operators
        operator_list(  1,  7,  4, 10 ),  // Channel 1 operators
        operator_list(  2,  8,  5, 11 ),  // Channel 2 operators

    If you write pc98dos_debug=2 in the hoot.ini file, the console will be displayed at runtime and you can check the error messages.
//
// OPN register map:
//
//      System-wide registers:
//           21 xxxxxxxx Test register
//           22 ----x--- LFO enable [OPNA+ only]
//              -----xxx LFO rate [OPNA+ only]
//           24 xxxxxxxx Timer A value (upper 8 bits)
//           25 ------xx Timer A value (lower 2 bits)
//           26 xxxxxxxx Timer B value
//           27 xx------ CSM/Multi-frequency mode for channel #2
//              --x----- Reset timer B
//              ---x---- Reset timer A
//              ----x--- Enable timer B
//              -----x-- Enable timer A
//              ------x- Load timer B
//              -------x Load timer A
//           28 x------- Key on/off operator 4
//              -x------ Key on/off operator 3
//              --x----- Key on/off operator 2
//              ---x---- Key on/off operator 1
//              ------xx Channel select
//
//     Per-channel registers (channel in address bits 0-1)
//     Note that all these apply to address+100 as well on OPNA+
//        A0-A3 xxxxxxxx Frequency number lower 8 bits
//        A4-A7 --xxx--- Block (0-7)
//              -----xxx Frequency number upper 3 bits
//        B0-B3 --xxx--- Feedback level for operator 1 (0-7)
//              -----xxx Operator connection algorithm (0-7)
//        B4-B7 x------- Pan left [OPNA]
//              -x------ Pan right [OPNA]
//              --xx---- LFO AM shift (0-3) [OPNA+ only]
//              -----xxx LFO PM depth (0-7) [OPNA+ only]
//
//     Per-operator registers (channel in address bits 0-1, operator in bits 2-3)
//     Note that all these apply to address+100 as well on OPNA+
//        30-3F -xxx---- Detune value (0-7)
//              ----xxxx Multiple value (0-15)
//        40-4F -xxxxxxx Total level (0-127)
//        50-5F xx------ Key scale rate (0-3)
//              ---xxxxx Attack rate (0-31)
//        60-6F x------- LFO AM enable [OPNA]
//              ---xxxxx Decay rate (0-31)
//        70-7F ---xxxxx Sustain rate (0-31)
//        80-8F xxxx---- Sustain level (0-15)
//              ----xxxx Release rate (0-15)
//        90-9F ----x--- SSG-EG enable
//              -----xxx SSG-EG envelope (0-7)
//
//     Special multi-frequency registers (channel implicitly #2; operator in address bits 0-1)
//        A8-AB xxxxxxxx Frequency number lower 8 bits
//        AC-AF --xxx--- Block (0-7)
//              -----xxx Frequency number upper 3 bits
//
//     Internal (fake) registers:
//        B8-BB --xxxxxx Latched frequency number upper bits (from A4-A7)
//        BC-BF --xxxxxx Latched frequency number upper bits (from AC-AF)
//

// SSG register map:
//
//      System-wide registers:
//           06 ---xxxxx Noise period
//           07 x------- I/O B in(0) or out(1)
//              -x------ I/O A in(0) or out(1)
//              --x----- Noise enable(0) or disable(1) for channel C
//              ---x---- Noise enable(0) or disable(1) for channel B
//              ----x--- Noise enable(0) or disable(1) for channel A
//              -----x-- Tone enable(0) or disable(1) for channel C
//              ------x- Tone enable(0) or disable(1) for channel B
//              -------x Tone enable(0) or disable(1) for channel A
//           0B xxxxxxxx Envelope period fine
//           0C xxxxxxxx Envelope period coarse
//           0D ----x--- Envelope shape: continue
//              -----x-- Envelope shape: attack/decay
//              ------x- Envelope shape: alternate
//              -------x Envelope shape: hold
//           0E xxxxxxxx 8-bit parallel I/O port A
//           0F xxxxxxxx 8-bit parallel I/O port B
//
//      Per-channel registers:
//     00,02,04 xxxxxxxx Tone period (fine) for channel A,B,C
//     01,03,05 ----xxxx Tone period (coarse) for channel A,B,C
//     08,09,0A ---x---- Mode: fixed(0) or variable(1) for channel A,B,C
//              ----xxxx Amplitude for channel A,B,C

I:\mame_vgm

uint8_t ym2203::read(uint32_t offset)
{
    uint8_t result = 0xff;
    switch (offset & 1)
    {
        case 0: // status port
            result = read_status();
            break;

        case 1: // data port (only SSG)
            result = read_data();
            break;
    }
    return result;
}

void ym2203::write(uint32_t offset, uint8_t data)
{
    switch (offset & 1)
    {
        case 0: // address port
            write_address(data);
            break;

        case 1: // data port
            write_data(data);
            break;
    }
}

void ym2203::write_address(uint8_t data)
{
    // just set the address
    m_address = data;

    // special case: update the prescale
    if (m_address >= 0x2d && m_address <= 0x2f)
    {
        // 2D-2F: prescaler select
        if (m_address == 0x2d)
            update_prescale(6);
        else if (m_address == 0x2e && m_fm.clock_prescale() == 6)
            update_prescale(3);
        else if (m_address == 0x2f)
            update_prescale(2);
    }
}

void ym2203::update_prescale(uint8_t prescale)
{
    // tell the FM engine
    m_fm.set_clock_prescale(prescale);
    m_ssg.prescale_changed();

    // Fidelity:   ---- minimum ----    ---- medium -----    ---- maximum-----
    //              rate = clock/24      rate = clock/12      rate = clock/4
    // Prescale    FM rate  SSG rate    FM rate  SSG rate    FM rate  SSG rate
    //     6          3:1     2:3          6:1     4:3         18:1     4:1
    //     3        1.5:1     1:3          3:1     2:3          9:1     2:1
    //     2          1:1     1:6          2:1     1:3          6:1     1:1

    // compute the number of FM samples per output sample, and select the
    // resampler function
    if (m_fidelity == OPN_FIDELITY_MIN)
    {
        switch (prescale)
        {
            default:
            case 6: m_fm_samples_per_output = 3;    m_ssg_resampler.configure(2, 3);    break;
            case 3: m_fm_samples_per_output = 0;    m_ssg_resampler.configure(1, 3);    break;
            case 2: m_fm_samples_per_output = 1;    m_ssg_resampler.configure(1, 6);    break;
        }
    }
    else if (m_fidelity == OPN_FIDELITY_MED)
    {
        switch (prescale)
        {
            default:
            case 6: m_fm_samples_per_output = 6;    m_ssg_resampler.configure(4, 3);    break;
            case 3: m_fm_samples_per_output = 3;    m_ssg_resampler.configure(2, 3);    break;
            case 2: m_fm_samples_per_output = 2;    m_ssg_resampler.configure(1, 3);    break;
        }
    }
    else
    {
        switch (prescale)
        {
            default:
            case 6: m_fm_samples_per_output = 18;   m_ssg_resampler.configure(4, 1);    break;
            case 3: m_fm_samples_per_output = 9;    m_ssg_resampler.configure(2, 1);    break;
            case 2: m_fm_samples_per_output = 6;    m_ssg_resampler.configure(1, 1);    break;
        }
    }

    // if overriding the SSG, override the configuration with the nop
    // resampler to at least keep the sample index moving forward
    if (m_ssg.overridden())
        m_ssg_resampler.configure(0, 0);
}

void ym2203::write_data(uint8_t data)
{
    if (m_address < 0x10)
    {
        // 00-0F: write to SSG
        m_ssg.write(m_address & 0x0f, data);
    }
    else
    {
        // 10-FF: write to FM
        m_fm.write(m_address, data);
    }

    // mark busy for a bit
    m_fm.intf().ymfm_set_busy_end(32 * m_fm.clock_prescale());
}

uint8_t ym2203::read_status()
{
    uint8_t result = m_fm.status();
    if (m_fm.intf().ymfm_is_busy())
        result |= fm_engine::STATUS_BUSY;
    return result;
}

uint8_t ym2203::read_data()
{
    uint8_t result = 0;
    if (m_address < 0x10)
    {
        // 00-0F: Read from SSG
        result = m_ssg.read(m_address & 0x0f);
    }
    return result;
}





                             SOUNDS_TABLE                                    XREF[1]:     Maybe_PlaySoundEffect:020e(*)
        ram:0dc1 00 ff           dw         FF00h                                            Sound 0: FF stops music playing
        ram:0dc3 49 0e           dw         PLAYER_LOSES_VITALITY                            = 8Fh
        ram:0dc5 9e 0e           dw         PLAYER_DEATH                                     = 8Fh
        ram:0dc7 7f 0f           dw         ENEMY_INJURED_BLOOP                              = CFh
        ram:0dc9 d4 0f           dw         ENEMY_DEFEATED                                   = CFh
        ram:0dcb fe 0f           dw         ITEM_TAKEN                                       = 88h
        ram:0dcd 7b 10           dw         PLAYER_TAKES_ZENNY_COIN                          = 88h
        ram:0dcf f5 10           dw         FIRE_PILLAR_WARNING                              = 88h
        ram:0dd1 5e 11           dw         POT_BREAKS_REVEALS_COIN                          = C8h
        ram:0dd3 c7 11           dw         FIRE_PILLAR                                      = C8h
        ram:0dd5 08 12           dw         GAS_JET                                          = C8h
        ram:0dd7 32 12           dw         WEAPON_CLASH_METALLIC_BATTLE                     = 88h
        ram:0dd9 84 12           dw         KILL_BAT                                         = C8h
        ram:0ddb ae 12           dw         PLAYER_EARNS_EXTRA_LIFE                          = 8Fh
        ram:0ddd 64 13           dw         POT_BREAKS                                       = 88h
        ram:0ddf bc 13           dw         PLAYER_DISCOVERS_TREASURE                        = C8h
        ram:0de1 86 14           dw         BIG_BOSS_HIT                                     10
        ram:0de3 b0 14           dw         TIME_EXPIRING                                    = 81h
        ram:0de5 ee 14           dw         PLAYER_GETS_ITEM_FROM_OLD_MAN                    = 88h
        ram:0de7 cc 15           dw         BOOM_EXPLOSION                                   = C8h
        ram:0de9 0d 16           dw         UNKNOWN_ALARM                                    = 81h
        ram:0deb 4e 16           dw         IMPACT                                           = C8h
        ram:0ded 78 16           dw         CLASH_SPINNING_COIN                              = C8h
        ram:0def a2 16           dw         PLAYER_LOSES_ARMOR                               = 8Fh
        ram:0df1 08 17           dw         MICHELIN_MAN_FIREBREATHING                       = C8h
        ram:0df3 35 17           dw         FIRETHROWER_TAUNT                                = C8h
        ram:0df5 b2 17           dw         PLAYER_CLIMB                                     = 88h
        ram:0df7 c8 17           dw         FLAIL_EMPTY_HIT                                  = 88h
        ram:0df9 de 17           dw         PLAYER_LANDS_ON_PLATFORM                         = 88h
        ram:0dfb 1c 18           dw         PLAYER_ASCENDS_DURING_CUTSCENE                   = 88h
        ram:0dfd 32 18           dw         PLAYER_GRABS_LADDER                              = 88h
        ram:0dff 01 ff           dw         FF01h                                            1f: stops playing music
        ram:0e01 10 1b           dw         COIN_OR_CREDIT_ADDED                             = 4Fh    O
        ram:0e03 8c 1b           dw         LEVEL_1_MUSIC                                    Level 1 music
        ram:0e05 de 1f           dw         LEVEL_2_MUSIC                                    = 06h
        ram:0e07 ef 23           dw         LEVEL_3_MUSIC                                    = 06h
        ram:0e09 b7 27           dw         LEVEL_4_MUSIC                                    = 06h
        ram:0e0b 27 2d           dw         LEVEL_5_MUSIC                                    = 06h
        ram:0e0d 07 32           dw         LEVEL_6_MUSIC                                    = 06h
        ram:0e0f c4 35           dw         LEVEL_7_MUSIC                                    = 06h
        ram:0e11 7c 3a           dw         LEVEL_8_MUSIC                                    Level 8 music
        ram:0e13 cb 3f           dw         BOSS_MUSIC_01                                    = 06h
        ram:0e15 f5 41           dw         FIGHT_DRAGON_MUSIC_01                            = 06h
        ram:0e17 8b 44           dw         FIGHT_DRAGON_MUSIC_02                            = 06h
        ram:0e19 70 47           dw         OLD_MAN_SHOP_MUSIC                               = 06h
        ram:0e1b 7e 49           dw         DUNGEON_MUSIC_01                                 = 06h
        ram:0e1d 96 4b           dw         ENTER_INITIALS_MUSIC                             = 06h
        ram:0e1f 9d 51           dw         AFTER_ENTER_INITIALS_MUSIC                       = 06h
        ram:0e21 82 52           dw         INTRO_MUSIC                                      30
        ram:0e23 48 54           dw         GAME_OVER_MUSIC                                  = 06h
        ram:0e25 13 55           dw         SUCCESSFULLY_FINISH_LEVEL_MUSIC                  = 06h
        ram:0e27 fa 55           dw         FINISH_LEVEL_8_MUSIC                             = 06h
        ram:0e29 a4 5e           dw         CONTINUE_MUSIC                                   = 06h
        ram:0e2b 51 60           dw         MAYBE_PERFECT_BONUS_MUSIC                        = 06h
        ram:0e2d d2 60           dw         UNKNOWN_FANFARE_MUSIC                            = 06h
        ram:0e2f 6d 61           dw         UNKNOWN_FANFARE_MUSIC_02                         = 06h
        ram:0e31 04 ff           dw         FF04h                                            38 stops music playing
        ram:0e33 36 62           dw         UNKNOWN_FANFARE_MUSIC_03                         = 06h
        ram:0e35 5c 18           dw         FLAIL_HIT                                        = 88h
        ram:0e37 86 18           dw         FALLING                                          = C1h
        ram:0e39 9c 18           dw         BOUNCING      _(LOOPS)                           = C1h
        ram:0e3b c9 18           dw         OLD_MAN_TALKING                                  = C8h
        ram:0e3d 57 19           dw         OLD_MAN_TALKING_02                               = C8h
        ram:0e3f a9 19           dw         DRAGON_DIE                                       = 90h
        ram:0e41 90 1a           dw         MAYBE_BLOCK_BOUNCE_UP                            40
        ram:0e43 ba 1a           dw         FALLING_02                                       = C8h
        ram:0e45 d0 1a           dw         BOSS_HIT                                         = C8h
        ram:0e47 e6 1a           dw         DRAGON_SPEW_FIRE                                 43 might be the last sound

PMD .M files
============

Professional Music Driver file, a format developed by Masahiro Kajihara, for various Yamaha chips.

- BattleOfTheBits.org has good info on PMD.
- lithcore.cn/2318 has additional analysis.
- There's a useful primer for PMD MML written in 2017 at delmunsoft.com.
- An English translation of the PMD MML manual: github.com/Pigu-A/pmddocs.
- A translation of the YM2608 manual exists online, which is OPN-compatible.
- Additionally, github.com/takamichih has some related source code.

There is a PMD98 player for Windows called FMPMD2000, though it can't handle the OPL-oriented
mode-2 .M files.

The English Nocturnal Illusion has, for some reason, one .M file, N12.M, although its other .M
files are really just disguised midi files. The song is not reproduced on any new version of the
game; it is only in the PC-98 version, and I am not sure it is ever played in the game. The song
is not very memorable in any case.

The Hoot collection has some .M2 files as well; these look very similar to .M.

Understanding the PMD MML is very useful for this, but .M files specifically are a translation of
that MML into a binary format, which doesn't have a direct equivalent for all convenience commands
available in the MML. I have added [MML x.y] tags here as references to MML specification parts.

File layout
===========

byte            File mode. If present, everything else is shifted forward +1 byte, including all
                possible word offsets found further on in the file.
array of words  Track addresses, possibly needing to be shifted ahead by +1 byte.
tracks          Musical tracks, plus metadata tracks.

File modes
==========

PMD's official "MC" tool can compile MML files in a few different modes, to target different sound
chips.

(Dragon Knight 1-3 .M files start with the byte 06, and are quite different... that's some other
format, recognisably used by a small handful of games. The first byte may also be absent, such as
in Princess Maker 1.)

Possible modes:
  00: OPN/OPNA: PC88 and PC98 (YM2203, YM2608), FM-Towns (YM2612)
  01: OPM: X68000 (YM2151)
  02: OPL2: Western Adlib/Soundblaster (YM3812)

As a historical detail, the YM2203 has 3 FM and 3 SSG channels, and was available as a PC-9801-26
expansion card, as well as being commonly integrated on motherboards. A lot of PC98 music thus
targets this as the most common device. The YM2608 has 3 additional full FM channels as well as
sample playback, and was available as a PC-9801-86 expansion card. Expected PMD playback behavior
differs a little between the chips, but I don't think there's any obvious way to figure out which
chip a PMD song is intended for from the file contents only. Files with the .M2 suffix are clearly
for the more advanced chip, but the plain .M suffix could be either. I think originally a separate
driver/player program was used on each platform, with the assumption that PMD files intended for
other platforms would just fail to work well. A modern player may need a switch to select a mode.

Tracks
======

Delineated by an array of words, LSB-first, PC98-native. These point to the start of data tracks.
The array length is usually 13 words, but can theoretically be shorter. Assume the array ends
where the first track begins.

Each melodic track is stored as a series of byte-size commands with possible data bytes following.
Melodic tracks normally end with the $80 end-of-track command, but in general each track runs up
to the start of the next one, or until end of file.

Some music tracks are duplicates, sometimes with a slight delay introduced, or a bit of detuning.
This allows for a fatter sound on FM chips, but it may be best to weed out these duplicate tracks
when doing a MIDI translation, unless the song sounds good with multiple instruments playing the
same thing.

The 11th track may be the "K" rhythm track. This has normal track commands, but instead of notes,
all bytes below $80 are rhythm pattern indexes, referencing the 12th track, "R". Each byte
indicates which pattern to paste in, once, building the 11th track into the actual rhythm track.
The 11th track still ends with $80 and has $F9 loops etc.

The rhythm tracks are only valid in mode 00, but exist in the other modes as well, though usually
empty. The music drivers for the other modes just won't play them. In those FM-focused modes,
rhythm is played using normal FM instruments.

The 12th and 13th tracks are special, in that aside from rhythm patterns, they also describe the
song's instruments, and may have some text fields for the song name and composer, etc. More on
those below.

If the first track's data begins with the command $C6 xxyy aabb ccdd, that activates a special
mode with three extra FM tracks, at the given addresses. If any address is 0000, then that track
is not used. You can process these tracks like the other melodic FM tracks.

Possible track types depending on mode [MML 1.1.3]:
  Mode 00:
    Tracks 1-6 = FM
    Tracks 7-9 = SSG
    Track 10 = PCM
    Track 11 "K" = Rhythm track (or PCM in FM-Towns mode)
    Track 12 "R" = Rhythm pattern definitions and metadata
    Track 13 = Metadata and instruments
    Tracks 14-16 = FM
    Tracks 17-24 = PPZ8 PCM
  Mode 01:
    Tracks 1-8 = FM
    Track 9 = PCM
    Tracks 10-11 = Ignored
    Tracks 12-13 = Metadata
  Mode 02:
    Tracks 1-9 = FM
    Tracks 10-11 = Ignored
    Tracks 12-13 = Metadata

Metadata tracks
===============

The two last tracks (12th and 13th) are metadata tracks.

With the 13th track present, the length of the 12th track is obvious.

If there is no 13th track, the 12th may be 8 unknown bytes followed by 4 useful bytes. If it's
shorter than 4 bytes, treat the track as empty. If the 12th track's first word points to within
~32 bytes of the file's end, then the 12th track is probably four bytes long. Otherwise it may be
12 bytes long. Unless there are Rhythm patterns, which are indicated by word addresses pointing to
locations inside the 12th track, which in that case may be much longer...

Normally, the 12th track's length is known, and it contains rhythm sequences, each terminating
with $FF, and a text array reference at the end. The rhythm sequences may or may not be valid, so
only try to parse them if the rhythm track actually references them. If the 12th track's final
byte is $FE, then the previous byte is usually $43..$48. The previous word is the address of the
array of string references, usually at the very end of the file. However, if the 12th track's
final byte isn't $FE, then there are no strings.

The string reference array ends with 0000. The references point to null-terminated Shift-JIS
strings, which may be empty. They always appear in this order:
  PPZ PCM file name, PPS SSG PCM file name, PCM file name, Title, Composer, Arranger.
  [MML 2.2, MML 2.3, MML 2.6, MML 2.7, MML 2.8, MML 2.9]
If the 12th track's second to last byte is $46 or below, the PPZ PCM file name is skipped.
Otherwise all 6 references should be present. If there are any further string references, those
are general-purpose Memo strings.

The 13th track contains instrument data.

Instrument definitions
======================
[MML 3.1]

Instrument IDs can't be assumed to map to General Midi, and in any case the IDs have a range of
0-255, while the normal MIDI instrument range is 0-127.

Each instrument uses a constant number of bytes depending on file mode. The 13th track ends with
the bytes 00 FF, immediately followed by text strings, an array pointing to them as referenced by
the 12th track, and the end of the file. Except if there are no strings at the end, then the 13th
track just ends at the end of the file without even a 00 FF.

Mode 00:
Here are some instrument definitions from EVE_05.M, rearranged slightly. 26 bytes each.
  _____________________________________________________________________________________________
   08 | 08 04 0A 04 | 14 00 00 00 | 1F 1F 1F 1F | 1B 10 1B 10 | 00 00 00 00 | F0 F8 F8 F8 | 35
   0A | 0F 00 08 00 | 13 7F 03 7F | 1F 1F 1F 1F | 00 00 0F 00 | 00 00 11 00 | 00 00 1F 0F | 3C
   0B | 7F 00 38 00 | 13 7F 00 7F | 1F 1F 1F 1F | 00 00 11 00 | 00 00 0B 00 | 00 00 4F 0F | 3C
   17 | 0F 00 31 00 | 00 00 18 00 | 1F 1F 5F 1F | 04 1A 15 00 | 00 00 04 0C | 01 DF 61 0F | 3B
   20 | 0F 02 00 01 | 07 09 02 00 | 1F 1F 5F 9F | 00 1F 10 0F | 00 0F 0F 0F | 06 F6 3F 7F | 3C
   2C | 7F 3F 7A 35 | 05 00 00 00 | 12 10 13 13 | 10 00 11 11 | 00 00 0E 0E | 10 00 18 18 | 2C
   4C | 0F 00 00 01 | 07 00 00 00 | 1F 1F 5F 1F | 00 17 0F 0F | 00 0F 0E 0F | 06 C6 2F 0F | 3C
      |             |             |             |             |             |             |
   2A | 7E 7E 72 72 | 17 17 00 00 | 1F 1F 1F 1F | 19 19 0F 0F | 0A 0A 06 06 | 30 30 19 19 | 04
   3A | 72 32 34 74 | 23 23 05 05 | 1F 1F 11 11 | 00 00 00 00 | 00 00 04 04 | 00 00 0A 0A | 04
   43 | 71 32 72 31 | 14 1E 00 00 | 1F 0C 11 11 | 09 00 00 00 | 00 00 02 02 | 40 00 0A 0A | 2C
  ____|_____________|_____________|_____________|_____________|_____________|_____________|____
   ID    -TTTmmmm      -lllllll      KK-aaaaa      @--ddddd      ---SSSSS      ssssrrrr    FB+A

The first byte is the instrument ID number. This is followed by six byte quartets, each quartet
corresponding to operators in the order 1-3-2-4. The last byte is [--FFFAAA], with a 3-bit
feedback level and a 3-bit algorithm selector.

Mode 01:
This is exactly the same as mode 0, except in addition to the 3-bit detune in the first quartet,
there's a second 3-bit detune in the top 3 bits of the 5th byte, right above the 5-bit sustain
fade rate.

Mode 02:
Since OPL chips have a different set of oscillators, the instrument definition looks different.
Here is an instrument definition track from 3sis song SS_12, rearranged. 10 bytes each.
  _____________________________________
   16 | 00 00 04 00 | F0 E0 00 08 | 06
   17 | 01 06 07 03 | F0 F0 0C 04 | 08
   20 | 0E 0F 00 84 | F9 F8 11 14 | 0E
   23 | 02 05 01 04 | F0 F1 F0 07 | 0E
   24 | 0F 0C 0D 06 | FF F7 01 08 | 0E
      |             |             |
   02 | E1 61 16 00 | A5 D7 24 16 | 0A
   2F | E2 F4 00 03 | F3 F3 D4 F4 | 01
   41 | 62 62 CA 00 | F9 F3 14 55 | 00
  ____|_____________|_____________|____
   ID   oscillators and envelopes  FB+A

  1st byte     op 1       op 2       op 1       op 2
.----------.----------.----------.----------.----------.
| iiiiiiii | tvekmmmm | tvekmmmm | ccllllll | ccllllll |
+----------+----------+----------+----------+----------+

    op 1       op 2       op 1       op 2     last byte
.----------.----------.----------.----------.----------.
| aaaadddd | aaaadddd | ssssrrrr | ssssrrrr | ----FFFA |
+----------+----------+----------+----------+----------+

  iiiiiiii = instrument number
  TTT = detune
  t = tremolo flag
  v = vibrato flag
  e = egt? Probably the flag for enabling the volume envelope sustain phase
  k = envelope scaling flag, enables key scale level when set
  mmmm = frequency multiplication factor, higher is higher pitch, each doubling is +1 octave
  cc = key scale level? attenuates output towards higher pitch, 0 = none, 3 = 6.0 dB/octave
  llllll = loudness or attenuation level, higher is quieter (or less modulative)
  KK = key scale rate? volume envelope rates are multiplied by this at higher pitch notes
  aaaa = attack rate, higher is faster
  @ = AMS mask flag
  dddd = decay rate, higher is faster
  SSSSS = sustain rate, higher causes sound to fade faster past sustain level until NoteOff
  ssss = sustain level, level at which decay stops and sustain starts, 1 = -3dB, 2 = -6dB
  rrrr = release rate, higher causes sound to fade faster after NoteOff
  FFF = feedback: 0 = 0%, 1 = 6.25%, 3 = 25%, 5 = 100%, 7 = 400%
  A = algorithm; assuming the value is passed directly to the OPL chip, 0 = FM, 1 = AM

The exact functions of these are best found in actual OPN/OPL programming guides.

If decay rate is 0, the operator will remain at 0 attenuation. Since the sustain phase is only
begun when decay has reached the sustain level of attenuation, if DR = 0 and SL != 0, the operator
is stuck at maximum volume until NoteOff. If DR = 0 and SL = 0, the sustain phase starts
immediately after attack. In either case, the release phase starts immediately on NoteOff.

The decay, sustain, and release rates' effect on attenuation is probably calculated identically.
The envelope runs independently of the song's tempo. Based on analysis of FM-PMD's output, the
time it takes to decay from full volume to silence can be approximated with this:
  decay duration in seconds = 0.48 * 0.5 ^ ((rate - 16) / 2), where rate is 1..31

Further observation suggests that the time taken to decay to half amplitude or about -6dB is:
  decay rate in seconds = 11.25 * 0.5 ^ (rate / 2), where rate is 1..31

Here are rough sketches of the algorithms, where an arrow indicates modulation. Where an operator
modulates its own frequency, that's feedback, whose strength can be separately controlled. The
OPN's algorithms are supposed to be the same as those on the OPM and the DX-21 synth, although the
operator numbering appears to be reversed. (Reminder: "AM" on OPL isn't amplitude modulation, it's
just adding operators.)

  Algorithm   Feedback   Modulators               Output
.-----------.----------.------------------------.---------------.
| OPL 0 FM  |   op 1   | 1 -> 2                 | 2             |
| OPL 1 AM  |   op 1   | none                   | 1 + 2         |
+-----------+----------+------------------------+---------------+
| OPN 0     |   op 1   | 1 -> 2 -> 3 -> 4       | 4             |
| OPN 1     |   op 1   | (1 + 2) -> 3 -> 4      | 4             |
| OPN 2     |   op 1?  | 2 -> 3, (1 + 3) -> 4   | 4             |
| OPN 3     |   op 1   | 1 -> 2, (2 + 3) -> 4   | 4             |
| OPN 4     |   op 1   | 1 -> 2, 3 -> 4         | 2 + 4         |
| OPN 5     |   op 1   | 1 -> 2, 1 -> 3, 1 -> 4 | 2 + 3 + 4     |
| OPN 6     |   op 1   | 1 -> 2                 | 2 + 3 + 4     |
| OPN 7     |   op 1   | none                   | 1 + 2 + 3 + 4 |
+-----------+----------+------------------------+---------------+

If an instrument hasn't been selected on a track, then the default instrument depends on mode:
  OPL: square wave
  OPN: ?
  SSG: square wave

It would be possible to write some fuzzy code to make decent guesses on what MIDI instruments
should be picked for each channel. It would also be a lot easier to just specify each instrument
by hand. Percussion is particularly problematic, since FM cymbals tend to all sound very alike,
mainly differentiated by individual note duration.

The pitch of the note played affects the percussion's pitch as well. While translating into MIDI,
probably the most important thing is to map the tom-toms into the melodic tom instrument, for
proper pitch control. Likewise the timpani.

Possible MIDI percussion assignments for OPL versions of 3sis/runaway/sakura:

  PMD instrument   Note range   Duration range      MIDI percussion
.----------------.------------.----------------.----------------------.
|      $0A       |   ???????  |       ???      | closed hi-hat?       |
|      $0B       |   ???????  |       ???      | open hi-hat?         |
|      $16       |   12 - 23  |       any      | bass drum     C-3/36 |
|      $23       |   14 - 14  |       any      | snare         D-3/38 |
|      $24       |   76 - 78  |       any      | closed hi-hat F#3/42 |
+----------------+------------+----------------+----------------------+
|      $20       |   91 - 94  |     16 - 19    | pedal hi-hat  G#3/44 |
|                |   91 - 94  |     20 - 48    | open hi-hat   A#3/46 |
|                |   90 - 94  |     49 - 72    | splash cymbal G-4/55 |
|                |   84 - 95  |       73+      | crash cymbal  C#4/49 |
+----------------+------------+----------------+----------------------+
|      $43       |   95 - 95  |      8 - 16    | cabasa        A-5/69 |
|                |   94 - 94  |     24 - 36    | open hi-hat   A#3/46 |
|                |     101    |     48 - 48    | splash cymbal G-4/55 |
|                |   95 - 95  |       49+      | crash cymbal  A-4/57 |
+----------------+------------+----------------+----------------------+

Splitting the third FM channel
==============================
[MML 2.20, MML 6.2]

This is a special feature of OPN chips, not available on OPM or OPL.

While normally restricted to 3 (OPN) or 6 (OPNA) 4-operator FM channels, the third channel's
operators can be controlled separately, allowing splitting the single 4-operator channel into two
2-operator tracks, or four single-operator tracks, or other combinations. This was obviously more
useful on the older chip, allowing more complex polyphony.

The channel can be split using the $C6 command. Operators used by each split track must then be
selected using the $CF command.

If a PMD file is targeting the older OPN chip, then the fourth through sixth FM tracks are already
by default split from the third, but with all operators masked. An explicit split command in this
case leaves the default split tracks empty, in favor of the three new tracks.

If the file is targeting the newer OPNA chip, then the fourth through sixth FM tracks are full FM
channels, and a split adds three extra tracks.

Playing a note in general sets the operator frequencies to that note, and switches all operators'
volume envelopes into their attack phase. However, this is skipped for any masked operators, so
the split tracks can play different notes without affecting each other.

Normally an instrument change command $FF on a track reads the instrument's parameters from the
instrument data track, and writes those into the four FM operators. Again, if an operator is
masked, then the instrument change only applies to the unmasked operators' parameters, plus it
sets the FM algorithm. The feedback parameter is only applied if operator 1 is not masked on the
effecting track.

There are a few other commands which tweak individual operator parameters on a track. These will
generally ignore operator masking, so a track can affect other split tracks by poking at shared
operators. However, composers are asked to please not do this, so it's not normally a problem.

The output of a split track still has to come from one or more carrier operators, as specified by
the selected FM algorithm. If a track doesn't have an unmasked carrier, it won't produce sound.
Unmasked modulators are applied to other unmasked operators only.

Example: Using algorithm 0 (1 -> 2 -> 3 -> 4 -> output), masking operator 3 will also cut off the
first two. The output will be a simple enveloped sine wave from operator 4. Masking operator 2 but
not 3 would result in a classic 3 -> 4 two-operator FM output.

Another example: Using algorithm 7 (no modulation, all operators are carriers), masking operators
3 and 4 will result in operators 1 and 2 being summed as output. Operator 1 can still use feedback
for a more interesting sound on this track.

Notes
=====
[MML 4.1]

The notes are stored per-channel, monophonically; chords are split across channels or arpeggioed.
Tones are notated as bytes, where the top nibble means the octave and the lower nibble the note in
the octave. There are 8 octaves, $00 though $7B. Example:
  $40 = C-4
  $42 = D-4
  $49 = A-4
  $4B = B-4 ($4C to $4F are left out)
  $50 = C-5

Although MML specifies various octave-selection commands, those are resolved at compile time into
the above note values. There are no specific octave selection commands in PMD files. Note that in
MML, "o1" is the lowest allowed octave, so "o1 c" will produce C-0.
[MML 4.4, MML 4.5, MML 4.6, MML 4.7]

On FM/SSG/PCM tracks, each note command is followed by a note length byte. Effectively, this is
how many ticks the note will play, NoteOn to NoteOff. Valid values are 0-255. Although MML again
specifies some length selection commands, those are resolved at compile time, so there's no need
to worry about them when reading a PMD file.
[MML 4.8, MML 4.9]

However, if staccato has been enabled, NoteOff is triggered earlier by the total staccato amount,
with an implicit rest for the remaining note duration. Staccato includes $C4 relative staccato,
$FE absolute staccato, and $B1 random staccato, which all stack. No matter how high the staccato
value, it can never reduce the note below a specific minimum note length. This is 1 tick by
default, and can be adjusted to be longer with the $B3 command. If a note's explicit duration is
shorter than the minimum staccatoed note length, the explicit duration is used and staccato is
ignored for that note.

Staccato is overridden, if the note command and its duration is followed immediately by $C1 or
$FB, tie/slur. In this case the note continues playing until the next note is triggered, or until
the next rest command.
[MML 4.10]

Sometimes $FB is followed by $DA, which is used for explicit pitch slides from note xx to note yy
over duration zz.

As a special case, when staccato is 0, if a $DA slide continues the note that was playing
immediately prior, the $DA should also have an implicit $FB, carrying the note smoothly into the
slide. This isn't how FM-PMD plays it (without an $FB the note is retriggered even if there's no
rest between noteoff and noteon), but there are some cases where pitch slides are obviously
supposed to continue the ongoing note, and the lack of $FB is merely masked by the lo-fi sound
quality. For an example, see track 6 in 3sis SS_02.

On the SSG rhythm track, byte values below $80 are actually rhythm pattern indexes instead of
notes, and don't have any additional data bytes. When a pattern index is encountered, paste the
indicated pattern into the rhythm track replacing the index byte.
[MML 6.7]

Rhythm and wave samples
=======================

There are four kinds of rhythm available:
- Built-in PCM samples, triggered with the $EB command. OPNA only. [MML 1.2.2, MML 14.1]
- Default SSG rhythm sounds, played on the rhythm track. OPN/OPNA only. [MML 1.2.1, MML 6.1.3]
- Custom-defined FM rhythm, played as normal FM sounds.
- Custom wave samples.

Depending on hardware configuration, different custom wave samples may be used:
- SSG PCM, relying on a "PPS" driver, samples loaded from a .PPS file
- PCM/ADPCM samples, loaded from a .PPC, .PVI, or .P86 file
- PPZ samples, loaded from a .PVI or .PZI file; two files can be loaded at the same time

The rhythm track is only really used for built-in SSG rhythm sounds. These are played on the 3rd
SSG channel, and take precedence over melodic notes. As long as a rhythm sound is playing, the
note is not played. Only one sound can play at once on each SSG channel. A song may of course
define its own noisy SSG instruments on any SSG channel and trigger those like normal notes.

There is a "PPS" driver, which plays SSG rhythm notes using PPS samples. SSG rhythm volume
can't be adjusted unless this PPS thing has been enabled. [MML 1.2.1]
With "PPS" active, two SSG rhythm sounds or samples can play simultaneously, provided its PDR
operation is in double mode, which it should be by default. [MML 15.2]
"PPS" allows loading custom samples from a .PPS file to override the default rhythm sounds.
It also has space for three extra rhythm sounds that are otherwise empty. SSG rhythm sounds,
with or without PPS, are playable with the $80..$87 commands. [MML 6.1.4]
I don't think it's possible to play PPS samples at different pitches, so they're useful for
rhythm and sound effects but not good for melodic sounds.

Built-in PCM samples can be triggered on any track. They are played on the PCM track anyway, so
they don't interfere with other notes on the triggering track.
Custom samples can be used by loading a wave data file or two. On the PCM track or extended PPZ
tracks, you can select an instrument and play notes normally. Pitch bending and fine volume
enveloping can be used. Only one PCM/ADPCM sample can play at a time. Two PPZ samples can play
simultaneously on separate PPZ tracks.
Sample mode can be set to PCM or ADPCM with the $C0 command. This changes how sample data is
interpreted, and how sample volume and looping is calculated. [MML 2.23, MML 15.10]
PCM/ADPCM/PPZ samples can select a part of the sample to loop as long as the note is on.
PCM/ADPCM can also define a release part that plays after noteoff. [MML 6.1.5]
PCM/PPZ are the only kind of sound that has proper stereo panning controls. [MML 13.2]

Examples from the Hoot archive:
- PPS samples are used by TMix98, AVG2, MP_BOX_98, and Virgin Angel
  (TMix98 uses PPS but tries to load a PPS02.PPS which I don't have...)
  (AVG2 tries to load CMLPPS1.PPS, which exists with a slightly different name...)
  (Rusty has some PPS files but they don't appear to be used...)
  (Virgin Angel has both PPC and PPS playing the same thing, likely should only play one...)

- PPC samples are used by GaoGao 1, Groundseed, Virgin Angel, MJGFant, and Sucharaka
  (GaoGao has LSP music files, which FMPMD happily plays, but they don't use the PPC file...)
  (MJGFant file N03 hangs FMPMD... S03 does work. None of them uses the PPC file...)

- PVI samples are only used by MForce, and FMPMD can't play its MDZ files...

- P86 samples are used by AVG2, Groundseed, Outsider, and MForce
  (No Groundseed song actually uses the P86 samples...)
  (Outsider uses samples, but FMPMD doesn't show it loaded the file and plays what sounds like
  the wrong sample indexes...)

- PZI samples are only used by Eve Burst Error

Although OPL chips have built-in FM rhythm sounds, using those requires switching to a rhythm
mode, which prevents using all 9 melodic channels. PMD doesn't bother with this, and always runs
in the full 9-channel mode, and as such doesn't support the built-in FM rhythm sounds. OPL music
has to define and use its own rhythm instruments like any other FM instrument.

Volume
======

There are a couple different volume values that all need to be considered together to calculate
the initial and ongoing volume of any note. For convenience, they are:

Track volume/channel volume:
  $FD to set, $F3/$F4 to adjust by one step, $E2/$E3 to adjust by any amount. Takes effect
  immediately, both on the current fading note and on any future note. Higher numbers are louder.
    PCM tracks: Range 0-255, default 128, step size 16. Linear, not logarithmic.
    SSG tracks, PPZ PCM: Range 0-15, default 8, step size 1.
    SSG rhythm tracks: Range 0-15, default 15, step size 1.
    FM tracks: Range 0-127, default 108, step size 4.

Next note volume tweak/accent:
  $DD/$DE to adjust. Directly increases/decreases track volume for the next note only at noteon.
  The following noteon afterward should restore the non-tweaked channel volume. This might be best
  translated to MIDI as a noteon velocity modifier, leaving the MIDI channel volume untouched.

Sound type volume attenuation:
  $C0 to set/adjust. Higher numbers are softer.
  All sound types: Range 0-255, default 0 = no attenuation.
  Since this is a global change, attenuation changes in the middle of a track must apply
  synchronously to all other tracks of the given type. Best applied as a MIDI track volume.

Master rhythm volume:
  $E8 to set, $E6 to adjust. Only affects $EB built-in PCM rhythm, not $8x SSG rhythm in rhythm
  patterns. Range 0-63, default 48, higher is louder. Best applied as a velocity modifier.

Rhythm specific instrument volume:
  $EA to set, $E5 to adjust. Range 0-31, default 15, higher is louder. Best applied as a velocity
  modifier. Only affects $EB built-in PCM rhythm, and not $8x SSG rhythm in rhythm patterns.

FM carrier attenuation:
  $B8 to set operator attenuation directly, otherwise it's a part of the instrument definition.
  On FM tracks, carrier operators' attenuation level directly affects the instrument's output
  volume. Changes to this immediately affect the loudness of that track. Which operators count as
  carriers depends on the active FM algorithm.

Global volume attenuation:
  $D2 to kick off. Used for song fade in/out. Range 0-255, default 0 = no attenuation, and
  255 = silence. Immediately affects all active notes on all tracks, and continues to do so as the
  fade completes.

Volume envelope:
  All tracks have an active volume envelope, specified by the instrument definition. $CD and $F0
  allow changing the SSG/PCM envelope directly. The FM envelope is only set by instrument
  definitions. For MIDI translation, while a carrier op's attack rate is intrinsically a part of
  the instrument, its release rate might be applied toward note off velocity. These could also be
  applied using MIDI expression commands.

Tremolo LFO:
  There is one hardware LFO (per channel?) and two software LFOs per track. Any of these can be
  applied to modulate an active note's volume. Although the most common volume effect of an LFO is
  a tremolo fluctuation, there are specialised LFO shapes that might function as an extra volume
  envelope. These could be applied using MIDI expression commands.

The "overall volume change" commands [MML 5.3] and [MML 5.4] change normal track volume commands
at compile time only. They have no especial handling when reading a PMD file.

Although it's probably safe to treat all the given ranges as linear for purposes of calculation,
the final generated sound output will need to use some kind of a logarithmic volume scale. Here is
a table showing the peak output amplitude each sound type produces at different PMD volume levels:

(Observed by compiling an MML file with a sine and square wave bleep at each volume, then
recording the file playback in Dosbox (0.74-3), FM-PMD (0.31, plus fixes), Anex86, and NP2kai
(commit f229197 2019-Oct-16) for verification, and examining the wave file. A more thorough
inspection should use real hardware and notes in more than one octave.)

(OPL amplitude is suggested to be 10^(0.075 * attenuation), here:
  https://github.com/stohrendorf/ppplay/blob/master/src/ymf262/envelopegenerator.h
That does give credible results if attenuation is further halved, and 1/x is applied, shown here
in the Expected column. Some sources suggest OPN may use a different curve than OPL, but this one:
  https://lipoyang.hatenablog.com/entry/20131112/p1
... thinks it's more of the same, ie. -0.75dB per attenuation step.)

.--------.--------.-------------------.--------.--------.--------.--------.
| OPL FM : Dosbox :     Expected      | OPN FM : FM-PMD : Anex86 : NP2kai |
+--------+--------+-------------------+--------+--------+--------+--------+
|  127   :   100% :       100%        |  127   :   100% :   100% :   100% |
|  126   :    92% : -0.75 dB   91.728 |  126   : 91.72% : 88.09% : 91.76% |
|  119   :    50% : -6 dB      50.119 |  119   : 54.55% : 47.62% : 50.02% |
|  111   :    25% : -12 dB     25.119 |  111   : 29.72% : 27.53% : 27.29% |
|  103   :  12.5% : -18 dB     12.589 |  103   : 16.21% : 13.84% : 13.65% |
|   95   :  6.25% : -24 dB      6.310 |   95   :  8.80% :  7.27% :  7.46% |
|   87   :  3.12% : -30 dB      3.162 |   87   :  4.78% :  3.72% :  3.72% |
|   79   :  1.55% : -36 dB      1.585 |   79   :  2.56% :  2.04% :  2.04% |
|   71   :  0.76% : -42 dB      0.794 |   71   :  1.42% :  1.07% :  1.02% |
|   63   :  0.42% : -48 dB      0.398 |   63   :  0.73% :  0.63% :  0.58% |
|   55   :  0.42% : -54 dB      0.200 |   55   :  0.38% :  0.37% :  0.30% |
|   47   :  0.42% : -60 dB      0.100 |   47   :  0.17% :  0.26% :  0.19% |
|   39   :  0.42% : -66 dB      0.050 |   39   :  0.07% :  0.16% :  0.10% |
|   31   :  0.42% : -72 dB      0.025 |   31   :  0.04% :      ? :  0.06% |
|   23   :  0.42% : -78 dB      0.013 |   23   :     0% :      ? :      ? |
|   15   :  0.42% : -84 dB      0.006 |   15   :     0% :      ? :      ? |
|    7   :  0.42% : -90 dB      0.003 |    7   :     0% :      ? :      ? |
|    1   :  0.42% : -94.5 dB    0.002 |    1   :     0% :      ? :      ? |
|    0   :     0% :         0%        |    0   :     0% :     0% :     0% |
+--------+--------+-------------------+--------+--------+--------+--------+

.---------.--------.--------.--------.--------.
| OPN SSG : FM-PMD : Anex86 : NP2kai | Approx |
+---------+--------+--------+--------+--------+
|   15    :   100% :   100% :   100% |   0 dB |
|   14    : 70.76% : 79.41% : 70.73% |  -3 dB |
|   13    : 50.00% : 50.44% : 50.03% |  -6 dB |
|   12    : 35.31% : 39.63% : 35.37% |  -9 dB |
|   11    : 25.00% : 25.87% : 25.04% | -12 dB |
|   10    : 17.62% : 18.73% : 17.69% | -15 dB |
|    9    : 12.50% : 13.61% : 12.52% | -18 dB |
|    8    : 12.50% :  9.75% :  8.87% | -21 dB |
|    7    :  8.77% :  6.42% :  6.29% | -24 dB |
|    6    :  6.15% :  4.56% :  4.44% | -27 dB |
|    5    :  4.32% :  3.28% :  3.17% | -30 dB |
|    4    :  3.07% :  2.58% :  2.25% | -33 dB |
|    3    :  2.13% :  1.62% :  1.61% | -36 dB |
|    2    :  1.54% :  1.43% :  1.13% | -39 dB |
|    1    :     0% :  0.95% :  0.84% | -42 dB |
|    0    :     0% :     0% :     0% |        |
+---------+--------+--------+--------+--------+

(I'm measuring peak amplitudes, because a root-mean-square would be thrown off by the sustain and
release of the instrument. An instrument's loudness may be best determined at the end of its
attack phase, which peak amplitude somewhat matches. I'm ignoring actual perceived loudness here,
since MIDI doesn't specify it, and as such volume levels should only apply to amplitudes.)

Todo: Blow the dust off my OPL4 sound card and record an FM sample to verify first-hand.

Anex86's SSG output has some kind of weird DC offset, causing every SSG note to be shifted upward
from center at NoteOn, rapidly converging to DC 0 afterward. Surely a bug? FM notes look normal.
Measurements from Anex86 and NP2kai are a bit imprecise at the low end due to the recording's
noise floor. On Anex everything also seems to have a bit of implicit tremolo, inflating its
figures slightly.

Native FM volume ranges are 0-127 on OPN, and 0-63 on OPL. However, because they attenuate at the
same rate, the 0-63 range produces similar volume levels on both. As such, all PMD files use
a 0-127 range for FM volumes regardless of OPL/OPN mode.

Based on the above, a joint FM volume curve using the given equation seems the best fit. The SSG
volume has obvious 50% and 25% points on FMPMD, but that has weird doubled volumes at 8-9 and 0-1,
surely incorrect. Using -3dB per attenuation step should be fine here.

  FM_amplitude(x) = 100% / (10 ^ ((127 - x) * 0.0375)), where volume x is 1..127
  SSG_amplitude(x) = 100% / (10 ^ (15 - x) * 0.15), where volume x is 1..15

MIDI volumes have a different amplitude curve, as defined in the DLS specification. But MIDI
implementations famously generally do whatever they want.
The specification from MIDI.org says:

  output = volume * expression * velocity * envelope * sample attenuation * AM * LFO tremolo

Furthermore, MIDI volume, expression, and velocity values each transform to amplitude like this:

  attenuation in dB = 20 * log10(127^2 / volume^2), where each 6.0206 dB halves the amplitude
  or,
  amplitude as fraction = (volume / 127)^2

The LFO and envelope use a modified version of that.

Therefore:

  MIDI volume = sqrt(16129 / (10 ^ (attenuation in dB / 20)))
  MIDI volume = sqrt(16129 / (10 ^ ((127 - FM volume) * 0.75 * 0.05)))
  MIDI volume = sqrt(16129 / (10 ^ ((15 - SSG volume) * 3 * 0.05)))

The below table has peak amplitude values recorded from four MIDI renderers at varying parameters:
Timidity++ (2.14.0) using the well-balanced EAWPats sound set, Fluidsynth using the sweet OPL3 FM
128 Mb sound set (AMidi-Plug as part of audacious-plugins 3.10.1-4 on Arch), Robbi-985's excellent
Bawami-tan softsynth using its default sound set (version 134), and Microsoft's GS wavetable synth
built into Windows XP with actual Roland Sound Canvas samples, the closest thing to an actual MIDI
instrument standard.

This evaluates each instrument in isolation, with a 100% amplitude baseline taken at the
instrument's maximum volume and velocity at note A-4; reverb and chorus disabled if possible.
Instruments have different top amplitude levels relative to each other, which is not being
evaluated here.

.------------.--------------------.--------------------.--------------------.--------------------.
| MIDI       | Timidity + EAWPats | Fluidsynth + OPL3  |     MS GS Synth    |     Bawami-tan     |
| specified  | Grand  Sqre   Acou | Grand  Sqre   Acou | Grand  Sqre   Acou | Grand  Sqre   Acou |
| amplitude  | Piano  Lead   Bass | Piano  Lead   Bass | Piano  Lead   Bass | Piano  Lead   Bass |
+------+-----+------+------+------+------+------+------+------+------+------+------+------+------+
|      | Volume (using note A-4, velocity 127)                                                   |
|      +-----+------+------+------+------+------+------+------+------+------+------+------+------+
| 100% : 127 | 100% : 100% : 100% | 100% : 100% : 100% | 100% : 100% : 100% | 100% : 100% : 100% |
| 76.4 : 111 | 80.0 : 80.0 : 79.9 | 76.7 : 76.7 : 76.7 | 70.9 : 95.4 : 86.3 | 84.1 : 82.6 : 85.3 |
| 56.0 :  95 | 61.7 : 61.8 : 61.7 | 56.2 : 56.2 : 56.2 | 51.0 : 71.0 : 65.2 | 69.9 : 69.5 : 70.1 |
| 38.7 :  79 | 45.5 : 45.4 : 45.4 | 38.9 : 38.9 : 38.9 | 36.9 : 48.9 : 45.0 | 53.9 : 54.6 : 56.8 |
| 24.6 :  63 | 31.2 : 31.2 : 31.2 | 24.8 : 24.8 : 24.8 | 23.0 : 30.2 : 28.3 | 41.2 : 43.0 : 43.4 |
| 13.7 :  47 | 19.2 : 19.2 : 19.2 | 13.8 : 13.8 : 13.8 | 12.5 : 17.8 : 16.5 | 29.1 : 29.3 : 32.1 |
| 5.96 :  31 | 9.61 : 9.62 : 9.59 | 6.00 : 6.00 : 6.01 | 5.21 : 7.50 : 7.27 | 19.0 : 19.8 : 18.9 |
| 1.40 :  15 | 2.87 : 2.88 : 2.89 | 1.37 : 1.38 : 1.39 | 1.21 : 1.76 : 1.62 | 8.66 : 9.23 : 8.91 |
| 0.01 :   1 | 0.08 : 0.08 : 0.08 | 0.00 : 0.00 : 0.00 | 0.00 : 0.00 : 0.00 | 1.97 : 1.12 : 0.70 |
+------+-----+------+------+------+------+------+------+------+------+------+------+------+------+
|      | Velocity (using note A-4, volume 127)                                                   |
|      +-----+------+------+------+------+------+------+------+------+------+------+------+------+
| 76.4 : 111 | 79.9 : 80.0 : 79.9 | 76.7 : 76.7 : 76.7 | 67.7 : 94.3 : 87.7 | 84.7 : 84.7 : 87.6 |
| 56.0 :  95 | 61.8 : 61.8 : 61.7 | 56.3 : 56.2 : 56.2 | 49.8 : 69.4 : 65.2 | 69.5 : 70.5 : 66.7 |
| 38.7 :  79 | 45.5 : 45.4 : 45.4 | 38.9 : 38.9 : 38.9 | 33.6 : 47.8 : 46.0 | 54.6 : 55.2 : 58.0 |
| 24.6 :  63 | 31.2 : 31.2 : 31.2 | 24.8 : 24.8 : 24.8 | 20.9 : 30.8 : 27.2 | 40.2 : 41.2 : 43.2 |
| 13.7 :  47 | 19.2 : 19.2 : 19.2 | 13.8 : 13.8 : 13.8 | 11.7 : 17.6 : 14.3 | 28.3 : 30.7 : 30.1 |
| 5.96 :  31 | 9.58 : 9.61 : 9.59 | 6.00 : 6.00 : 6.01 | 5.18 : 7.39 : 6.04 | 18.0 : 19.4 : 19.0 |
| 1.40 :  15 | 2.84 : 2.90 : 2.89 | 1.41 : 1.38 : 1.37 | 1.15 : 1.72 : 1.47 | 8.05 : 8.96 : 9.07 |
| 0.01 :   1 | 0.08 : 0.07 : 0.08 | 0.00 : 0.00 : 0.00 | 0.00 : 0.00 : 0.00 | 0.52 : 0.55 : 0.57 |
+------+-----+------+------+------+------+------+------+------+------+------+------+------+------+
|      | Note (using volume 111, velocity 111)                                                   |
|      +-----+------+------+------+------+------+------+------+------+------+------+------+------+
| 58.4 : C-0 | 63.9 : 64.0 : 55.0 | 72.6 : 51.3 : 51.8 | 41.9 : 83.5 : 81.5 | 81.4 : 94.2 : 91.6 |
| 58.4 : A-2 | 64.0 : 64.0 : 62.9 | 82.9 : 58.7 : 55.9 | 41.9 : 76.0 : 81.2 | 75.4 : 73.2 : 73.7 |
| 58.4 : A-4 | 64.0 : 64.0 : 63.9 | 58.9 : 58.9 : 58.9 | 47.7 : 75.6 : 67.5 | 69.9 : 69.9 : 71.4 |
| 58.4 : A-6 | 63.8 : 64.0 : 64.0 | 59.8 : 57.7 : 55.9 | 55.6 : 67.7 : 32.0 | 65.7 : 76.1 : 22.3 |
| 58.4 : G-9 | 61.7 : 61.9 : 45.7 | 60.6 : 51.4 : 43.1 | 25.8 : 110% : 4.57 | 60.0 : 96.5 : 49.8 |
+------+-----+------+------+------+------+------+------+------+------+------+------+------+------+

Findings: Fluidsynth has the most correct volume levels. The wavetable synths make no difference
between volume and velocity, with regard to amplitude, which is also broadly correct. The MS GS
synth reacts differently to velocity than volume, suggesting it is doing something more than just
playing back a single sample. Generative synths like Bawami-tan need to take special care that an
instrument's final output is at the correct amplitude; here its volumes are consistently too high,
and almost seem linear rather than logarithmic.

Todo: Extract relative instrument balances and ADSR's from MS GS synth and Fluidsynth + Fluid
soundfont. Play three notes on each instrument. Also one of each rhythm instrument. Try to include
GS instruments.

Track looping
=============

Tracks make clever use of a repetition feature. For example, a simple bassline can be surrounded
by a command to repeat it 16 times. Repetition can be nested, by at most 32 levels. Additionally
there's a main song loop to allow songs to keep playing forever, whose loop markers can also be
set separately on each track. All tracks loop independently of the others.

Note that there are also some global commands that can appear on any track but will affect all
tracks immediately, most notably global volume changes. All together, this means you're not going
to have a good time unless you process all tracks simultaneously in synch.

When encountering the $80 end of track marker, if an F6 main loop has been specified on that
track, jump track parsing back to the F6 mark. Once every track has encountered $80 at least once,
that's the true end of the main song loop; the main loop's true beginning is the last F6 marker.

This assumes that the song's main loop keeps repeating exactly the same way each time. However,
the PMD format doesn't enforce this, so the second time around the main loop could be different,
or the tracks could even loop completely asynchronously so they'll never line up. In such cases,
a clean MIDI translation probably isn't possible. Fortunately, composers don't normally use such
trickery.

It's normal for some tracks to have their main loops a dozen or a hundred ticks off, compared to
other tracks. One reason for this is if the song uses a common echo effect, where a track is
copied exactly to another track but with a short delay. The multi-channel notation in [MML 1.1.2]
is meant precisely for this. This fattens the sound nicely, but it means the echo track's loop
marker is also delayed.

Tempo, timing, ticks
====================
[MML 2.10]

PMD relies on note lengths for rhythm. By default, a "whole note" is 96 ticks. Possible values are
1-255 ticks.

In conventional music, tempo is beats per minute, where one beat is the bottom number of the
song's time signature. So a 3/4 song has 3 quarternotes in a bar, and BPM is quarternotes per
minute.

In PMD, the default whole note is 96 ticks, and tempo is defined as some number of 48-tick-notes
per minute. So the default whole note length assumes an x/2 time signature, half notes. If the
whole note has been increased to 192 ticks, then tempo is still some number of 48-tick-notes per
minute, but now refers to quarter notes, an x/4 time signature.

PMD also allows a more technical tempo "timerB" setting, for the timer trigger speed. By playing
some 3sis/saku songs in Dosbox at different cycle rates, it shows that TimerB has some processing
overhead, and songs' tempo increases slightly as cycle rates go up. When the game was published in
1996, western players would have been using 386's, 486's, and Pentiums, corresponding to cycle
rates 7800-77000. Japanese players would likewise have had comparable PC98 systems. Around the
speed of an average 486, the overhead starts to be negligible, and the tempo remains constant, so
that should be used for the most precise calculation. This does mean, however, that music for
older games is supposed to play slightly slower, but there's no way to tell from the PMD file
itself how fast the composer's computer was. This is mostly not a huge problem, as the tempo
difference will only be 1-2% even then.

The tempo calculation in pmdwin.cpp uses the constant 4396 (0x112c), but that consistently
produces slightly too fast tempos. My BPM measurements taken with Dosbox and Anex86 suggest 4296
is a more accurate value. It gives average results very close to the observed tempo.
  tempo = 4296 / (256 - timerB)
  timerB = 256 - 4296 / tempo
The default timerB is 200. Default tempo is therefore 4296 / 56 = 76.7 48-tick-notes per minute.
(Note that 256*3=768, and 16*3=48; maybe a coincidence, but programmers like powers of two, so I
think this must be close to the correct value.)

MIDI files also use ticks and beats, but differently. Note timings are still defined by ticks, and
ticks per beat can be changed (default 48), but the true MIDI tempo is defined as microseconds per
beat (default 500000).

I'm not sure how to get the measure length from .M files, since the Zxx command doesn't appear to
be saved by the MC tool. So, have to assume a default 4/4 time signature for purposes of MIDI
timing.

  MIDI tempo (using 48 ticks per beat) = 60 million / PMD tempo

With the tempo correctly translated, note lengths in ticks can be used interchangeably between PMD
and MIDI, without needing further translation.

Tempo is set with the $FC commands. These can appear on different tracks in the same song, and
must take effect globally.

List of commands
================

0F xx
Rest for xx ticks.
[MML 4.2]

80
Everywhere except as part of a rhythm pattern: Track end marker. Loop back to F6 loop start, if
one exists.

80..87 xx yy
Only as part of a rhythm pattern: SSG rhythm trigger. The duration of the sound is yy ticks.
The type of sound is cxx, where c is the lower nibble of the command byte. The type of sound is
a bitfield, allowing different rhythm sounds to be triggered simultaneously, although if the
"PPS" driver isn't active, only one sound can play at a time. With "PPS", two sounds can play
simultaneously, and any of these rhythm instruments can be replaced by a custom PPS sample, with
an extra three sample slots available.
  001 = bass drum
  002 = snare drum
  004 = low tom
  008 = mid tom
  010 = high tom
  020 = rimshot
  040 = clap (more like a wet snare slap)
  080 = closed hi-hat (very short tink, really just a metal blip)
  100 = open hi-hat (more like a ride cymbal, metallic tone rings through)
  200 = crash cymbal
  400 = soft ride cymbal
  800, 1000, 2000 = custom samples, loaded from a .PPS file
[MML 6.1.3, MML 6.1.4]

B1 xx
Random absolute staccato modifier, stacks with the other staccatos. Every subsequent note on this
track gets random(xx) added to its absolute staccato. A minimum note length still applies no
matter how high staccato gets.
[MML 4.13]

B2 xx
Set global transposition to (shortint) xx semitones. All subsequent notes on all tracks are played
transposed. Stacks with E7/F5 per-track transposition.
[MML 4.16]

B3 xx
Set the staccato limit on this track. Every note is guaranteed to be reduced to no less than xx
ticks no matter how much staccato is applied. This is always at least 1 tick, the default.
[MML 4.13]

B4 xxyy zzaa bbcc ddee ffgg hhii jjkk llmm
Only seen as the first byte on the PCM track. This spawns up to 8 new PPZ PCM tracks, with the
given offsets as each track's base. Ignore offsets of 0000.
[MML 2.25]

B5 xx yy
Set FM operator keyon delay to yy ticks. xx is a bitmask 1+2+4+8 for the FM ops. Should only
appear on FM tracks.
[MML 12.3]

B6 xx
Set FM feedback amount directly on FM tracks only. If xx is 0-7, set feedback to 0-7.
If shortint xx is -1 to -7, decrease feedback by that amount. If xx is $80-$87, increase feedback
by +0 to +7. The final value is capped at range 0-7.
[MML 6.4]

B7 xx
Set LFO depth evolution limit counter on this track. Top bit set = LFO2, top bit clear = LFO1. The
rest of the byte indicates how many times the D6/BD evolution may happen before the evolution is
disabled.
[MML 9.7]

B8 xx yy
Set operator attenuation directly on FM tracks only. xx indicates which FM operators to edit
(bitfield 1+2+4+8), with an additional +$80 if the change is relative instead of absolute.
yy indicates the volume 0-127 to set each selected operator to, or is a shortint if making
a relative change. Larger numbers are quieter, or less modulative.
[MML 6.3]
Although the 0-127 range natively applies to OPN, the same range is saved for OPL files as well.
The PMDIBM player probably just drops the most significant bit, since most of the useful
attenuation range is covered by 0-63.

B9 xx
Set LFO2 delay to xx ticks on this track.
[MML 9.1]

BA xx
Should only appear on FM tracks. Apply LFO2 on this track to FM operators, bitmask xx:
  01 = op 1
  02 = op 2
  04 = op 3
  08 = op 4
If xx = 00, LFO in vibrato mode affects all operators, while LFO in tremolo mode only affects the
carrier.
[MML 9.4]

BB xx
Set LFO2 speed adjustment by tempo on this track. If xx = 01, LFO speed is unaffected by tempo.
If xx = 00, the default, the LFO runs faster when tempo is higher.
Counterpart for LFO1 is CA.
[MML 9.5]

BC xx
Set LFO2 to waveform xx on this track, allowed range 0-6. See the MML manual for waveform shapes.
The default is 0, basic triangle wave. Counterpart for LFO1 is CB.
[MML 9.2]

BD xx yy
Set LFO2 depth evolution on this track. Once each xx LFO cycles, LFO depth ($BF parameter zz) is
adjusted by shortint yy. If B7 depth evolution limit is set, the depth adjustment is only done up
to so many times (by default infinite).
If yy is negative, LFO depth only goes as low as 0. When an LFO is reset (usually at note on), its
accumulated depth evolution is also reset.
[MML 9.7]

BE xx
Set LFO2 usage on this track, bitmask:
  00 = default, disabled
  01 = affect pitch (vibrato)
  02 = affect volume (tremolo)
  04 = disable keyon synch (so LFO keeps running uninterrupted on new note)
Vibrato shouldn't appear on PCM tracks?
On a rhythm track, this becomes the PDR operation mode control command?..
[MML 9.3, MML 15.2]

BF xx yy zz aa
Set LFO2 parameters on this track. Works the same as the F2 command for LFO1.
[MML 9.1]

C0 xx, where xx = 00 or 01
Masks or mutes the track if xx = 01, otherwise unmutes. This track muting is a separate thing from
FM operator masking.
[MML 15.7]

C0 xx yy, where xx = F7
Sets PCM channel to PMD86 normal mode if yy = 0, or PMDB2 compatibility mode if yy = 1.
In PMDB2 compatibility mode, ADPCM is expected instead of PCM, which changes how volume and sample
looping are calculated.
[MML2.23, MML 15.10]

C0 xx yy
Changes a particular sound type's volume attenuation globally. This stacks with all the other
volume settings. The allowed range for each type is 0-255, where 0 is maximum volume, and larger
numbers attenuate it. If yy = 0, resets that type's attenuation to default, which is 0.
  xx = FF: Set FM attenuation to yy
  xx = FE: Adjust FM attenuation by shortint yy
  xx = FD: Set SSG attenuation to yy
  xx = FC: Adjust SSG attenuation by shortint yy
  xx = FB: Set PCM attenuation to yy
  xx = FA: Adjust PCM attenuation by shortint yy
  xx = F9: Set rhythm attenuation to yy
  xx = F8: Adjust rhythm attenuation by shortint yy
Although this can appear on any track at any time, it is normally only found at the very start of
the seventh track. Expecting C0 only there could allow for a simpler MIDI translation.
I'm not sure what exactly rhythm attenuation is supposed to affect. Doesn't seem to do anything to
SSG or PCM rhythm.
[MML 15.4]

C1
Enable "slur" for the next note. This keeps playing the current note without a NoteOff, ignoring
the current staccato value. When the next note occurs, there is an immediate NoteOff and NoteOn to
trigger the new note.
The FB "tie" works similarly to this, except it switches to the next note without a new NoteOn.
C1 may appear more than once between adjacent notes, but this has no particular extra effect.
C1 must follow the note (or DA pitch slide) it modifies immediately, with no other commands in
between. C1 following any other command is ignored.
If C1 is followed by a rest, staccato is still ignored, but NoteOff is applied at the start of the
rest.
[MML 4.10]

C2 xx
Set LFO1 delay on this track to xx ticks.
[MML 9.1]

C3 xx yy
Set track panning to shortint xx, fake surround enabled if yy = 01.
The meaning of xx depends on track type and mode (00 is always center):
  FM-OPM: -1 or less = left, +1 or more = right
  FM-OPNA: -1 or less = right, +1 or more = left
  PCM-AD: -1 or less = right, +1 or more = left
  PCM-68: -1 or less = left, +1 or more = right
  PCM-86: -1 to -128 = rightward, +1 to +128 = leftward
  PCM-PPZ: -4 or less = hard left, -3 to +3 = left to right, +4 or more = hard right
  SSG: not allowed?
[MML 13.2]

C4 xx
Relative staccato setting, can be adjusted separately from absolute staccato, which stacks with
this. The setting's range is 0-255, causing each subsequent note to be shortened by xx/255 of its
nominal duration, with an implicit rest of the cut length.
[MML 4.12]

C5 xx
Should only appear on FM tracks. Apply LFO1 on this track to FM operators, bitmask xx:
  01 = op 1
  02 = op 2
  04 = op 3
  08 = op 4
If xx = 00, LFO in vibrato mode affects all operators, while LFO in tremolo mode only affects the
carrier.
[MML 9.4]

C6 xxyy aabb ccdd
Enable explicit third FM channel extension. Each of the three addresses points to an extra FM-type
track, or 0000 for not used. This must always be the first command on the first track, if present.
This command is used to split the third FM channel into up to 4 tracks, and each split track is
responsible for masking away any operators it doesn't need, so the tracks don't mess with each
other.
This feature is only available for OPN mode files. FM Towns and western OPL don't support this.
If the file is targeting the older OPN chip, then the fourth through sixth FM tracks are already
by default split from the third, but with all operators masked. An explicit split command in this
case leaves the default split tracks empty, in favor of the three new tracks.
If the file is targeting the newer OPNA chip, then the fourth through sixth FM tracks are full FM
channels, and a split adds three extra tracks.
[MML 2.20]

C7 xx yyzz
Adjust FM operator detune directly, on the third FM track only. Operator xx is changed by
int16 yyzz.
  01 = op 1
  02 = op 2
  04 = op 3
  08 = op 4
If the third FM channel has been split, adjusting op detune on any such split track will apply the
detune across all split tracks, regardless of operator masking on this track.
[MML 7.2]

C8 xx yyzz
Set FM operator detune directly, on the third FM track only. Operator xx is set to int16 yyzz.
  01 = op 1
  02 = op 2
  04 = op 3
  08 = op 4
If the third FM channel has been split, adjusting op detune on any such split track will apply the
detune across all split tracks, regardless of operator masking on this track.
[MML 7.2]

C9 xx
Set SSG/PCM volume envelope adjustment by tempo. If xx = 01, envelope speed is unaffected by
tempo. If xx = 00, the default, envelope runs faster when tempo is higher.
[MML 8.2]

CA xx
Set LFO1 speed adjustment by tempo on this track. If xx = 01, LFO speed is unaffected by tempo.
If xx = 00, the default, the LFO runs faster when tempo is higher.
Counterpart for LFO2 is BB.
[MML 9.5]

CB xx
Set LFO1 on this track to waveform xx, allowed range 0-6. See the MML manual for waveform shapes.
The default is 0, basic triangle wave. Counterpart for LFO2 is BC.
[MML 9.2]

CC xx
Set SSG pitch interval correction. xx = 00 for off, 01 for on. Should only occur on SSG tracks.
When enabled, FA/D5 pitch bends will use a constant range of +/- 256 for +/- 1 semitone,
regardless of the note or octave being played. When disabled, the pitch bend commands use
a different range depending on note and octave. See the FA command for details.
[MML 7.3]

CD xx yy zz ab cc
Set SSG/PCM volume envelope parameters on this track:
  xx = Attack rate 0-31, where higher values attack faster:
       value [0] causes attack to be ignored, and the note remains at initial attack level
       values [1..16] apply +1 volume every (18 - xx) ticks
       values [17..31] apply (xx - 16) volume every tick
  yy = Decay rate 0-31, where higher values decay faster toward the inverted sustain level:
       value [0] causes decay to be ignored, and also ignores the sustain phase if SL > 0
       values [1..16] apply -1 volume after every (34 - yy * 2) ticks
       values [17..31] apply (16 - yy) volume every tick
  zz = Sustain rate 0-31, where higher values decay faster during the sustain phase:
       value [0] causes sustain to not decay
       values [1..16] apply -1 volume every (34 - zz * 2) ticks
       values [17..31] apply (16 - zz) volume every tick
  b  = Release rate 0-15, where higher values release faster:
       value [0] causes release to be ignored, and the note keeps playing until next noteon
       values [1..8] apply -1 volume every (18 - b * 2) ticks
       values [9..15] apply (16 - b * 2) volume every tick
  a  = Sustain level 0-15, where 0 is maximum volume, 15 is silence.
  cc = Attack initial level 0-15, where 15 is maximum volume, 0 is silence.
The above tick counts apply when envelope speed is dependent on tempo, the default. [MML 8.2] The
above tick/volume values are derived from analysing FM-PMD's output, which may not be correct.
The volume envelope is multiplied with the normalised channel volume, so both can use their full
dynamic range. The F0 command is a related, different way to define a volume envelope.
May occur on FM tracks too, but doesn't appear to do anything there. FM-PMD ignores CD on FM
tracks, and such songs (eg. EVE_21.M) sound no different in-game, at least using the NP2 emulator.
[MML 8.1.2]

CE xxyy aabb ccdd
PCM tracks only. Sets the PCM sample loop start to offset xxyy, sample loop end to offset aabb,
and the release offset to ccdd. This is a direct offset for PMD86/PPZ tracks, but is multiplied by
16 for PMDB2/PMDVA tracks.
Positive offsets are counted from the sample's beginning, while negative offsets
are counted from the sample's end. If ccdd is not $8000, then on noteoff sample playback will jump
to the ccdd offset, and play through to the sample's end without further looping. If ccdd is
$8000, then the sample will continue looping and it's up to the volume envelope to fade it out.
[MML 6.1.5]

CF xx
Set FM operators or "slots" to use on this track, top nibble of xx is a bitmask:
  01 = op 1
  02 = op 2
  04 = op 3
  08 = op 4
Set a bit to enable the operator, clear the bit to mask it. A masked operator's parameters are not
modified by instrument change commands on this track, and played notes only affect the frequency
of non-masked slots.
This allows splitting the third FM track into up to four separate tracks, with each track using
a subset of the four operators. (If tracks try to share operators, they effectively overwrite each
other's parameters and notes.)
You can mask operators on other full FM tracks as well, but that just disables the specified
operators, and you don't really gain anything.
[MML 6.2]

D0 xx
Adjust noise generation frequency by shortint xx. Larger numbers produce lower-frequency noise.
Supposed to be limited to -31 to +31, but might go up to max shortint?
[MML 6.6]

D2 xx
Start global fadeout, adjust global volume by shortint xx, once every 8 ticks? Global volume
starts at 0, the loudest, and can go up to 255, which would silence everything.
[MML 15.3]

D3 xx
Play FM sound effect xx. Stop playback if xx = 0.
[MML 15.5]

D4 xx
Play SSG sound effect xx, or SSGPCM effect if x >= 128. Stop playback if xx = 0.
[MML 15.6]

D5 xxyy
Adjust track pitch bend by int16 xxyy. Counterpart to FA. Bend range changes are handled at
compile time, so track pitch always exists in the same range. For notes on how to translate these
values to semitones, see the FA command.
[MML 7.1]

D6 xx yy
Set LFO1 depth evolution on this track. Once each xx LFO cycles, LFO depth ($BF parameter zz) is
adjusted by shortint yy. If B7 depth evolution limit is set, the depth adjustment is only done up
to so many times (by default infinite).
If yy is negative, LFO depth only goes as low as 0. When an LFO is reset (usually at note on), its
accumulated depth evolution is also reset.
[MML 9.7]

D7 xx
Set hardware LFO frequency to xx.
[MML 9.12]

D8 xx
Set hardware LFO vibrato/tremolo depth. If xx is in 0-127, tremolo depth is set to xx. If xx is -1
to -64, vibrato depth is set to xx. If xx is 128-191, vibrato depth is set to xx - 128.
[MML 9.12]

D9 xx
Set hardware LFO waveform to xx. Allowed range = 0-3.
[MML 9.12]

DA xx yy zz
Pitch slide (portamento) from note xx to yy, duration zz ticks. Staccato applies normally. The
slide is calculated to reach note yy at the end of zz ticks, but if the duration has been reduced
by staccato, the slide still runs at the same speed, and a NoteOff is generated while the slide is
still ongoing. If the sound has a slow release, it may still reach the target note while fading.
There may be an FB/C1 tie/slur command before and after DA. These are applied just like with
normal note triggers. If preceded by FB, the initial slide note should do a legato flow from the
previous playing note. If followed by FB or C1, ignore staccato and carry the pitch slide through
its full duration. The FB/C1 following must follow immediately, and is ignored if any other
commands are between it and DA.
The played notes are shifted by E7/F5 per-track transposition plus B2 global transposition.
Can't be used on the rhythm channel.
[MML 4.3]

DB xx
Adjust "Status1" byte by shortint xx. This is a value that a game can query by some other
mechanism, if it needs to synchronise with a music track for some reason. There's no bounds check,
so Status1 will happily rollover from 255 to 0.
[MML 15.9]

DC xx
Set "Status1" byte to xx. This is a value that a game can query by some other mechanism, if it
needs to synchronise with a music track for some reason.
[MML 15.9]

DD xx
Adjust the volume of the next note only on this track, down by xx. Respect the volume bounds of
the track.
  FM track: range 0-127
  SSG/rhythm/PPZ track: range 0-15
  PCM track: range 0-255
[MML 5.5]

DE xx
Adjust the volume of the next note only on this track, up by xx. Respect the volume bounds of the
track.
  FM track: range 0-127
  SSG/rhythm/PPZ track: range 0-15
  PCM track: range 0-255
[MML 5.5]

DF xx
Whole note length setting, probably. Also seems to be produced by the Zxx measure length command,
which doesn't seem right. This is the number of ticks to count per whole note. May force a tempo
recalculation?..
[MML 4.11, MML 15.8]

E0 xy
Set hardware LFO usage/depth. If the bottom nibble is 08-0F, the LFO is enabled, at depth y - 8.
[MML 9.11]

E1 xy
Set hardware LFO pitch/volume change speed. Pitch change speed is the lower nibble of xy, volume
change speed is the higher nibble. Should only appear on FM tracks?
[MML 9.10]

E2 xx
Track volume down by xx. Respect the volume bounds of the track.
  FM track: range 0-127
  SSG/rhythm/PPZ track: range 0-15
  PCM track: range 0-255
[MML 5.5]

E3 xx
Track volume up by xx. Respect the volume bounds of the track.
  FM track: range 0-127
  SSG/rhythm/PPZ track: range 0-15
  PCM track: range 0-255
[MML 5.5]

E4 xx
Set hardware LFO delay to xx ticks after noteon. Should only appear on FM track?
[MML 9.10, MML 9.13]

E5 xx yy
Adjust the individual built-in PCM rhythm sound xx volume by shortint yy. Volume range is 0-31,
default 15. Larger is louder.
  1 = bass drum
  2 = snare
  3 = ride cymbal
  4 = closed hi-hat
  5 = tomtom
  6 = rimshot
[MML 14.3]

E6 xx
Adjust the master volume for the EB built-in PCM rhythm triggers on this track by shortint xx.
Default master rhythm volume starts at 48. Cap the volume range at 0-63. Higher is louder.
[MML 14.2]

E7 xx
Adjust track's note transposing from current value by (shortint) xx semitones. Stacks with B2
global transposing.
[MML 4.14]

E8 xx
Set the master volume for the EB built-in PCM rhythm triggers on this track. Cap the volume at
0-63. Default master rhythm volume is 48. Higher is louder.
[MML 14.2]

E9 xx
Set the individual built-in PCM rhythm sound panning on this track. The top 3 bits have a value
1-6, signifying the rhythm type. The bottom two bits signify the pan position:
  2 = left
  1 = right
  3 = middle (both)
[MML 14.4]

EA xx
Set the individual built-in PCM rhythm sound volume. The top 3 bits of xx have a value 1-6,
signifying the rhythm type, and the bottom 5 bits are the volume. The volume range is 0-31,
default 15, larger is louder.
  1 = bass drum
  2 = snare
  3 = ride cymbal
  4 = closed hi-hat
  5 = tomtom
  6 = rimshot
[MML 14.3]

EB xx
Trigger a built-in PCM rhythm sound. xx is a bitmask to select which sounds are desired. If $80 is
set, that means to note off instead of note on.
  01 = bass drum
  02 = snare
  04 = ride cymbal
  08 = closed hi-hat
  10 = tomtom
  20 = rimshot
These are only available in OPN mode, and can play simultaneously with all other channels. These
are ignored in OPL mode, where rhythm can only be used by defining suitable sounds for normal FM
instruments.
The EB command can appear on any track, not just the rhythm or PCM track. Only one of these can
play at the same time. Songs aren't forced to off notes, so a MIDI conversion would have to keep
track of notes and off them explicitly if still on when the same sound is triggered again, or the
main loop ends.
The global rhythm volume can be modified with the commands E8/E6; the individual types with EA/E5.
[MML 14.1]

EC xx
Set track panning to xx. Allowed values depend on file mode and track type?
  00 = PCM only, fake surround
  01 = OPM-FM or PCM-68: left; otherwise: right
  02 = OPM-FM or PCM-68: right; otherwise: left
  03 = center
[MML 13.2]

ED xx
Set tone/noise generation to xx.
  $00 = silence?, $07 = tone, $38 = noise, $3F = both
Should be different on SSG/FM tracks, but the output looks the same... Presumably defaults to tone
being enabled and noise disabled.
[MML 6.5]

EE xx
Set noise generation frequency to xx. Larger numbers produce lower-frequency noise. Supposed to be
limited to 0-31, but might go up to 255?
This is supposed to be limited to mainly SSG tracks only, but it can appear anywhere, it'll just
be ignored outside SSG tracks.
[MML 6.6]

EF xx yy
Feed byte yy to the FM chip's address xx. Only useful if emulating the actual chip.
[MML 15.1]

F0 xx yy zz aa
Set SSG/PCM volume envelope parameters: attack length, decay depth, sustain rate, release rate.
Shouldn't appear on FM tracks. Some special named combinations:
  00 00 00 00 = default square wave
  02 FF 00 01 = Synth 1
  02 FE 00 01 = Synth 2, more distinct attack and slightly stronger decay
  02 FE 00 08 = Synth 3, more distinct attack and slightly stronger decay, gradual release
  02 FF 18 01 = Piano 1
  02 FE 18 01 = Piano 2, more distinct attack and slightly stronger decay
  02 FE 04 01 = Glockenspiel/Marimba, rapid decay
  02 01 00 01 = Strings
  01 02 00 01 = Brass 1
  01 02 18 01 = Brass 2, not sustained
Allowed ranges: AL 0-255, DD -15 to +15, SR 0-255, RR 0-255.
The note plays at the channel's volume for AL ticks, then gets shortint(DD) added to it. The note
volume may be pushed above 15 by this, but the output volume remains capped at 15, so the sustain
and release phases only become noticeable after bringing the note volume below 15. In the sustain
phase, -1 is applied to the note volume every SR ticks until a noteoff begins the release phase,
where -1 is applied every RR ticks.
If SR = 0, it sustains without fading; if RR = 0, release is immediate.
The above is derived from analysing FM-PMD's output, which may not be correct.
To vaguely translate to the CD command's style:
  attack start level = if shortint(DD) > 0, then level = 15 - shortint(DD), else level = 15
  attack rate (fractional) = attack start level / AL; if shortint(DD) > 0, then rate += 16
  decay rate = immediate, 31
  sustain level = if shortint(DD) > 0, then level = 0, else level = -shortint(DD)
  sustain rate = if SR > 0, then rate = 17 - SR / 2 (cap result above 0), else rate = 0
  release rate = if RR > 0, then rate = 9 - RR / 2 (cap result above 0), else rate = 15
[MML 6.1.2, MML 8.1]

F1 xx
Set LFO1 usage on this track, bitmask:
  00 = default disabled
  01 = affect pitch (vibrato)
  02 = affect volume (tremolo)
  04 = disable keyon synch (so LFO keeps running uninterrupted on new note)
Vibrato shouldn't appear on PCM tracks?
On a rhythm track, this is instead the PDR operation mode control command:
  00 = Double mode, can play two rhythm samples simultaneously?
  01 = Single mode
  02 = 16kHz mode, better quality mixing?
  03 = 8kHz mode
  04 = EI mode??
  05 = DI mode??
[MML 9.3, MML 15.2]

F2 xx yy zz aa
Set LFO1 parameters on this track. The BF command is used for LFO2.
Delay xx ticks from noteon, adjust every yy ticks afterward, by (shortint) zz amount, with aa
repetitions per phase. The MML document describes how each waveform uses these values.
High values of yy cause the LFO effect to be noticeably stepped. A value of 1 or 2 gives a smooth
ride along the waveform.
Interpretation of zz depends on track type (tested using the one-shot waveform):
  OPN: one semitone = 50
  OPL: one semitone = 25? OPL is twice as sensitive...
  SSG: if SSG pitch interval correction is enabled for this track, one semitone = 256.
    If it is disabled, then one semitone = 8 at G-4, 16 at G-3, 32 at G-2.
    This can be calculated using the expression
      f(x) = 192 * 0.5 ^ (x/12)
    where x is 0 for C-0 (note number 0), and increases by 1 per semitone.
The CB/BC commands are used to select the LFO wafeform.
For the default triangle waveform, the value of (shortint) zz is added to the current note once
every yy ticks, aa times before being negated. Then it is added aa*2 times, before being negated
again. Therefore, the LFO cycles once in yy * aa * 4 ticks, with a depth of
+/- (zz * aa / semitone_size) semitones.
MIDI vibrato is poorly defined, but assume a constant rate, and at maximum vibration a depth of
+/- 1 semitone.
The PMDIBM driver for OPL chips doesn't seem to implement software LFO's?
[MML 9.1]

F3
Decrease track volume:
  SSG/rhythm/PPZ channel: -1 (bounds 0..15)
  FM channel: -4 (bounds 0..127)
  PCM channel: -16 (bounds 0..255)
[MML 5.5]

F4
Increase track volume:
  SSG/rhythm/PPZ channel: +1 (bounds 0..15)
  FM channel: +4 (bounds 0..127)
  PCM channel: +16 (bounds 0..255)
[MML 5.5]

F5 xx
Set track's note transposing. All subsequent notes on this track are transposed by (shortint) xx
semitones. Stacks with B2 global transposing.
[MML 4.14]

F6
Track loop begin marker; jump back here automatically from end of track. One of these should exist
on every track that loops.
[MML 10.2]

F7 xxyy
When playing the last repetition of the containing loop F9 xxyy where the xxyy is the same as
here, this breaks out of the loop. If it's not yet the last repetition, do nothing.
If the loop is infinite, F7 is ignored.
[MML 10.1]

F8 xx yy aabb
Repeat xx times from the F9 command at aabb. If xx is 0, repeat infinitely, so the original F9 is
actually an F6.
The yy appears to be the repetition counter, which should always be the same as xx, unless there's
an F7 early break in the loop, in which case it's xx - 1. yy could also be just 00, in which case
count to xx normally anyway.
[MML 10.1]

F9 xxyy
Begin a repeat sequence; xxyy is the address of the sequence-ending F8 command parameters. Repeat
sequences can be nested up to 32 levels.
[MML 10.1]

FA xxyy
Set track detune or pitch bend to xxyy. Counterpart to D5. This is normally only used for slight
detuning by a few cents, for a fatter sound. Due to the terrible pitch accuracy, the separate DA
command is used for pitch slides.
  PCM tracks: same as SSG?
  Rhythm tracks: not allowed, or same as SSG?
  SSG tracks: If SSG pitch interval correction is enabled for this track, +/- 256 is one semitone.
    If it is disabled, then +/- 32 is one semitone at C-4; +/- 64 at C-3; and +/- 128 at C-2.
    This can be calculated using the expression
      f(x) = 512 * 0.5 ^ (x/12)
    where x is 0 for C-0 (note number 0), and increases by 1 per semitone.
  FM tracks: bend range changes are handled at MML compile time, so the FA command has a constant
    bend range. The bend amount doesn't have a simple relationship with the resulting frequency.
    The pitch change required depends on the note being played, but not the octave.
    Approximate +1 semitone on OPN (tuned by ear):
      C  = +36
      C# = +37
      D  = +38
      D# = +40
      E  = +43
      F  = +45
      F# = +48
      G  = +50
      G# = +53
      A  = +56
      A# = +60
      B  = +64
      C back down to B = -64
    But if you try to move more than 1 semitone, simply adding these numbers won't be in tune, and
    I don't know how to calculate it more exactly. The above can be approximated with the equation
      f(x) = 6/55 * x^2 + 74/55 * x + 36
    where x ranges 0..11 for C..B.
    The song P14 in Princess Maker 2 suggests that +/- 50 should on average count as 1 semitone.
    OPL is twice as sensitive, so it uses these values divided by two.
MML commands D and I both produce the FA command, with D setting the FM pitch bend directly, and I
trying to map a semitone more precisely depending on the base frequency. However, in both cases
the result is more or less out of tune, FM being quite difficult to tune perfectly.
While it would be possible to use MIDI pitch bends for this, the actual detune controller might be
preferable, although it's not supported everywhere.
Detuning has some special behavior around repetition sequences, but it's all done at compile time;
in some conditions detune is implicitly reset on loopback or loop exit, but that's done by
generating an extra FA command, so requires no special handling.
[MML 7.1, MML 7.4, MML 7.5]
Master detune is added into normal detuning at compile time, so it needs no especial handling.
[MML 7.6]

FB
Enable "tie" or legato for the next note. This keeps playing the current note without a NoteOff,
ignoring the current staccato value. When the next note occurs, the active note's pitch is set to
the new note, but without retriggering the note. If the next note is the same as the previous
note, the note simply continues playing without interruption.
The C1 "slur" works similarly to this, except it does retrigger the note on the next NoteOn.
FB may appear more than once in a row, but this has no particular extra effect.
FB must follow the note (or DA pitch slide) it modifies immediately, with no other commands in
between. FB following any other command is ignored.
If FB is followed by a rest, the note keeps playing without interruption.
This may be best translated to MIDI using the legato pedal controller or instant portamento.
[MML 4.10]

FC FD xx
Adjust global tempo by shortint xx. Valid result values are 18-255.
[MML 11.1]

FC FE xx
Adjust global timerB tempo by shortint xx. Valid result values are 0-250.
[MML 11.2]

FC FF xx
Set global tempo to xx. Valid result values are 18-255.
[MML 11.1]

FC xx
Set global timerB tempo to xx. Valid result values are 0-250.
[MML 11.2]

FD xx
Set the track volume to xx.
  PCM tracks: Valid range is 0-255, simple linear multiplier? Default 128.
  SSG/PPZ tracks: Valid range is 0-15, default 8. Larger values may be encountered, but it's not
    clear what they mean, and can probably be ignored.
  FM tracks: Valid range is 0-127, logarithmic. Default 108.
  SSG rhythm track: Valid range is 0-15. Default 15.
[MML 5.1, MML 5.2]

FE xx
Set absolute staccato on this track to xx ticks; 00 is no pause between notes. Each subsequent
note on this track is shortened by this amount, followed by an implicit rest of the cut duration.
Can be adjusted separately from relative staccato, which stacks with this.
Staccato is ignored if FB/C1 tie/slur is used.
[MML 4.13]

FF
Rhythm pattern only: ends the pattern.

FF xx
FM and PCM tracks: Select instrument xx, as defined in the instrument metatrack. Shouldn't exist
on SSG channel, since those are expanded at compile time to an F0 command. Instrument numbers can
go up to 255.
[MML 6.1.1]
The instrument parameters won't be applied on any operators that have been masked with the CF
command. The feedback parameter is only applied if operator 1 is not masked on this track. The FM
algorithm used by the instrument is set regardless of masking.
[MML 6.2]

Operating environment

The program is designed to run in a Win32 environment with a sound card, DirectX7 or DirectX9, and IE6 (Microsoft's XML parser: MSXML3) installed.
sound card, DirectX7 or DirectX9, IE6 (Microsoft's XML parser: MSXML3) installed in Win32 environment. It is
If you don't have them, you will get an error immediately.
Create a directory with the name contained in data_dir in shoot.ini, and put the data files in it.
The YM2608 rhythm sound data is based on M88.
Please put them in the same directory as shoot.exe.
Please place it in the same directory as shoot.exe.

If you start it with the -list option, it will output drivers.xml in the current directory.
When started with the -list option, drivers.xml is output to the current directory.

When invoked with the -ini option followed by the name of the ini file to be used, it will output drivers.xml in the current directory.
When you start with the -ini option followed by the name of the ini file to be used, the ini file that exists in the specified location will be used.

Operation (keyboard)

Cursor up/down Title selection
Cursor left/right Folder/title scroll
BS,ESC Go back one layer from folder/title selection.
            When incremental search is in progress
            BS : Delete one character
            ESC : End of search mode
Return/Space key Title decision, driver loading
Alt+Enter Full screen mode
P Stop playing
            (In many cases, "stop playing" is not implemented.
            In many cases, it is not implemented.)
0 Issue call number 0
Ctrl-F/S Fast/slow playback
Ctrl-C Hexadecimal dump of sound register contents to clipboard
Ctrl-R Reload title definition file when relocating dataCtrl-W Wave output ON/OFF
Ctrl-I Incremental search mode switch
/ Speaner ON/OFF
Ctrl+cursor left/right keyboard scroll
Ctrl+Cursor Up/Down register display scroll (+/-$10 each)
Ctrl+Page Up/Down register display scroll (+/-$100 each)
Ctrl+Home register start display
Ctrl+End End of register display
Ctrl+1/2 Switch between window equal-mode and double-mode
F1/F2/F3/F4/F5/F6/F7/F8 Register display sound source switching
            When scrolling, switches while maintaining the display offset.
TAB selector/channel mask mode switching
12345678 Channel Mask (ch0-7)
QWERTYUI Channel Mask (ch8-16)
            Hold down SHIFT to turn on that channel only.
9/O All channels ON/OFF
- Invert channel mask
L LPF ON/OFF
Z (driver selected) Display of chip clock information, etc.

Operation (mouse)

[Selector]
Left click Move cursor
Right-click Go back one level up (equivalent to [BS]/[ESC])
Back Go back one level up (=equivalent to [BS]/[ESC])
Double left click Select folder/play title (=equivalent to [ENTER])
Wheel Scroll folder/title

[Register Dump]
Left click Dump forward direction switching
Right-click to switch to reverse dump direction
Forward Dump forward direction switching
Back Dump reverse direction switching
Wheel Scroll dump range

[Keyboard]
Left click Mask ON/OFF
Right-click to release all masks (equivalent to [9])

About Incremental Search

Use CTRL+[I] to switch between search and normal mode.
The search targets are folder names, driver names, and title names, not individual song names of each title.
The search does not apply to individual song titles.
The search is performed by partial matching using up to 24 single-byte alphanumeric characters (with large and small comparisons).
The cursor moves up and down to the corresponding list. Press [BS] to delete one character at a time.
The [BS] key deletes one character at a time, but the search mode is maintained even if the character is lost.
To cancel the search mode, press CTRL+[I], [ESC], or [RETURN] again.
or scrolling the selector by any key other than up/down cursor.
Left and right mouse clicks in the selector area are ignored during search.
When the title is reloaded, the search mode is canceled.

Setting

Currently, it is almost impossible to configure the data directory, playback frequency, and each sound source by editing shoot.ini.
By editing shoot.ini, you can change the data directory, playback frequency, mixing level of each sound source, LPF characteristics, etc.
You can change the data directory, playback frequency, mixing level of each sound source, LPF characteristics, etc. by editing hoot.ini. Please
refer to the hoot.ini file in the distribution archive.

Code used

*****************************************************************************************
* SOUND ROM NOTES:                                                                      *
*****************************************************************************************

audiocpu: C001 sound one? c800 sound 2?

c500 - queue for YM1. C515 start ptr (big endian) C517 end ptr (big endian) c51b - Original control value (from A)
C530 - queue for YM2. C545 start ptr (big endian) C547 end ptr (big endian) c54b - Original control value (from A)

[Black Tiger] Black Tiger ()
capcom
Arcade

*****************************************************************************************
* MAME NOTES:                                                                           *
*****************************************************************************************

    map(0x0000, 0x7fff).rom();
    map(0xc000, 0xc7ff).ram();
    map(0xc800, 0xc800).r("soundlatch", FUNC(generic_latch_8_device::read));
    map(0xe000, 0xe001).rw("ym1", FUNC(ym2203_device::read), FUNC(ym2203_device::write));
    map(0xe002, 0xe003).rw("ym2", FUNC(ym2203_device::read), FUNC(ym2203_device::write));
}

    map(0x0000, 0x7fff).rom().region("audiocpu", 0);
    map(0xc000, 0xc7ff).ram();
    map(0xc900, 0xc900).noprw(); // what lives here?
    map(0xdff8, 0xdff8).r("soundlatch", FUNC(generic_latch_8_device::read));
    map(0xdff0, 0xdfff).nopw(); // what lives here?
    map(0xe000, 0xe001).w("ym1", FUNC(ym2203_device::write));
    map(0xe002, 0xe003).w("ym2", FUNC(ym2203_device::write));
    map(0xe008, 0xe009).r("ym1", FUNC(ym2203_device::read));
    map(0xe00a, 0xe00b).r("ym2", FUNC(ym2203_device::read));

// set this to control the output sample rate for SSG-based chips
#define SSG_FIDELITY (ymfm::OPN_FIDELITY_MED)

DECLARE_DEVICE_TYPE(YM2203, ym2203_device);

class ym2203_device : public ymfm_ssg_device_base<ymfm::ym2203>
{
    using parent = ymfm_ssg_device_base<ymfm::ym2203>;

public:
    // constructor
    ym2203_device(const machine_config &mconfig, const char *tag, device_t *owner, uint32_t clock);

    // configuration helpers, handled by the interface
    auto port_a_read_callback() { return io_read_handler(0); }
    auto port_b_read_callback() { return io_read_handler(1); }
    auto port_a_write_callback() { return io_write_handler(0); }
    auto port_b_write_callback() { return io_write_handler(1); }

    // data register read
    u8 data_r() { return update_streams().read_data(); }

protected:
    // device-level overrides
    virtual void device_start() override;
};

//*********************************************************
//  MAME INTERFACES
//*********************************************************

// ======================> ym_generic_device

// generic base class for a standalone FM device; this class contains the shared
// configuration helpers, timers, and ymfm interface implementation; it also
// specifies pure virtual functions for read/write access, which means it
// can be used as a generic proxy for systems that have multiple FM types that are
// swappable
class ym_generic_device : public device_t, public device_sound_interface, public ymfm::ymfm_interface
{
public:
    // constructor
    ym_generic_device(const machine_config &mconfig, const char *tag, device_t *owner, uint32_t clock, device_type type) :
        device_t(mconfig, type, tag, owner, clock),
        device_sound_interface(mconfig, *this),
        m_timer{ nullptr, nullptr },
        m_update_irq(*this),
        m_io_read{ *this, *this },
        m_io_write{ *this, *this }
    {
    }

    // configuration helpers
    auto irq_handler() { return m_update_irq.bind(); }
    auto io_read_handler(int index = 0) { return m_io_read[index & 1].bind(); }
    auto io_write_handler(int index = 0) { return m_io_write[index & 1].bind(); }

    // read access interface, implemented by the derived chip-specific class
    virtual u8 read(offs_t offset) = 0;
    virtual u8 status_r() = 0;

    // write access interface, implemented by the derived chip-specific class
    virtual void write(offs_t offset, u8 data) = 0;
    virtual void address_w(u8 data) = 0;
    virtual void data_w(u8 data) = 0;

protected:
    // the chip implementation calls this when a write happens to the mode
    // register, which could affect timers and interrupts; our responsibility
    // is to ensure the system is up to date before calling the engine's
    // engine_mode_write() method
    virtual void ymfm_sync_mode_write(uint8_t data) override
    {
        machine().scheduler().synchronize(timer_expired_delegate(FUNC(ym_generic_device::fm_mode_write), this), data);
    }

    // the chip implementation calls this when the chip's status has changed,
    // which may affect the interrupt state; our responsibility is to ensure
    // the system is up to date before calling the engine's
    // engine_check_interrupts() method
    virtual void ymfm_sync_check_interrupts() override
    {
        // if we're currently executing a CPU, schedule the interrupt check;
        // otherwise, do it directly
        auto &scheduler = machine().scheduler();
        if (scheduler.currently_executing())
            scheduler.synchronize(timer_expired_delegate(FUNC(ym_generic_device::fm_check_interrupts), this));
        else
            m_engine->engine_check_interrupts();
    }

    // the chip implementation calls this when one of the two internal timers
    // has changed state; our responsibility is to arrange to call the engine's
    // engine_timer_expired() method after the provided number of clocks; if
    // duration_in_clocks is negative, we should cancel any outstanding timers
    virtual void ymfm_set_timer(uint32_t tnum, int32_t duration_in_clocks) override
    {
        if (duration_in_clocks >= 0)
            m_timer[tnum]->adjust(attotime::from_ticks(duration_in_clocks, device_t::clock()), tnum);
        else
            m_timer[tnum]->enable(false);
    }

    // the chip implementation calls this when the state of the IRQ signal has
    // changed due to a status change; our responsibility is to respons as
    // needed to the change in IRQ state, signaling any consumers
    virtual void ymfm_update_irq(bool asserted) override
    {
        if (!m_update_irq.isnull())
            m_update_irq(asserted ? ASSERT_LINE : CLEAR_LINE);
    }

    // the chip implementation calls this to indicate that the chip should be
    // considered in a busy state until the given number of clocks has passed;
    // our responsibility is to compute and remember the ending time based on
    // the chip's clock for later checking
    virtual void ymfm_set_busy_end(uint32_t clocks) override
    {
        m_busy_end = machine().time() + attotime::from_ticks(clocks, device_t::clock());
    }

    // the chip implementation calls this to see if the chip is still currently
    // is a busy state, as specified by a previous call to ymfm_set_busy_end();
    // our responsibility is to compare the current time against the previously
    // noted busy end time and return true if we haven't yet passed it
    virtual bool ymfm_is_busy() override
    {
        return (machine().time() < m_busy_end);
    }

    // the chip implementation calls this whenever data is read from outside
    // of the chip; our responsibility is to provide the data requested
    virtual uint8_t ymfm_external_read(ymfm::access_class type, uint32_t address) override
    {
        return (type != ymfm::ACCESS_IO || m_io_read[address & 1].isnull()) ? 0 : m_io_read[address & 1]();
    }

    // the chip implementation calls this whenever data is written outside
    // of the chip; our responsibility is to pass the written data on to any consumers
    virtual void ymfm_external_write(ymfm::access_class type, uint32_t address, uint8_t data) override
    {
        if (type == ymfm::ACCESS_IO && !m_io_write[address & 1].isnull())
            m_io_write[address & 1](data);
    }

    // handle device start
    virtual void device_start() override
    {
        // allocate our timers
        for (int tnum = 0; tnum < 2; tnum++)
            m_timer[tnum] = machine().scheduler().timer_alloc(timer_expired_delegate(FUNC(ym_generic_device::fm_timer_handler), this));

        // resolve the handlers
        m_update_irq.resolve();
        m_io_read[0].resolve();
        m_io_read[1].resolve();
        m_io_write[0].resolve();
        m_io_write[1].resolve();

        // remember the busy end time
        save_item(NAME(m_busy_end));
    }

    // timer callbacks
    void fm_mode_write(void *ptr, int param) { m_engine->engine_mode_write(param); }
    void fm_check_interrupts(void *ptr, int param) { m_engine->engine_check_interrupts(); }
    void fm_timer_handler(void *ptr, int param) { m_engine->engine_timer_expired(param); }

    // internal state
    attotime m_busy_end;             // busy end time
    emu_timer *m_timer[2];           // two timers
    devcb_write_line m_update_irq;   // IRQ update callback
    devcb_read8 m_io_read[2];        // up to 2 input port handlers
    devcb_write8 m_io_write[2];      // up to 2 output port handlers
};

// ======================> ymfm_device_base

// this template provides most of the basics used by device objects in MAME
// that wrap ymfm chips; it provides basic read/write functions
template<typename ChipClass>
class ymfm_device_base : public ym_generic_device
{
protected:
    static constexpr int OUTPUTS = ChipClass::OUTPUTS;

public:
    // constructor
    ymfm_device_base(const machine_config &mconfig, const char *tag, device_t *owner, uint32_t clock, device_type type) :
        ym_generic_device(mconfig, tag, owner, clock, type),
        m_stream(nullptr),
        m_chip(*this)
    {
    }

    // read access: update the streams before performing the read
    virtual u8 read(offs_t offset) override { return update_streams().read(offset); }
    virtual u8 status_r() override { return update_streams().read_status(); }

    // write access: update the strams before performing the write
    virtual void write(offs_t offset, u8 data) override { update_streams().write(offset, data); }
    virtual void address_w(u8 data) override { update_streams().write_address(data); }
    virtual void data_w(u8 data) override { update_streams().write_data(data); }

protected:
    // handle device start
    virtual void device_start() override
    {
        // let our parent do its startup
        ym_generic_device::device_start();

        // allocate our stream
        m_stream = device_sound_interface::stream_alloc(0, OUTPUTS, m_chip.sample_rate(device_t::clock()));

        // compute the size of the save buffer by doing an initial save
        ymfm::ymfm_saved_state state(m_save_blob, true);
        m_chip.save_restore(state);

        // now register the blob for save, on the assumption the size won't change
        save_item(NAME(m_save_blob));
    }

    // device reset
    virtual void device_reset() override
    {
        m_chip.reset();
    }

    // handle clock changed
    virtual void device_clock_changed() override
    {
        if (m_stream != nullptr)
            m_stream->set_sample_rate(m_chip.sample_rate(device_t::clock()));
    }

    // handle pre-saving by filling the blob
    virtual void device_pre_save() override
    {
        // remember the original blob size
        auto orig_size = m_save_blob.size();

        // save the state
        ymfm::ymfm_saved_state state(m_save_blob, true);
        m_chip.save_restore(state);

        // ensure that the size didn't change since we first allocated
        if (m_save_blob.size() != orig_size)
            throw emu_fatalerror("State size changed for ymfm chip");
    }

    // handle post-loading by restoring from the blob
    virtual void device_post_load() override
    {
        // populate the state from the blob
        ymfm::ymfm_saved_state state(m_save_blob, false);
        m_chip.save_restore(state);
    }

    // sound overrides
    virtual void sound_stream_update(sound_stream &stream, std::vector<read_stream_view> const &inputs, std::vector<write_stream_view> &outputs) override
    {
        update_internal(outputs);
    }

    // update streams
    virtual ChipClass &update_streams()
    {
        m_stream->update();
        return m_chip;
    }

    // internal update helper
    void update_internal(std::vector<write_stream_view> &outputs, int output_shift = 0)
    {
        // local buffer to hold samples
        constexpr int MAX_SAMPLES = 256;
        typename ChipClass::output_data output[MAX_SAMPLES];

        // parameters
        int const outcount = std::min(outputs.size(), std::size(output[0].data));
        int const numsamples = outputs[0].samples();

        // generate the FM/ADPCM stream
        for (int sampindex = 0; sampindex < numsamples; sampindex += MAX_SAMPLES)
        {
            int cursamples = std::min(numsamples - sampindex, MAX_SAMPLES);
            m_chip.generate(output, cursamples);
            for (int outnum = 0; outnum < outcount; outnum++)
            {
                int eff_outnum = (outnum + output_shift) % OUTPUTS;
                for (int index = 0; index < cursamples; index++)
                    outputs[eff_outnum].put_int(sampindex + index, output[index].data[outnum], 32768);
            }
        }
    }

    // internal state
    sound_stream *m_stream;           // sound stream
    ChipClass m_chip;                 // core chip implementation
    std::vector<uint8_t> m_save_blob; // state saving buffer
};

// ======================> ymfm_ssg_device_base

// this template adds SSG support to the base template, using ymfm's internal
// SSG implementation
template<typename ChipClass>
class ymfm_ssg_device_base : public ymfm_device_base<ChipClass>
{
    using parent = ymfm_device_base<ChipClass>;

public:
    // constructor
    ymfm_ssg_device_base(const machine_config &mconfig, const char *tag, device_t *owner, uint32_t clock, device_type type) :
        ymfm_device_base<ChipClass>(mconfig, tag, owner, clock, type)
    {
    }

protected:
    // sound overrides
    virtual void sound_stream_update(sound_stream &stream, std::vector<read_stream_view> const &inputs, std::vector<write_stream_view> &outputs) override
    {
        // ymfm outputs FM first, then SSG, while MAME traditionally
        // wants SSG streams first; to do this, we rotate the outputs
        // by the number of SSG output channels
        parent::update_internal(outputs, ChipClass::SSG_OUTPUTS);

        // for the single-output case, also apply boost the gain to better match
        // previous version, which summed instead of averaged the outputs
        if (ChipClass::SSG_OUTPUTS == 1)
            outputs[0].apply_gain(3.0);
    }
};

#endif // MAME_SOUND_YMFM_H

    map(0x0000, 0x7fff).rom();
    map(0xc000, 0xc7ff).ram();
    map(0xc800, 0xc800).r("soundlatch", FUNC(generic_latch_8_device::read));
    map(0xe000, 0xe001).rw("ym1", FUNC(ym2203_device::read), FUNC(ym2203_device::write));
    map(0xe002, 0xe003).rw("ym2", FUNC(ym2203_device::read), FUNC(ym2203_device::write));

    ym2203_device &ym1(YM2203(config, "ym1", XTAL(3'579'545))); /* verified on pcb */
    ym1.irq_handler().set_inputline(m_audiocpu, 0);
    ym1.add_route(ALL_OUTPUTS, "mono", 0.15);

    ym2203_device &ym2(YM2203(config, "ym2", XTAL(3'579'545))); /* verified on pcb */
    ym2.add_route(ALL_OUTPUTS, "mono", 0.15);

* ymfm_opn.h:
    * YM2203 (OPN) [1984: NEC PC-88, PC-98, NEC PC-6001mkII SR, PC-6601 SR]

ymfm_opn

* OPN (YM2203)
    * OPNA/OPNB/OPN2 (YM2608, YM2610, YM2610B, YM2612, YM3438, YMF276, YMF288)

//
// OPN register map:
//
//      System-wide registers:
//           21 xxxxxxxx Test register
//           22 ----x--- LFO enable [OPNA+ only]
//              -----xxx LFO rate [OPNA+ only]
//           24 xxxxxxxx Timer A value (upper 8 bits)
//           25 ------xx Timer A value (lower 2 bits)
//           26 xxxxxxxx Timer B value
//           27 xx------ CSM/Multi-frequency mode for channel #2
//              --x----- Reset timer B
//              ---x---- Reset timer A
//              ----x--- Enable timer B
//              -----x-- Enable timer A
//              ------x- Load timer B
//              -------x Load timer A
//           28 x------- Key on/off operator 4
//              -x------ Key on/off operator 3
//              --x----- Key on/off operator 2
//              ---x---- Key on/off operator 1
//              ------xx Channel select
//
//     Per-channel registers (channel in address bits 0-1)
//     Note that all these apply to address+100 as well on OPNA+
//        A0-A3 xxxxxxxx Frequency number lower 8 bits
//        A4-A7 --xxx--- Block (0-7)
//              -----xxx Frequency number upper 3 bits
//        B0-B3 --xxx--- Feedback level for operator 1 (0-7)
//              -----xxx Operator connection algorithm (0-7)
//        B4-B7 x------- Pan left [OPNA]
//              -x------ Pan right [OPNA]
//              --xx---- LFO AM shift (0-3) [OPNA+ only]
//              -----xxx LFO PM depth (0-7) [OPNA+ only]
//
//     Per-operator registers (channel in address bits 0-1, operator in bits 2-3)
//     Note that all these apply to address+100 as well on OPNA+
//        30-3F -xxx---- Detune value (0-7)
//              ----xxxx Multiple value (0-15)
//        40-4F -xxxxxxx Total level (0-127)
//        50-5F xx------ Key scale rate (0-3)
//              ---xxxxx Attack rate (0-31)
//        60-6F x------- LFO AM enable [OPNA]
//              ---xxxxx Decay rate (0-31)
//        70-7F ---xxxxx Sustain rate (0-31)
//        80-8F xxxx---- Sustain level (0-15)
//              ----xxxx Release rate (0-15)
//        90-9F ----x--- SSG-EG enable
//              -----xxx SSG-EG envelope (0-7)
//
//     Special multi-frequency registers (channel implicitly #2; operator in address bits 0-1)
//        A8-AB xxxxxxxx Frequency number lower 8 bits
//        AC-AF --xxx--- Block (0-7)
//              -----xxx Frequency number upper 3 bits
//
//     Internal (fake) registers:
//        B8-BB --xxxxxx Latched frequency number upper bits (from A4-A7)
//        BC-BF --xxxxxx Latched frequency number upper bits (from AC-AF)
//

    static constexpr uint32_t OUTPUTS = IsOpnA ? 2 : 1;
    static constexpr uint32_t CHANNELS = IsOpnA ? 6 : 3;
    static constexpr uint32_t ALL_CHANNELS = (1 << CHANNELS) - 1;
    static constexpr uint32_t OPERATORS = CHANNELS * 4;
    static constexpr uint32_t WAVEFORMS = 1;
    static constexpr uint32_t REGISTERS = IsOpnA ? 0x200 : 0x100;
    static constexpr uint32_t REG_MODE = 0x27;
    static constexpr uint32_t DEFAULT_PRESCALE = 6;
    static constexpr uint32_t EG_CLOCK_DIVIDER = 3;
    static constexpr bool EG_HAS_SSG = true;
    static constexpr bool MODULATOR_DELAY = false;
    static constexpr uint32_t CSM_TRIGGER_MASK = 1 << 2;
    static constexpr uint8_t STATUS_TIMERA = 0x01;
    static constexpr uint8_t STATUS_TIMERB = 0x02;
    static constexpr uint8_t STATUS_BUSY = 0x80;
    static constexpr uint8_t STATUS_IRQ = 0;

// A note about prescaling and sample rates.
//
// YM2203, YM2608, and YM2610 contain an onboard SSG (basically, a YM2149).
// In order to properly generate sound at fully fidelity, the output sample
// rate of the YM2149 must be input_clock / 8. This is much higher than the
// FM needs, but in the interest of keeping things simple, the OPN generate
// functions will output at the higher rate and just replicate the last FM
// sample as many times as needed.
//
// To make things even more complicated, the YM2203 and YM2608 allow for
// software-controlled prescaling, which affects the FM and SSG clocks in
// different ways. There are three settings: divide by 6/4 (FM/SSG); divide
// by 3/2; and divide by 2/1.
//
// Thus, the minimum output sample rate needed by each part of the chip
// varies with the prescale as follows:
//
//             ---- YM2203 -----    ---- YM2608 -----    ---- YM2610 -----
// Prescale    FM rate  SSG rate    FM rate  SSG rate    FM rate  SSG rate
//     6         /72      /16         /144     /32          /144    /32
//     3         /36      /8          /72      /16
//     2         /24      /4          /48      /8
//
// If we standardized on the fastest SSG rate, we'd end up with the following
// (ratios are output_samples:source_samples):
//
//             ---- YM2203 -----    ---- YM2608 -----    ---- YM2610 -----
//              rate = clock/4       rate = clock/8       rate = clock/16
// Prescale    FM rate  SSG rate    FM rate  SSG rate    FM rate  SSG rate
//     6         18:1     4:1         18:1     4:1          9:1    2:1
//     3          9:1     2:1          9:1     2:1
//     2          6:1     1:1          6:1     1:1
//
// However, that's a pretty big performance hit for minimal gain. Going to
// the other extreme, we could standardize on the fastest FM rate, but then
// at least one prescale case (3) requires the FM to be smeared across two
// output samples:
//
//             ---- YM2203 -----    ---- YM2608 -----    ---- YM2610 -----
//              rate = clock/24      rate = clock/48      rate = clock/144
// Prescale    FM rate  SSG rate    FM rate  SSG rate    FM rate  SSG rate
//     6          3:1     2:3          3:1     2:3          1:1    2:9
//     3        1.5:1     1:3        1.5:1     1:3
//     2          1:1     1:6          1:1     1:6
//
// Stepping back one factor of 2 addresses that issue:
//
//             ---- YM2203 -----    ---- YM2608 -----    ---- YM2610 -----
//              rate = clock/12      rate = clock/24      rate = clock/144
// Prescale    FM rate  SSG rate    FM rate  SSG rate    FM rate  SSG rate
//     6          6:1     4:3          6:1     4:3          1:1    2:9
//     3          3:1     2:3          3:1     2:3
//     2          2:1     1:3          2:1     1:3
//
// This gives us three levels of output fidelity:
//    OPN_FIDELITY_MAX -- highest sample rate, using fastest SSG rate
//    OPN_FIDELITY_MIN -- lowest sample rate, using fastest FM rate
//    OPN_FIDELITY_MED -- medium sample rate such that FM is never smeared
//
// At the maximum clocks for YM2203/YM2608 (4Mhz/8MHz), these rates will
// end up as:
//    OPN_FIDELITY_MAX = 1000kHz
//    OPN_FIDELITY_MIN =  166kHz
//    OPN_FIEDLITY_MED =  333kHz

// ======================> ym2203

class ym2203
{
public:
    using fm_engine = fm_engine_base<opn_registers>;
    static constexpr uint32_t FM_OUTPUTS = fm_engine::OUTPUTS;
    static constexpr uint32_t SSG_OUTPUTS = ssg_engine::OUTPUTS;
    static constexpr uint32_t OUTPUTS = FM_OUTPUTS + SSG_OUTPUTS;
    using output_data = ymfm_output<OUTPUTS>;

    // constructor
    ym2203(ymfm_interface &intf);

    // configuration
    void ssg_override(ssg_override &intf) { m_ssg.override(intf); }
    void set_fidelity(opn_fidelity fidelity) { m_fidelity = fidelity; update_prescale(m_fm.clock_prescale()); }

    // reset
    void reset();

    // save/restore
    void save_restore(ymfm_saved_state &state);

    // pass-through helpers
    uint32_t sample_rate(uint32_t input_clock) const
    {
        switch (m_fidelity)
        {
            case OPN_FIDELITY_MIN:  return input_clock / 24;
            case OPN_FIDELITY_MED:  return input_clock / 12;
            default:
            case OPN_FIDELITY_MAX:  return input_clock / 4;
        }
    }
    uint32_t ssg_effective_clock(uint32_t input_clock) const { uint32_t scale = m_fm.clock_prescale() * 2 / 3; return input_clock * 2 / scale; }
    void invalidate_caches() { m_fm.invalidate_caches(); }

    // read access
    uint8_t read_status();
    uint8_t read_data();
    uint8_t read(uint32_t offset);

    // write access
    void write_address(uint8_t data);
    void write_data(uint8_t data);
    void write(uint32_t offset, uint8_t data);

    // generate one sample of sound
    void generate(output_data *output, uint32_t numsamples = 1);

protected:
    // internal helpers
    void update_prescale(uint8_t prescale);
    void clock_fm();

    // internal state
    opn_fidelity m_fidelity;            // configured fidelity
    uint8_t m_address;                  // address register
    uint8_t m_fm_samples_per_output;    // how many samples to repeat
    fm_engine::output_data m_last_fm;   // last FM output
    fm_engine m_fm;                     // core FM engine
    ssg_engine m_ssg;                   // SSG engine
    ssg_resampler<output_data, 1, false> m_ssg_resampler; // SSG resampler helper
};

//*********************************************************
//  YM2203
//*********************************************************

//-------------------------------------------------
//  ym2203 - constructor
//-------------------------------------------------

ym2203::ym2203(ymfm_interface &intf) :
    m_fidelity(OPN_FIDELITY_MAX),
    m_address(0),
    m_fm(intf),
    m_ssg(intf),
    m_ssg_resampler(m_ssg)
{
    m_last_fm.clear();
    update_prescale(m_fm.clock_prescale());
}

//-------------------------------------------------
//  reset - reset the system
//-------------------------------------------------

void ym2203::reset()
{
    // reset the engines
    m_fm.reset();
    m_ssg.reset();
}

//-------------------------------------------------
//  save_restore - save or restore the data
//-------------------------------------------------

void ym2203::save_restore(ymfm_saved_state &state)
{
    state.save_restore(m_address);
    state.save_restore(m_last_fm.data);

    m_fm.save_restore(state);
    m_ssg.save_restore(state);
    m_ssg_resampler.save_restore(state);

    update_prescale(m_fm.clock_prescale());
}

//-------------------------------------------------
//  read_status - read the status register
//-------------------------------------------------

uint8_t ym2203::read_status()
{
    uint8_t result = m_fm.status();
    if (m_fm.intf().ymfm_is_busy())
        result |= fm_engine::STATUS_BUSY;
    return result;
}

//-------------------------------------------------
//  read_data - read the data register
//-------------------------------------------------

uint8_t ym2203::read_data()
{
    uint8_t result = 0;
    if (m_address < 0x10)
    {
        // 00-0F: Read from SSG
        result = m_ssg.read(m_address & 0x0f);
    }
    return result;
}

//-------------------------------------------------
//  read - handle a read from the device
//-------------------------------------------------

uint8_t ym2203::read(uint32_t offset)
{
    uint8_t result = 0xff;
    switch (offset & 1)
    {
        case 0: // status port
            result = read_status();
            break;

        case 1: // data port (only SSG)
            result = read_data();
            break;
    }
    return result;
}

//-------------------------------------------------
//  write_address - handle a write to the address
//  register
//-------------------------------------------------

void ym2203::write_address(uint8_t data)
{
    // just set the address
    m_address = data;

    // special case: update the prescale
    if (m_address >= 0x2d && m_address <= 0x2f)
    {
        // 2D-2F: prescaler select
        if (m_address == 0x2d)
            update_prescale(6);
        else if (m_address == 0x2e && m_fm.clock_prescale() == 6)
            update_prescale(3);
        else if (m_address == 0x2f)
            update_prescale(2);
    }
}

//-------------------------------------------------
//  write - handle a write to the register
//  interface
//-------------------------------------------------

void ym2203::write_data(uint8_t data)
{
    if (m_address < 0x10)
    {
        // 00-0F: write to SSG
        m_ssg.write(m_address & 0x0f, data);
    }
    else
    {
        // 10-FF: write to FM
        m_fm.write(m_address, data);
    }

    // mark busy for a bit
    m_fm.intf().ymfm_set_busy_end(32 * m_fm.clock_prescale());
}

//-------------------------------------------------
//  write - handle a write to the register
//  interface
//-------------------------------------------------

void ym2203::write(uint32_t offset, uint8_t data)
{
    switch (offset & 1)
    {
        case 0: // address port
            write_address(data);
            break;

        case 1: // data port
            write_data(data);
            break;
    }
}

//-------------------------------------------------
//  generate - generate one sample of sound
//-------------------------------------------------

void ym2203::generate(output_data *output, uint32_t numsamples)
{
    // FM output is just repeated the prescale number of times; note that
    // 0 is a special 1.5 case
    if (m_fm_samples_per_output != 0)
    {
        for (uint32_t samp = 0; samp < numsamples; samp++, output++)
        {
            if ((m_ssg_resampler.sampindex() + samp) % m_fm_samples_per_output == 0)
                clock_fm();
            output->data[0] = m_last_fm.data[0];
        }
    }
    else
    {
        for (uint32_t samp = 0; samp < numsamples; samp++, output++)
        {
            uint32_t step = (m_ssg_resampler.sampindex() + samp) % 3;
            if (step == 0)
                clock_fm();
            output->data[0] = m_last_fm.data[0];
            if (step == 1)
            {
                clock_fm();
                output->data[0] = (output->data[0] + m_last_fm.data[0]) / 2;
            }
        }
    }

    // resample the SSG as configured
    m_ssg_resampler.resample(output - numsamples, numsamples);
}

//-------------------------------------------------
//  update_prescale - update the prescale value,
//  recomputing derived values
//-------------------------------------------------

void ym2203::update_prescale(uint8_t prescale)
{
    // tell the FM engine
    m_fm.set_clock_prescale(prescale);
    m_ssg.prescale_changed();

    // Fidelity:   ---- minimum ----    ---- medium -----    ---- maximum-----
    //              rate = clock/24      rate = clock/12      rate = clock/4
    // Prescale    FM rate  SSG rate    FM rate  SSG rate    FM rate  SSG rate
    //     6          3:1     2:3          6:1     4:3         18:1     4:1
    //     3        1.5:1     1:3          3:1     2:3          9:1     2:1
    //     2          1:1     1:6          2:1     1:3          6:1     1:1

    // compute the number of FM samples per output sample, and select the
    // resampler function
    if (m_fidelity == OPN_FIDELITY_MIN)
    {
        switch (prescale)
        {
            default:
            case 6: m_fm_samples_per_output = 3;    m_ssg_resampler.configure(2, 3);    break;
            case 3: m_fm_samples_per_output = 0;    m_ssg_resampler.configure(1, 3);    break;
            case 2: m_fm_samples_per_output = 1;    m_ssg_resampler.configure(1, 6);    break;
        }
    }
    else if (m_fidelity == OPN_FIDELITY_MED)
    {
        switch (prescale)
        {
            default:
            case 6: m_fm_samples_per_output = 6;    m_ssg_resampler.configure(4, 3);    break;
            case 3: m_fm_samples_per_output = 3;    m_ssg_resampler.configure(2, 3);    break;
            case 2: m_fm_samples_per_output = 2;    m_ssg_resampler.configure(1, 3);    break;
        }
    }
    else
    {
        switch (prescale)
        {
            default:
            case 6: m_fm_samples_per_output = 18;   m_ssg_resampler.configure(4, 1);    break;
            case 3: m_fm_samples_per_output = 9;    m_ssg_resampler.configure(2, 1);    break;
            case 2: m_fm_samples_per_output = 6;    m_ssg_resampler.configure(1, 1);    break;
        }
    }

    // if overriding the SSG, override the configuration with the nop
    // resampler to at least keep the sample index moving forward
    if (m_ssg.overridden())
        m_ssg_resampler.configure(0, 0);
}

//-------------------------------------------------
//  clock_fm - clock FM state
//-------------------------------------------------

void ym2203::clock_fm()
{
    // clock the system
    m_fm.clock(fm_engine::ALL_CHANNELS);

    // update the FM content; OPN is full 14-bit with no intermediate clipping
    m_fm.output(m_last_fm.clear(), 0, 32767, fm_engine::ALL_CHANNELS);

    // convert to 10.3 floating point value for the DAC and back
    m_last_fm.roundtrip_fp();
}

template<typename OutputType, int FirstOutput, bool MixTo1>
void ssg_resampler<OutputType, FirstOutput, MixTo1>::resample_4_3(OutputType *output, uint32_t numsamples)
{
    for (uint32_t samp = 0; samp < numsamples; samp++, output++)
    {
        int32_t sum0 = 0, sum1 = 0, sum2 = 0;
        int32_t step = bitfield(m_sampindex, 0, 2);
        add_last(sum0, sum1, sum2, step);
        if (step != 3)
            clock_and_add(sum0, sum1, sum2, 3 - step);
        write_to_output(output, sum0, sum1, sum2, 3);
    }
}

//-------------------------------------------------
//  resample_nop - no-op resampler
//-------------------------------------------------

template<typename OutputType, int FirstOutput, bool MixTo1>
void ssg_resampler<OutputType, FirstOutput, MixTo1>::resample_nop(OutputType *output, uint32_t numsamples)
{
    // nothing to do except increment the sample index
    m_sampindex += numsamples;
}

//*********************************************************
//  SSG RESAMPLER
//*********************************************************

//-------------------------------------------------
//  add_last - helper to add the last computed
//  value to the sums, applying the given scale
//-------------------------------------------------

template<typename OutputType, int FirstOutput, bool MixTo1>
void ssg_resampler<OutputType, FirstOutput, MixTo1>::add_last(int32_t &sum0, int32_t &sum1, int32_t &sum2, int32_t scale)
{
    sum0 += m_last.data[0] * scale;
    sum1 += m_last.data[1] * scale;
    sum2 += m_last.data[2] * scale;
}

//-------------------------------------------------
//  clock_and_add - helper to clock a new value
//  and then add it to the sums, applying the
//  given scale
//-------------------------------------------------

template<typename OutputType, int FirstOutput, bool MixTo1>
void ssg_resampler<OutputType, FirstOutput, MixTo1>::clock_and_add(int32_t &sum0, int32_t &sum1, int32_t &sum2, int32_t scale)
{
    m_ssg.clock();
    m_ssg.output(m_last);
    add_last(sum0, sum1, sum2, scale);
}

//-------------------------------------------------
//  write_to_output - helper to write the sums to
//  the appropriate outputs, applying the given
//  divisor to the final result
//-------------------------------------------------

template<typename OutputType, int FirstOutput, bool MixTo1>
void ssg_resampler<OutputType, FirstOutput, MixTo1>::write_to_output(OutputType *output, int32_t sum0, int32_t sum1, int32_t sum2, int32_t divisor)
{
    if (MixTo1)
    {
        // mixing to one, apply a 2/3 factor to prevent overflow
        output->data[FirstOutput] = (sum0 + sum1 + sum2) * 2 / (3 * divisor);
    }
    else
    {
        // write three outputs in a row
        output->data[FirstOutput + 0] = sum0 / divisor;
        output->data[FirstOutput + 1] = sum1 / divisor;
        output->data[FirstOutput + 2] = sum2 / divisor;
    }

    // track the sample index here
    m_sampindex++;
}

//-------------------------------------------------
//  ssg_resampler - constructor
//-------------------------------------------------

template<typename OutputType, int FirstOutput, bool MixTo1>
ssg_resampler<OutputType, FirstOutput, MixTo1>::ssg_resampler(ssg_engine &ssg) :
    m_ssg(ssg),
    m_sampindex(0),
    m_resampler(&ssg_resampler::resample_nop)
{
    m_last.clear();
}

//-------------------------------------------------
//  save_restore - save or restore the data
//-------------------------------------------------

template<typename OutputType, int FirstOutput, bool MixTo1>
void ssg_resampler<OutputType, FirstOutput, MixTo1>::save_restore(ymfm_saved_state &state)
{
    state.save_restore(m_sampindex);
    state.save_restore(m_last.data);
}

//-------------------------------------------------
//  configure - configure a new ratio
//-------------------------------------------------

template<typename OutputType, int FirstOutput, bool MixTo1>
void ssg_resampler<OutputType, FirstOutput, MixTo1>::configure(uint8_t outsamples, uint8_t srcsamples)
{
    switch (outsamples * 10 + srcsamples)
    {
        case 4*10 + 1:  /* 4:1 */   m_resampler = &ssg_resampler::resample_n_1<4>;  break;
        case 2*10 + 1:  /* 2:1 */   m_resampler = &ssg_resampler::resample_n_1<2>;  break;
        case 4*10 + 3:  /* 4:3 */   m_resampler = &ssg_resampler::resample_4_3;     break;
        case 1*10 + 1:  /* 1:1 */   m_resampler = &ssg_resampler::resample_n_1<1>;  break;
        case 2*10 + 3:  /* 2:3 */   m_resampler = &ssg_resampler::resample_2_3;     break;
        case 1*10 + 3:  /* 1:3 */   m_resampler = &ssg_resampler::resample_1_n<3>;  break;
        case 2*10 + 9:  /* 2:9 */   m_resampler = &ssg_resampler::resample_2_9;     break;
        case 1*10 + 6:  /* 1:6 */   m_resampler = &ssg_resampler::resample_1_n<6>;  break;
        case 0*10 + 0:  /* 0:0 */   m_resampler = &ssg_resampler::resample_nop;     break;
        default: assert(false); break;
    }
}

//-------------------------------------------------
//  resample_n_1 - resample SSG output to the
//  target at a rate of 1 SSG sample to every
//  n output sample
//-------------------------------------------------

template<typename OutputType, int FirstOutput, bool MixTo1>
template<int Multiplier>
void ssg_resampler<OutputType, FirstOutput, MixTo1>::resample_n_1(OutputType *output, uint32_t numsamples)
{
    for (uint32_t samp = 0; samp < numsamples; samp++, output++)
    {
        if (m_sampindex % Multiplier == 0)
        {
            m_ssg.clock();
            m_ssg.output(m_last);
        }
        write_to_output(output, m_last.data[0], m_last.data[1], m_last.data[2]);
    }
}

//-------------------------------------------------
//  resample_1_n - resample SSG output to the
//  target at a rate of n SSG samples to every
//  1 output sample
//-------------------------------------------------

template<typename OutputType, int FirstOutput, bool MixTo1>
template<int Divisor>
void ssg_resampler<OutputType, FirstOutput, MixTo1>::resample_1_n(OutputType *output, uint32_t numsamples)
{
    for (uint32_t samp = 0; samp < numsamples; samp++, output++)
    {
        int32_t sum0 = 0, sum1 = 0, sum2 = 0;
        for (int rep = 0; rep < Divisor; rep++)
            clock_and_add(sum0, sum1, sum2);
        write_to_output(output, sum0, sum1, sum2, Divisor);
    }
}

//-------------------------------------------------
//  resample_2_9 - resample SSG output to the
//  target at a rate of 9 SSG samples to every
//  2 output samples
//-------------------------------------------------

template<typename OutputType, int FirstOutput, bool MixTo1>
void ssg_resampler<OutputType, FirstOutput, MixTo1>::resample_2_9(OutputType *output, uint32_t numsamples)
{
    for (uint32_t samp = 0; samp < numsamples; samp++, output++)
    {
        int32_t sum0 = 0, sum1 = 0, sum2 = 0;
        if (bitfield(m_sampindex, 0) != 0)
            add_last(sum0, sum1, sum2, 1);
        clock_and_add(sum0, sum1, sum2, 2);
        clock_and_add(sum0, sum1, sum2, 2);
        clock_and_add(sum0, sum1, sum2, 2);
        clock_and_add(sum0, sum1, sum2, 2);
        if (bitfield(m_sampindex, 0) == 0)
            clock_and_add(sum0, sum1, sum2, 1);
        write_to_output(output, sum0, sum1, sum2, 9);
    }
}

//-------------------------------------------------
//  resample_2_3 - resample SSG output to the
//  target at a rate of 3 SSG samples to every
//  2 output samples
//-------------------------------------------------

template<typename OutputType, int FirstOutput, bool MixTo1>
void ssg_resampler<OutputType, FirstOutput, MixTo1>::resample_2_3(OutputType *output, uint32_t numsamples)
{
    for (uint32_t samp = 0; samp < numsamples; samp++, output++)
    {
        int32_t sum0 = 0, sum1 = 0, sum2 = 0;
        if (bitfield(m_sampindex, 0) == 0)
        {
            clock_and_add(sum0, sum1, sum2, 2);
            clock_and_add(sum0, sum1, sum2, 1);
        }
        else
        {
            add_last(sum0, sum1, sum2, 1);
            clock_and_add(sum0, sum1, sum2, 2);
        }
        write_to_output(output, sum0, sum1, sum2, 3);
    }
}

//-------------------------------------------------
//  resample_4_3 - resample SSG output to the
//  target at a rate of 3 SSG samples to every
//  4 output samples
//-------------------------------------------------

namespace ymfm
{

//*********************************************************
//  OPN/OPNA REGISTERS
//*********************************************************

//-------------------------------------------------
//  opn_registers_base - constructor
//-------------------------------------------------

template<bool IsOpnA>
opn_registers_base<IsOpnA>::opn_registers_base() :
    m_lfo_counter(0),
    m_lfo_am(0)
{
    // create the waveforms
    for (uint32_t index = 0; index < WAVEFORM_LENGTH; index++)
        m_waveform[0][index] = abs_sin_attenuation(index) | (bitfield(index, 9) << 15);
}

//-------------------------------------------------
//  reset - reset to initial state
//-------------------------------------------------

template<bool IsOpnA>
void opn_registers_base<IsOpnA>::reset()
{
    std::fill_n(&m_regdata[0], REGISTERS, 0);
    if (IsOpnA)
    {
        // enable output on both channels by default
        m_regdata[0xb4] = m_regdata[0xb5] = m_regdata[0xb6] = 0xc0;
        m_regdata[0x1b4] = m_regdata[0x1b5] = m_regdata[0x1b6] = 0xc0;
    }
}

//-------------------------------------------------
//  save_restore - save or restore the data
//-------------------------------------------------

template<bool IsOpnA>
void opn_registers_base<IsOpnA>::save_restore(ymfm_saved_state &state)
{
    if (IsOpnA)
    {
        state.save_restore(m_lfo_counter);
        state.save_restore(m_lfo_am);
    }
    state.save_restore(m_regdata);
}

//-------------------------------------------------
//  operator_map - return an array of operator
//  indices for each channel; for OPN this is fixed
//-------------------------------------------------

template<>
void opn_registers_base<false>::operator_map(operator_mapping &dest) const
{
    // Note that the channel index order is 0,2,1,3, so we bitswap the index.
    //
    // This is because the order in the map is:
    //    carrier 1, carrier 2, modulator 1, modulator 2
    //
    // But when wiring up the connections, the more natural order is:
    //    carrier 1, modulator 1, carrier 2, modulator 2
    static const operator_mapping s_fixed_map =
    { {
        operator_list(  0,  6,  3,  9 ),  // Channel 0 operators
        operator_list(  1,  7,  4, 10 ),  // Channel 1 operators
        operator_list(  2,  8,  5, 11 ),  // Channel 2 operators
    } };
    dest = s_fixed_map;
}

template<>
void opn_registers_base<true>::operator_map(operator_mapping &dest) const
{
    // Note that the channel index order is 0,2,1,3, so we bitswap the index.
    //
    // This is because the order in the map is:
    //    carrier 1, carrier 2, modulator 1, modulator 2
    //
    // But when wiring up the connections, the more natural order is:
    //    carrier 1, modulator 1, carrier 2, modulator 2
    static const operator_mapping s_fixed_map =
    { {
        operator_list(  0,  6,  3,  9 ),  // Channel 0 operators
        operator_list(  1,  7,  4, 10 ),  // Channel 1 operators
        operator_list(  2,  8,  5, 11 ),  // Channel 2 operators
        operator_list( 12, 18, 15, 21 ),  // Channel 3 operators
        operator_list( 13, 19, 16, 22 ),  // Channel 4 operators
        operator_list( 14, 20, 17, 23 ),  // Channel 5 operators
    } };
    dest = s_fixed_map;
}

//-------------------------------------------------
//  write - handle writes to the register array
//-------------------------------------------------

template<bool IsOpnA>
bool opn_registers_base<IsOpnA>::write(uint16_t index, uint8_t data, uint32_t &channel, uint32_t &opmask)
{
    assert(index < REGISTERS);

    // writes in the 0xa0-af/0x1a0-af region are handled as latched pairs
    // borrow unused registers 0xb8-bf/0x1b8-bf as temporary holding locations
    if ((index & 0xf0) == 0xa0)
    {
        uint32_t latchindex = 0xb8 | (bitfield(index, 3) << 2) | bitfield(index, 0, 2);
        if (IsOpnA)
            latchindex |= index & 0x100;

        // writes to the upper half just latch (only low 6 bits matter)
        if (bitfield(index, 2))
            m_regdata[latchindex] = data | 0x80;

        // writes to the lower half only commit if the latch is there
        else if (bitfield(m_regdata[latchindex], 7))
        {
            m_regdata[index | 4] = m_regdata[latchindex] & 0x3f;
            m_regdata[latchindex] = 0;
        }
    }

    // everything else is normal
    m_regdata[index] = data;

    // handle writes to the key on index
    if (index == 0x28)
    {
        channel = bitfield(data, 0, 2);
        if (channel == 3)
            return false;
        if (IsOpnA)
            channel += bitfield(data, 2, 1) * 3;
        opmask = bitfield(data, 4, 4);
        return true;
    }
    return false;
}

//-------------------------------------------------
//  clock_noise_and_lfo - clock the noise and LFO,
//  handling clock division, depth, and waveform
//  computations
//-------------------------------------------------

template<bool IsOpnA>
int32_t opn_registers_base<IsOpnA>::clock_noise_and_lfo()
{
    // OPN has no noise generation

    // if LFO not enabled (not present on OPN), quick exit with 0s
    if (!IsOpnA || !lfo_enable())
    {
        m_lfo_counter = 0;
        m_lfo_am = 0;
        return 0;
    }

    // this table is based on converting the frequencies in the applications
    // manual to clock dividers, based on the assumption of a 7-bit LFO value
    static uint8_t const lfo_max_count[8] = { 109, 78, 72, 68, 63, 45, 9, 6 };
    uint32_t subcount = uint8_t(m_lfo_counter++);

    // when we cross the divider count, add enough to zero it and cause an
    // increment at bit 8; the 7-bit value lives from bits 8-14
    if (subcount >= lfo_max_count[lfo_rate()])
    {
        // note: to match the published values this should be 0x100 - subcount;
        // however, tests on the hardware and nuked bear out an off-by-one
        // error exists that causes the max LFO rate to be faster than published
        m_lfo_counter += 0x101 - subcount;
    }

    // AM value is 7 bits, staring at bit 8; grab the low 6 directly
    m_lfo_am = bitfield(m_lfo_counter, 8, 6);

    // first half of the AM period (bit 6 == 0) is inverted
    if (bitfield(m_lfo_counter, 8+6) == 0)
        m_lfo_am ^= 0x3f;

    // PM value is 5 bits, starting at bit 10; grab the low 3 directly
    int32_t pm = bitfield(m_lfo_counter, 10, 3);

    // PM is reflected based on bit 3
    if (bitfield(m_lfo_counter, 10+3))
        pm ^= 7;

    // PM is negated based on bit 4
    return bitfield(m_lfo_counter, 10+4) ? -pm : pm;
}

//-------------------------------------------------
//  lfo_am_offset - return the AM offset from LFO
//  for the given channel
//-------------------------------------------------

template<bool IsOpnA>
uint32_t opn_registers_base<IsOpnA>::lfo_am_offset(uint32_t choffs) const
{
    // shift value for AM sensitivity is [7, 3, 1, 0],
    // mapping to values of [0, 1.4, 5.9, and 11.8dB]
    uint32_t am_shift = (1 << (ch_lfo_am_sens(choffs) ^ 3)) - 1;

    // QUESTION: max sensitivity should give 11.8dB range, but this value
    // is directly added to an x.8 attenuation value, which will only give
    // 126/256 or ~4.9dB range -- what am I missing? The calculation below
    // matches several other emulators, including the Nuked implemenation.

    // raw LFO AM value on OPN is 0-3F, scale that up by a factor of 2
    // (giving 7 bits) before applying the final shift
    return (m_lfo_am << 1) >> am_shift;
}

//-------------------------------------------------
//  cache_operator_data - fill the operator cache
//  with prefetched data
//-------------------------------------------------

template<bool IsOpnA>
void opn_registers_base<IsOpnA>::cache_operator_data(uint32_t choffs, uint32_t opoffs, opdata_cache &cache)
{
    // set up the easy stuff
    cache.waveform = &m_waveform[0][0];

    // get frequency from the channel
    uint32_t block_freq = cache.block_freq = ch_block_freq(choffs);

    // if multi-frequency mode is enabled and this is channel 2,
    // fetch one of the special frequencies
    if (multi_freq() && choffs == 2)
    {
        if (opoffs == 2)
            block_freq = cache.block_freq = multi_block_freq(1);
        else if (opoffs == 10)
            block_freq = cache.block_freq = multi_block_freq(2);
        else if (opoffs == 6)
            block_freq = cache.block_freq = multi_block_freq(0);
    }

    // compute the keycode: block_freq is:
    //
    //     BBBFFFFFFFFFFF
    //     ^^^^???
    //
    // the 5-bit keycode uses the top 4 bits plus a magic formula
    // for the final bit
    uint32_t keycode = bitfield(block_freq, 10, 4) << 1;

    // lowest bit is determined by a mix of next lower FNUM bits
    // according to this equation from the YM2608 manual:
    //
    //   (F11 & (F10 | F9 | F8)) | (!F11 & F10 & F9 & F8)
    //
    // for speed, we just look it up in a 16-bit constant
    keycode |= bitfield(0xfe80, bitfield(block_freq, 7, 4));

    // detune adjustment
    cache.detune = detune_adjustment(op_detune(opoffs), keycode);

    // multiple value, as an x.1 value (0 means 0.5)
    cache.multiple = op_multiple(opoffs) * 2;
    if (cache.multiple == 0)
        cache.multiple = 1;

    // phase step, or PHASE_STEP_DYNAMIC if PM is active; this depends on
    // block_freq, detune, and multiple, so compute it after we've done those
    if (!IsOpnA || lfo_enable() == 0 || ch_lfo_pm_sens(choffs) == 0)
        cache.phase_step = compute_phase_step(choffs, opoffs, cache, 0);
    else
        cache.phase_step = opdata_cache::PHASE_STEP_DYNAMIC;

    // total level, scaled by 8
    cache.total_level = op_total_level(opoffs) << 3;

    // 4-bit sustain level, but 15 means 31 so effectively 5 bits
    cache.eg_sustain = op_sustain_level(opoffs);
    cache.eg_sustain |= (cache.eg_sustain + 1) & 0x10;
    cache.eg_sustain <<= 5;

    // determine KSR adjustment for enevlope rates
    uint32_t ksrval = keycode >> (op_ksr(opoffs) ^ 3);
    cache.eg_rate[EG_ATTACK] = effective_rate(op_attack_rate(opoffs) * 2, ksrval);
    cache.eg_rate[EG_DECAY] = effective_rate(op_decay_rate(opoffs) * 2, ksrval);
    cache.eg_rate[EG_SUSTAIN] = effective_rate(op_sustain_rate(opoffs) * 2, ksrval);
    cache.eg_rate[EG_RELEASE] = effective_rate(op_release_rate(opoffs) * 4 + 2, ksrval);
}

//-------------------------------------------------
//  compute_phase_step - compute the phase step
//-------------------------------------------------

template<bool IsOpnA>
uint32_t opn_registers_base<IsOpnA>::compute_phase_step(uint32_t choffs, uint32_t opoffs, opdata_cache const &cache, int32_t lfo_raw_pm)
{
    // OPN phase calculation has only a single detune parameter
    // and uses FNUMs instead of keycodes

    // extract frequency number (low 11 bits of block_freq)
    uint32_t fnum = bitfield(cache.block_freq, 0, 11) << 1;

    // if there's a non-zero PM sensitivity, compute the adjustment
    uint32_t pm_sensitivity = ch_lfo_pm_sens(choffs);
    if (pm_sensitivity != 0)
    {
        // apply the phase adjustment based on the upper 7 bits
        // of FNUM and the PM depth parameters
        fnum += opn_lfo_pm_phase_adjustment(bitfield(cache.block_freq, 4, 7), pm_sensitivity, lfo_raw_pm);

        // keep fnum to 12 bits
        fnum &= 0xfff;
    }

    // apply block shift to compute phase step
    uint32_t block = bitfield(cache.block_freq, 11, 3);
    uint32_t phase_step = (fnum << block) >> 2;

    // apply detune based on the keycode
    phase_step += cache.detune;

    // clamp to 17 bits in case detune overflows
    // QUESTION: is this specific to the YM2612/3438?
    phase_step &= 0x1ffff;

    // apply frequency multiplier (which is cached as an x.1 value)
    return (phase_step * cache.multiple) >> 1;
}

//-------------------------------------------------
//  log_keyon - log a key-on event
//-------------------------------------------------

template<bool IsOpnA>
std::string opn_registers_base<IsOpnA>::log_keyon(uint32_t choffs, uint32_t opoffs)
{
    uint32_t chnum = (choffs & 3) + 3 * bitfield(choffs, 8);
    uint32_t opnum = (opoffs & 15) - ((opoffs & 15) / 4) + 12 * bitfield(opoffs, 8);

    uint32_t block_freq = ch_block_freq(choffs);
    if (multi_freq() && choffs == 2)
    {
        if (opoffs == 2)
            block_freq = multi_block_freq(1);
        else if (opoffs == 10)
            block_freq = multi_block_freq(2);
        else if (opoffs == 6)
            block_freq = multi_block_freq(0);
    }

    char buffer[256];
    char *end = &buffer[0];

    end += sprintf(end, "%u.%02u freq=%04X dt=%u fb=%u alg=%X mul=%X tl=%02X ksr=%u adsr=%02X/%02X/%02X/%X sl=%X",
        chnum, opnum,
        block_freq,
        op_detune(opoffs),
        ch_feedback(choffs),
        ch_algorithm(choffs),
        op_multiple(opoffs),
        op_total_level(opoffs),
        op_ksr(opoffs),
        op_attack_rate(opoffs),
        op_decay_rate(opoffs),
        op_sustain_rate(opoffs),
        op_release_rate(opoffs),
        op_sustain_level(opoffs));

    if (OUTPUTS > 1)
        end += sprintf(end, " out=%c%c",
            ch_output_0(choffs) ? 'L' : '-',
            ch_output_1(choffs) ? 'R' : '-');
    if (op_ssg_eg_enable(opoffs))
        end += sprintf(end, " ssg=%X", op_ssg_eg_mode(opoffs));
    bool am = (lfo_enable() && op_lfo_am_enable(opoffs) && ch_lfo_am_sens(choffs) != 0);
    if (am)
        end += sprintf(end, " am=%u", ch_lfo_am_sens(choffs));
    bool pm = (lfo_enable() && ch_lfo_pm_sens(choffs) != 0);
    if (pm)
        end += sprintf(end, " pm=%u", ch_lfo_pm_sens(choffs));
    if (am || pm)
        end += sprintf(end, " lfo=%02X", lfo_rate());
    if (multi_freq() && choffs == 2)
        end += sprintf(end, " multi=1");

    return buffer;
}

//*********************************************************
// SSG ENGINE
//*********************************************************

//-------------------------------------------------
//  ssg_engine - constructor
//-------------------------------------------------

ssg_engine::ssg_engine(ymfm_interface &intf) :
    m_intf(intf),
    m_tone_count{ 0,0,0 },
    m_tone_state{ 0,0,0 },
    m_envelope_count(0),
    m_envelope_state(0),
    m_noise_count(0),
    m_noise_state(1),
    m_override(nullptr)
{
}

//-------------------------------------------------
//  reset - reset the engine state
//-------------------------------------------------

void ssg_engine::reset()
{
    // defer to the override if present
    if (m_override != nullptr)
        return m_override->ssg_reset();

    // reset register state
    m_regs.reset();

    // reset engine state
    for (int chan = 0; chan < 3; chan++)
    {
        m_tone_count[chan] = 0;
        m_tone_state[chan] = 0;
    }
    m_envelope_count = 0;
    m_envelope_state = 0;
    m_noise_count = 0;
    m_noise_state = 1;
}

//-------------------------------------------------
//  save_restore - save or restore the data
//-------------------------------------------------

void ssg_engine::save_restore(ymfm_saved_state &state)
{
    // save register state
    m_regs.save_restore(state);

    // save engine state
    state.save_restore(m_tone_count);
    state.save_restore(m_tone_state);
    state.save_restore(m_envelope_count);
    state.save_restore(m_envelope_state);
    state.save_restore(m_noise_count);
    state.save_restore(m_noise_state);
}

//-------------------------------------------------
//  clock - master clocking function
//-------------------------------------------------

void ssg_engine::clock()
{
    // clock tones; tone period units are clock/16 but since we run at clock/8
    // that works out for us to toggle the state (50% duty cycle) at twice the
    // programmed period
    for (int chan = 0; chan < 3; chan++)
    {
        m_tone_count[chan]++;
        if (m_tone_count[chan] >= m_regs.ch_tone_period(chan))
        {
            m_tone_state[chan] ^= 1;
            m_tone_count[chan] = 0;
        }
    }

    // clock noise; noise period units are clock/16 but since we run at clock/8,
    // our counter needs a right shift prior to compare; note that a period of 0
    // should produce an indentical result to a period of 1, so add a special
    // check against that case
    m_noise_count++;
    if ((m_noise_count >> 1) >= m_regs.noise_period() && m_noise_count != 1)
    {
        m_noise_state ^= (bitfield(m_noise_state, 0) ^ bitfield(m_noise_state, 3)) << 17;
        m_noise_state >>= 1;
        m_noise_count = 0;
    }

    // clock envelope; envelope period units are clock/8 (manual says clock/256
    // but that's for all 32 steps)
    m_envelope_count++;
    if (m_envelope_count >= m_regs.envelope_period())
    {
        m_envelope_state++;
        m_envelope_count = 0;
    }
}

//-------------------------------------------------
//  output - output the current state
//-------------------------------------------------

void ssg_engine::output(output_data &output)
{
    // volume to amplitude table, taken from MAME's implementation but biased
    // so that 0 == 0
    static int16_t const s_amplitudes[32] =
    {
             0,   32,   78,  141,  178,  222,  262,  306,
           369,  441,  509,  585,  701,  836,  965, 1112,
          1334, 1595, 1853, 2146, 2576, 3081, 3576, 4135,
          5000, 6006, 7023, 8155, 9963,11976,14132,16382
    };

    // compute the envelope volume
    uint32_t envelope_volume;
    if ((m_regs.envelope_hold() | (m_regs.envelope_continue() ^ 1)) && m_envelope_state >= 32)
    {
        m_envelope_state = 32;
        envelope_volume = ((m_regs.envelope_attack() ^ m_regs.envelope_alternate()) & m_regs.envelope_continue()) ? 31 : 0;
    }
    else
    {
        uint32_t attack = m_regs.envelope_attack();
        if (m_regs.envelope_alternate())
            attack ^= bitfield(m_envelope_state, 5);
        envelope_volume = (m_envelope_state & 31) ^ (attack ? 0 : 31);
    }

    // iterate over channels
    for (int chan = 0; chan < 3; chan++)
    {
        // noise depends on the noise state, which is the LSB of m_noise_state
        uint32_t noise_on = m_regs.ch_noise_enable(chan) & m_noise_state;

        // tone depends on the current tone state
        uint32_t tone_on = m_regs.ch_tone_enable(chan) & m_tone_state[chan];

        // if neither tone nor noise enabled, return 0
        uint32_t volume;
        if ((noise_on | tone_on) == 0)
            volume = 0;

        // if the envelope is enabled, use its amplitude
        else if (m_regs.ch_envelope_enable(chan))
            volume = envelope_volume;

        // otherwise, scale the tone amplitude up to match envelope values
        // according to the datasheet, amplitude 15 maps to envelope 31
        else
        {
            volume = m_regs.ch_amplitude(chan) * 2;
            if (volume != 0)
                volume |= 1;
        }

        // convert to amplitude
        output.data[chan] = s_amplitudes[volume];
    }
}

//-------------------------------------------------
//  read - handle reads from the SSG registers
//-------------------------------------------------

uint8_t ssg_engine::read(uint32_t regnum)
{
    // defer to the override if present
    if (m_override != nullptr)
        return m_override->ssg_read(regnum);

    // read from the I/O ports call the handlers if they are configured for input
    if (regnum == 0x0e && !m_regs.io_a_out())
        return m_intf.ymfm_external_read(ACCESS_IO, 0);
    else if (regnum == 0x0f && !m_regs.io_b_out())
        return m_intf.ymfm_external_read(ACCESS_IO, 1);

    // otherwise just return the register value
    return m_regs.read(regnum);
}

//-------------------------------------------------
//  write - handle writes to the SSG registers
//-------------------------------------------------

void ssg_engine::write(uint32_t regnum, uint8_t data)
{
    // defer to the override if present
    if (m_override != nullptr)
        return m_override->ssg_write(regnum, data);

    // store the raw value to the register array;
    // most writes are passive, consumed only when needed
    m_regs.write(regnum, data);

    // writes to the envelope shape register reset the state
    if (regnum == 0x0d)
        m_envelope_state = 0;

    // writes to the I/O ports call the handlers if they are configured for output
    else if (regnum == 0x0e && m_regs.io_a_out())
        m_intf.ymfm_external_write(ACCESS_IO, 0, data);
    else if (regnum == 0x0f && m_regs.io_b_out())
        m_intf.ymfm_external_write(ACCESS_IO, 1, data);
}

//*********************************************************
//  REGISTER CLASS
//*********************************************************

// ======================> ssg_registers

//
// SSG register map:
//
//      System-wide registers:
//           06 ---xxxxx Noise period
//           07 x------- I/O B in(0) or out(1)
//              -x------ I/O A in(0) or out(1)
//              --x----- Noise enable(0) or disable(1) for channel C
//              ---x---- Noise enable(0) or disable(1) for channel B
//              ----x--- Noise enable(0) or disable(1) for channel A
//              -----x-- Tone enable(0) or disable(1) for channel C
//              ------x- Tone enable(0) or disable(1) for channel B
//              -------x Tone enable(0) or disable(1) for channel A
//           0B xxxxxxxx Envelope period fine
//           0C xxxxxxxx Envelope period coarse
//           0D ----x--- Envelope shape: continue
//              -----x-- Envelope shape: attack/decay
//              ------x- Envelope shape: alternate
//              -------x Envelope shape: hold
//           0E xxxxxxxx 8-bit parallel I/O port A
//           0F xxxxxxxx 8-bit parallel I/O port B
//
//      Per-channel registers:
//     00,02,04 xxxxxxxx Tone period (fine) for channel A,B,C
//     01,03,05 ----xxxx Tone period (coarse) for channel A,B,C
//     08,09,0A ---x---- Mode: fixed(0) or variable(1) for channel A,B,C
//              ----xxxx Amplitude for channel A,B,C
//
//*********************************************************
//  OVERRIDE INTERFACE
//*********************************************************

// ======================> ssg_override

// this class describes a simple interface to allow the internal SSG to be
// overridden with another implementation
class ssg_override
{
public:
    // reset our status
    virtual void ssg_reset() = 0;

    // read/write to the SSG registers
    virtual uint8_t ssg_read(uint32_t regnum) = 0;
    virtual void ssg_write(uint32_t regnum, uint8_t data) = 0;

    // notification when the prescale has changed
    virtual void ssg_prescale_changed() = 0;
};
class ssg_registers
{
public:
    // constants
    static constexpr uint32_t OUTPUTS = 3;
    static constexpr uint32_t CHANNELS = 3;
    static constexpr uint32_t REGISTERS = 0x10;
    static constexpr uint32_t ALL_CHANNELS = (1 << CHANNELS) - 1;

    // constructor
    ssg_registers() { }

    // reset to initial state
    void reset();

    // save/restore
    void save_restore(ymfm_saved_state &state);

    // direct read/write access
    uint8_t read(uint32_t index) { return m_regdata[index]; }
    void write(uint32_t index, uint8_t data) { m_regdata[index] = data; }

    // system-wide registers
    uint32_t noise_period() const                       { return bitfield(m_regdata[0x06], 0, 5); }
    uint32_t io_b_out() const                           { return bitfield(m_regdata[0x07], 7); }
    uint32_t io_a_out() const                           { return bitfield(m_regdata[0x07], 6); }
    uint32_t envelope_period() const                    { return m_regdata[0x0b] | (m_regdata[0x0c] << 8); }
    uint32_t envelope_continue() const                  { return bitfield(m_regdata[0x0d], 3); }
    uint32_t envelope_attack() const                    { return bitfield(m_regdata[0x0d], 2); }
    uint32_t envelope_alternate() const                 { return bitfield(m_regdata[0x0d], 1); }
    uint32_t envelope_hold() const                      { return bitfield(m_regdata[0x0d], 0); }
    uint32_t io_a_data() const                          { return m_regdata[0x0e]; }
    uint32_t io_b_data() const                          { return m_regdata[0x0f]; }

    // per-channel registers
    uint32_t ch_noise_enable(uint32_t choffs) const     { return bitfield(~m_regdata[0x07], 3 + choffs); }
    uint32_t ch_tone_enable(uint32_t choffs) const      { return bitfield(~m_regdata[0x07], 0 + choffs); }
    uint32_t ch_tone_period(uint32_t choffs) const      { return m_regdata[0x00 + 2 * choffs] | (bitfield(m_regdata[0x01 + 2 * choffs], 0, 4) << 8); }
    uint32_t ch_envelope_enable(uint32_t choffs) const  { return bitfield(m_regdata[0x08 + choffs], 4); }
    uint32_t ch_amplitude(uint32_t choffs) const        { return bitfield(m_regdata[0x08 + choffs], 0, 4); }

private:
    // internal state
    uint8_t m_regdata[REGISTERS];         // register data
};

// ======================> ssg_engine

class ssg_engine
{
public:
    static constexpr int OUTPUTS = ssg_registers::OUTPUTS;
    static constexpr int CHANNELS = ssg_registers::CHANNELS;
    static constexpr int CLOCK_DIVIDER = 8;

    using output_data = ymfm_output<OUTPUTS>;

    // constructor
    ssg_engine(ymfm_interface &intf);

    // configure an override
    void override(ssg_override &override) { m_override = &override; }

    // reset our status
    void reset();

    // save/restore
    void save_restore(ymfm_saved_state &state);

    // master clocking function
    void clock();

    // compute sum of channel outputs
    void output(output_data &output);

    // read/write to the SSG registers
    uint8_t read(uint32_t regnum);
    void write(uint32_t regnum, uint8_t data);

    // return a reference to our interface
    ymfm_interface &intf() { return m_intf; }

    // return a reference to our registers
    ssg_registers &regs() { return m_regs; }

    // true if we are overridden
    bool overridden() const { return (m_override != nullptr); }

    // indicate the prescale has changed
    void prescale_changed() { if (m_override != nullptr) m_override->ssg_prescale_changed(); }

private:
    // internal state
    ymfm_interface &m_intf;                   // reference to the interface
    uint32_t m_tone_count[3];               // current tone counter
    uint32_t m_tone_state[3];               // current tone state
    uint32_t m_envelope_count;              // envelope counter
    uint32_t m_envelope_state;              // envelope state
    uint32_t m_noise_count;                 // current noise counter
    uint32_t m_noise_state;                 // current noise state
    ssg_registers m_regs;                   // registers
    ssg_override *m_override;               // override interface
};

//*********************************************************
//  GLOBAL TABLE LOOKUPS
//*********************************************************

//-------------------------------------------------
//  abs_sin_attenuation - given a sin (phase) input
//  where the range 0-2*PI is mapped onto 10 bits,
//  return the absolute value of sin(input),
//  logarithmically-adjusted and treated as an
//  attenuation value, in 4.8 fixed point format
//-------------------------------------------------

inline uint32_t abs_sin_attenuation(uint32_t input)
{
    // the values here are stored as 4.8 logarithmic values for 1/4 phase
    // this matches the internal format of the OPN chip, extracted from the die
    static uint16_t const s_sin_table[256] =
    {
        0x859,0x6c3,0x607,0x58b,0x52e,0x4e4,0x4a6,0x471,0x443,0x41a,0x3f5,0x3d3,0x3b5,0x398,0x37e,0x365,
        0x34e,0x339,0x324,0x311,0x2ff,0x2ed,0x2dc,0x2cd,0x2bd,0x2af,0x2a0,0x293,0x286,0x279,0x26d,0x261,
        0x256,0x24b,0x240,0x236,0x22c,0x222,0x218,0x20f,0x206,0x1fd,0x1f5,0x1ec,0x1e4,0x1dc,0x1d4,0x1cd,
        0x1c5,0x1be,0x1b7,0x1b0,0x1a9,0x1a2,0x19b,0x195,0x18f,0x188,0x182,0x17c,0x177,0x171,0x16b,0x166,
        0x160,0x15b,0x155,0x150,0x14b,0x146,0x141,0x13c,0x137,0x133,0x12e,0x129,0x125,0x121,0x11c,0x118,
        0x114,0x10f,0x10b,0x107,0x103,0x0ff,0x0fb,0x0f8,0x0f4,0x0f0,0x0ec,0x0e9,0x0e5,0x0e2,0x0de,0x0db,
        0x0d7,0x0d4,0x0d1,0x0cd,0x0ca,0x0c7,0x0c4,0x0c1,0x0be,0x0bb,0x0b8,0x0b5,0x0b2,0x0af,0x0ac,0x0a9,
        0x0a7,0x0a4,0x0a1,0x09f,0x09c,0x099,0x097,0x094,0x092,0x08f,0x08d,0x08a,0x088,0x086,0x083,0x081,
        0x07f,0x07d,0x07a,0x078,0x076,0x074,0x072,0x070,0x06e,0x06c,0x06a,0x068,0x066,0x064,0x062,0x060,
        0x05e,0x05c,0x05b,0x059,0x057,0x055,0x053,0x052,0x050,0x04e,0x04d,0x04b,0x04a,0x048,0x046,0x045,
        0x043,0x042,0x040,0x03f,0x03e,0x03c,0x03b,0x039,0x038,0x037,0x035,0x034,0x033,0x031,0x030,0x02f,
        0x02e,0x02d,0x02b,0x02a,0x029,0x028,0x027,0x026,0x025,0x024,0x023,0x022,0x021,0x020,0x01f,0x01e,
        0x01d,0x01c,0x01b,0x01a,0x019,0x018,0x017,0x017,0x016,0x015,0x014,0x014,0x013,0x012,0x011,0x011,
        0x010,0x00f,0x00f,0x00e,0x00d,0x00d,0x00c,0x00c,0x00b,0x00a,0x00a,0x009,0x009,0x008,0x008,0x007,
        0x007,0x007,0x006,0x006,0x005,0x005,0x005,0x004,0x004,0x004,0x003,0x003,0x003,0x002,0x002,0x002,
        0x002,0x001,0x001,0x001,0x001,0x001,0x001,0x001,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000
    };

    // if the top bit is set, we're in the second half of the curve
    // which is a mirror image, so invert the index
    if (bitfield(input, 8))
        input = ~input;

    // return the value from the table
    return s_sin_table[input & 0xff];
}

//-------------------------------------------------
//  attenuation_to_volume - given a 5.8 fixed point
//  logarithmic attenuation value, return a 13-bit
//  linear volume
//-------------------------------------------------

inline uint32_t attenuation_to_volume(uint32_t input)
{
    // the values here are 10-bit mantissas with an implied leading bit
    // this matches the internal format of the OPN chip, extracted from the die

    // as a nod to performance, the implicit 0x400 bit is pre-incorporated, and
    // the values are left-shifted by 2 so that a simple right shift is all that
    // is needed; also the order is reversed to save a NOT on the input
#define X(a) (((a) | 0x400) << 2)
    static uint16_t const s_power_table[256] =
    {
        X(0x3fa),X(0x3f5),X(0x3ef),X(0x3ea),X(0x3e4),X(0x3df),X(0x3da),X(0x3d4),
        X(0x3cf),X(0x3c9),X(0x3c4),X(0x3bf),X(0x3b9),X(0x3b4),X(0x3ae),X(0x3a9),
        X(0x3a4),X(0x39f),X(0x399),X(0x394),X(0x38f),X(0x38a),X(0x384),X(0x37f),
        X(0x37a),X(0x375),X(0x370),X(0x36a),X(0x365),X(0x360),X(0x35b),X(0x356),
        X(0x351),X(0x34c),X(0x347),X(0x342),X(0x33d),X(0x338),X(0x333),X(0x32e),
        X(0x329),X(0x324),X(0x31f),X(0x31a),X(0x315),X(0x310),X(0x30b),X(0x306),
        X(0x302),X(0x2fd),X(0x2f8),X(0x2f3),X(0x2ee),X(0x2e9),X(0x2e5),X(0x2e0),
        X(0x2db),X(0x2d6),X(0x2d2),X(0x2cd),X(0x2c8),X(0x2c4),X(0x2bf),X(0x2ba),
        X(0x2b5),X(0x2b1),X(0x2ac),X(0x2a8),X(0x2a3),X(0x29e),X(0x29a),X(0x295),
        X(0x291),X(0x28c),X(0x288),X(0x283),X(0x27f),X(0x27a),X(0x276),X(0x271),
        X(0x26d),X(0x268),X(0x264),X(0x25f),X(0x25b),X(0x257),X(0x252),X(0x24e),
        X(0x249),X(0x245),X(0x241),X(0x23c),X(0x238),X(0x234),X(0x230),X(0x22b),
        X(0x227),X(0x223),X(0x21e),X(0x21a),X(0x216),X(0x212),X(0x20e),X(0x209),
        X(0x205),X(0x201),X(0x1fd),X(0x1f9),X(0x1f5),X(0x1f0),X(0x1ec),X(0x1e8),
        X(0x1e4),X(0x1e0),X(0x1dc),X(0x1d8),X(0x1d4),X(0x1d0),X(0x1cc),X(0x1c8),
        X(0x1c4),X(0x1c0),X(0x1bc),X(0x1b8),X(0x1b4),X(0x1b0),X(0x1ac),X(0x1a8),
        X(0x1a4),X(0x1a0),X(0x19c),X(0x199),X(0x195),X(0x191),X(0x18d),X(0x189),
        X(0x185),X(0x181),X(0x17e),X(0x17a),X(0x176),X(0x172),X(0x16f),X(0x16b),
        X(0x167),X(0x163),X(0x160),X(0x15c),X(0x158),X(0x154),X(0x151),X(0x14d),
        X(0x149),X(0x146),X(0x142),X(0x13e),X(0x13b),X(0x137),X(0x134),X(0x130),
        X(0x12c),X(0x129),X(0x125),X(0x122),X(0x11e),X(0x11b),X(0x117),X(0x114),
        X(0x110),X(0x10c),X(0x109),X(0x106),X(0x102),X(0x0ff),X(0x0fb),X(0x0f8),
        X(0x0f4),X(0x0f1),X(0x0ed),X(0x0ea),X(0x0e7),X(0x0e3),X(0x0e0),X(0x0dc),
        X(0x0d9),X(0x0d6),X(0x0d2),X(0x0cf),X(0x0cc),X(0x0c8),X(0x0c5),X(0x0c2),
        X(0x0be),X(0x0bb),X(0x0b8),X(0x0b5),X(0x0b1),X(0x0ae),X(0x0ab),X(0x0a8),
        X(0x0a4),X(0x0a1),X(0x09e),X(0x09b),X(0x098),X(0x094),X(0x091),X(0x08e),
        X(0x08b),X(0x088),X(0x085),X(0x082),X(0x07e),X(0x07b),X(0x078),X(0x075),
        X(0x072),X(0x06f),X(0x06c),X(0x069),X(0x066),X(0x063),X(0x060),X(0x05d),
        X(0x05a),X(0x057),X(0x054),X(0x051),X(0x04e),X(0x04b),X(0x048),X(0x045),
        X(0x042),X(0x03f),X(0x03c),X(0x039),X(0x036),X(0x033),X(0x030),X(0x02d),
        X(0x02a),X(0x028),X(0x025),X(0x022),X(0x01f),X(0x01c),X(0x019),X(0x016),
        X(0x014),X(0x011),X(0x00e),X(0x00b),X(0x008),X(0x006),X(0x003),X(0x000)
    };
#undef X

    // look up the fractional part, then shift by the whole
    return s_power_table[input & 0xff] >> (input >> 8);
}

//-------------------------------------------------
//  attenuation_increment - given a 6-bit ADSR
//  rate value and a 3-bit stepping index,
//  return a 4-bit increment to the attenutaion
//  for this step (or for the attack case, the
//  fractional scale factor to decrease by)
//-------------------------------------------------

inline uint32_t attenuation_increment(uint32_t rate, uint32_t index)
{
    static uint32_t const s_increment_table[64] =
    {
        0x00000000, 0x00000000, 0x10101010, 0x10101010,  // 0-3    (0x00-0x03)
        0x10101010, 0x10101010, 0x11101110, 0x11101110,  // 4-7    (0x04-0x07)
        0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 8-11   (0x08-0x0B)
        0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 12-15  (0x0C-0x0F)
        0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 16-19  (0x10-0x13)
        0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 20-23  (0x14-0x17)
        0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 24-27  (0x18-0x1B)
        0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 28-31  (0x1C-0x1F)
        0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 32-35  (0x20-0x23)
        0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 36-39  (0x24-0x27)
        0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 40-43  (0x28-0x2B)
        0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 44-47  (0x2C-0x2F)
        0x11111111, 0x21112111, 0x21212121, 0x22212221,  // 48-51  (0x30-0x33)
        0x22222222, 0x42224222, 0x42424242, 0x44424442,  // 52-55  (0x34-0x37)
        0x44444444, 0x84448444, 0x84848484, 0x88848884,  // 56-59  (0x38-0x3B)
        0x88888888, 0x88888888, 0x88888888, 0x88888888   // 60-63  (0x3C-0x3F)
    };
    return bitfield(s_increment_table[rate], 4*index, 4);
}

//-------------------------------------------------
//  detune_adjustment - given a 5-bit key code
//  value and a 3-bit detune parameter, return a
//  6-bit signed phase displacement; this table
//  has been verified against Nuked's equations,
//  but the equations are rather complicated, so
//  we'll keep the simplicity of the table
//-------------------------------------------------

inline int32_t detune_adjustment(uint32_t detune, uint32_t keycode)
{
    static uint8_t const s_detune_adjustment[32][4] =
    {
        { 0,  0,  1,  2 },  { 0,  0,  1,  2 },  { 0,  0,  1,  2 },  { 0,  0,  1,  2 },
        { 0,  1,  2,  2 },  { 0,  1,  2,  3 },  { 0,  1,  2,  3 },  { 0,  1,  2,  3 },
        { 0,  1,  2,  4 },  { 0,  1,  3,  4 },  { 0,  1,  3,  4 },  { 0,  1,  3,  5 },
        { 0,  2,  4,  5 },  { 0,  2,  4,  6 },  { 0,  2,  4,  6 },  { 0,  2,  5,  7 },
        { 0,  2,  5,  8 },  { 0,  3,  6,  8 },  { 0,  3,  6,  9 },  { 0,  3,  7, 10 },
        { 0,  4,  8, 11 },  { 0,  4,  8, 12 },  { 0,  4,  9, 13 },  { 0,  5, 10, 14 },
        { 0,  5, 11, 16 },  { 0,  6, 12, 17 },  { 0,  6, 13, 19 },  { 0,  7, 14, 20 },
        { 0,  8, 16, 22 },  { 0,  8, 16, 22 },  { 0,  8, 16, 22 },  { 0,  8, 16, 22 }
    };
    int32_t result = s_detune_adjustment[keycode][detune & 3];
    return bitfield(detune, 2) ? -result : result;
}

//-------------------------------------------------
//  opm_key_code_to_phase_step - converts an
//  OPM concatenated block (3 bits), keycode
//  (4 bits) and key fraction (6 bits) to a 0.10
//  phase step, after applying the given delta;
//  this applies to OPM and OPZ, so it lives here
//  in a central location
//-------------------------------------------------

inline uint32_t opm_key_code_to_phase_step(uint32_t block_freq, int32_t delta)
{
    // The phase step is essentially the fnum in OPN-speak. To compute this table,
    // we used the standard formula for computing the frequency of a note, and
    // then converted that frequency to fnum using the formula documented in the
    // YM2608 manual.
    //
    // However, the YM2608 manual describes everything in terms of a nominal 8MHz
    // clock, which produces an FM clock of:
    //
    //    8000000 / 24(operators) / 6(prescale) = 55555Hz FM clock
    //
    // Whereas the descriptions for the YM2151 use a nominal 3.579545MHz clock:
    //
    //    3579545 / 32(operators) / 2(prescale) = 55930Hz FM clock
    //
    // To correct for this, the YM2608 formula was adjusted to use a clock of
    // 8053920Hz, giving this equation for the fnum:
    //
    //    fnum = (double(144) * freq * (1 << 20)) / double(8053920) / 4;
    //
    // Unfortunately, the computed table differs in a few spots from the data
    // verified from an actual chip. The table below comes from David Viens'
    // analysis, used with his permission.
    static const uint32_t s_phase_step[12*64] =
    {
        41568,41600,41632,41664,41696,41728,41760,41792,41856,41888,41920,41952,42016,42048,42080,42112,
        42176,42208,42240,42272,42304,42336,42368,42400,42464,42496,42528,42560,42624,42656,42688,42720,
        42784,42816,42848,42880,42912,42944,42976,43008,43072,43104,43136,43168,43232,43264,43296,43328,
        43392,43424,43456,43488,43552,43584,43616,43648,43712,43744,43776,43808,43872,43904,43936,43968,
        44032,44064,44096,44128,44192,44224,44256,44288,44352,44384,44416,44448,44512,44544,44576,44608,
        44672,44704,44736,44768,44832,44864,44896,44928,44992,45024,45056,45088,45152,45184,45216,45248,
        45312,45344,45376,45408,45472,45504,45536,45568,45632,45664,45728,45760,45792,45824,45888,45920,
        45984,46016,46048,46080,46144,46176,46208,46240,46304,46336,46368,46400,46464,46496,46528,46560,
        46656,46688,46720,46752,46816,46848,46880,46912,46976,47008,47072,47104,47136,47168,47232,47264,
        47328,47360,47392,47424,47488,47520,47552,47584,47648,47680,47744,47776,47808,47840,47904,47936,
        48032,48064,48096,48128,48192,48224,48288,48320,48384,48416,48448,48480,48544,48576,48640,48672,
        48736,48768,48800,48832,48896,48928,48992,49024,49088,49120,49152,49184,49248,49280,49344,49376,
        49440,49472,49504,49536,49600,49632,49696,49728,49792,49824,49856,49888,49952,49984,50048,50080,
        50144,50176,50208,50240,50304,50336,50400,50432,50496,50528,50560,50592,50656,50688,50752,50784,
        50880,50912,50944,50976,51040,51072,51136,51168,51232,51264,51328,51360,51424,51456,51488,51520,
        51616,51648,51680,51712,51776,51808,51872,51904,51968,52000,52064,52096,52160,52192,52224,52256,
        52384,52416,52448,52480,52544,52576,52640,52672,52736,52768,52832,52864,52928,52960,52992,53024,
        53120,53152,53216,53248,53312,53344,53408,53440,53504,53536,53600,53632,53696,53728,53792,53824,
        53920,53952,54016,54048,54112,54144,54208,54240,54304,54336,54400,54432,54496,54528,54592,54624,
        54688,54720,54784,54816,54880,54912,54976,55008,55072,55104,55168,55200,55264,55296,55360,55392,
        55488,55520,55584,55616,55680,55712,55776,55808,55872,55936,55968,56032,56064,56128,56160,56224,
        56288,56320,56384,56416,56480,56512,56576,56608,56672,56736,56768,56832,56864,56928,56960,57024,
        57120,57152,57216,57248,57312,57376,57408,57472,57536,57568,57632,57664,57728,57792,57824,57888,
        57952,57984,58048,58080,58144,58208,58240,58304,58368,58400,58464,58496,58560,58624,58656,58720,
        58784,58816,58880,58912,58976,59040,59072,59136,59200,59232,59296,59328,59392,59456,59488,59552,
        59648,59680,59744,59776,59840,59904,59936,60000,60064,60128,60160,60224,60288,60320,60384,60416,
        60512,60544,60608,60640,60704,60768,60800,60864,60928,60992,61024,61088,61152,61184,61248,61280,
        61376,61408,61472,61536,61600,61632,61696,61760,61824,61856,61920,61984,62048,62080,62144,62208,
        62272,62304,62368,62432,62496,62528,62592,62656,62720,62752,62816,62880,62944,62976,63040,63104,
        63200,63232,63296,63360,63424,63456,63520,63584,63648,63680,63744,63808,63872,63904,63968,64032,
        64096,64128,64192,64256,64320,64352,64416,64480,64544,64608,64672,64704,64768,64832,64896,64928,
        65024,65056,65120,65184,65248,65312,65376,65408,65504,65536,65600,65664,65728,65792,65856,65888,
        65984,66016,66080,66144,66208,66272,66336,66368,66464,66496,66560,66624,66688,66752,66816,66848,
        66944,66976,67040,67104,67168,67232,67296,67328,67424,67456,67520,67584,67648,67712,67776,67808,
        67904,67936,68000,68064,68128,68192,68256,68288,68384,68448,68512,68544,68640,68672,68736,68800,
        68896,68928,68992,69056,69120,69184,69248,69280,69376,69440,69504,69536,69632,69664,69728,69792,
        69920,69952,70016,70080,70144,70208,70272,70304,70400,70464,70528,70560,70656,70688,70752,70816,
        70912,70976,71040,71104,71136,71232,71264,71360,71424,71488,71552,71616,71648,71744,71776,71872,
        71968,72032,72096,72160,72192,72288,72320,72416,72480,72544,72608,72672,72704,72800,72832,72928,
        72992,73056,73120,73184,73216,73312,73344,73440,73504,73568,73632,73696,73728,73824,73856,73952,
        74080,74144,74208,74272,74304,74400,74432,74528,74592,74656,74720,74784,74816,74912,74944,75040,
        75136,75200,75264,75328,75360,75456,75488,75584,75648,75712,75776,75840,75872,75968,76000,76096,
        76224,76288,76352,76416,76448,76544,76576,76672,76736,76800,76864,76928,77024,77120,77152,77248,
        77344,77408,77472,77536,77568,77664,77696,77792,77856,77920,77984,78048,78144,78240,78272,78368,
        78464,78528,78592,78656,78688,78784,78816,78912,78976,79040,79104,79168,79264,79360,79392,79488,
        79616,79680,79744,79808,79840,79936,79968,80064,80128,80192,80256,80320,80416,80512,80544,80640,
        80768,80832,80896,80960,80992,81088,81120,81216,81280,81344,81408,81472,81568,81664,81696,81792,
        81952,82016,82080,82144,82176,82272,82304,82400,82464,82528,82592,82656,82752,82848,82880,82976
    };

    // extract the block (octave) first
    uint32_t block = bitfield(block_freq, 10, 3);

    // the keycode (bits 6-9) is "gappy", mapping 12 values over 16 in each
    // octave; to correct for this, we multiply the 4-bit value by 3/4 (or
    // rather subtract 1/4); note that a (invalid) value of 15 will bleed into
    // the next octave -- this is confirmed
    uint32_t adjusted_code = bitfield(block_freq, 6, 4) - bitfield(block_freq, 8, 2);

    // now re-insert the 6-bit fraction
    int32_t eff_freq = (adjusted_code << 6) | bitfield(block_freq, 0, 6);

    // now that the gaps are removed, add the delta
    eff_freq += delta;

    // handle over/underflow by adjusting the block:
    if (uint32_t(eff_freq) >= 768)
    {
        // minimum delta is -512 (PM), so we can only underflow by 1 octave
        if (eff_freq < 0)
        {
            eff_freq += 768;
            if (block-- == 0)
                return s_phase_step[0] >> 7;
        }

        // maximum delta is +512+608 (PM+detune), so we can overflow by up to 2 octaves
        else
        {
            eff_freq -= 768;
            if (eff_freq >= 768)
                block++, eff_freq -= 768;
            if (block++ >= 7)
                return s_phase_step[767];
        }
    }

    // look up the phase shift for the key code, then shift by octave
    return s_phase_step[eff_freq] >> (block ^ 7);
}

//-------------------------------------------------
//  opn_lfo_pm_phase_adjustment - given the 7 most
//  significant frequency number bits, plus a 3-bit
//  PM depth value and a signed 5-bit raw PM value,
//  return a signed PM adjustment to the frequency;
//  algorithm written to match Nuked behavior
//-------------------------------------------------

inline int32_t opn_lfo_pm_phase_adjustment(uint32_t fnum_bits, uint32_t pm_sensitivity, int32_t lfo_raw_pm)
{
    // this table encodes 2 shift values to apply to the top 7 bits
    // of fnum; it is effectively a cheap multiply by a constant
    // value containing 0-2 bits
    static uint8_t const s_lfo_pm_shifts[8][8] =
    {
        { 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77 },
        { 0x77, 0x77, 0x77, 0x77, 0x72, 0x72, 0x72, 0x72 },
        { 0x77, 0x77, 0x77, 0x72, 0x72, 0x72, 0x17, 0x17 },
        { 0x77, 0x77, 0x72, 0x72, 0x17, 0x17, 0x12, 0x12 },
        { 0x77, 0x77, 0x72, 0x17, 0x17, 0x17, 0x12, 0x07 },
        { 0x77, 0x77, 0x17, 0x12, 0x07, 0x07, 0x02, 0x01 },
        { 0x77, 0x77, 0x17, 0x12, 0x07, 0x07, 0x02, 0x01 },
        { 0x77, 0x77, 0x17, 0x12, 0x07, 0x07, 0x02, 0x01 }
    };

    // look up the relevant shifts
    int32_t abs_pm = (lfo_raw_pm < 0) ? -lfo_raw_pm : lfo_raw_pm;
    uint32_t const shifts = s_lfo_pm_shifts[pm_sensitivity][bitfield(abs_pm, 0, 3)];

    // compute the adjustment
    int32_t adjust = (fnum_bits >> bitfield(shifts, 0, 4)) + (fnum_bits >> bitfield(shifts, 4, 4));
    if (pm_sensitivity > 5)
        adjust <<= pm_sensitivity - 5;
    adjust >>= 2;

    // every 16 cycles it inverts sign
    return (lfo_raw_pm < 0) ? -adjust : adjust;
}

//*********************************************************
//  FM OPERATOR
//*********************************************************

//-------------------------------------------------
//  fm_operator - constructor
//-------------------------------------------------

template<class RegisterType>
fm_operator<RegisterType>::fm_operator(fm_engine_base<RegisterType> &owner, uint32_t opoffs) :
    m_choffs(0),
    m_opoffs(opoffs),
    m_phase(0),
    m_env_attenuation(0x3ff),
    m_env_state(EG_RELEASE),
    m_ssg_inverted(false),
    m_key_state(0),
    m_keyon_live(0),
    m_regs(owner.regs()),
    m_owner(owner)
{
}

//-------------------------------------------------
//  reset - reset the channel state
//-------------------------------------------------

template<class RegisterType>
void fm_operator<RegisterType>::reset()
{
    // reset our data
    m_phase = 0;
    m_env_attenuation = 0x3ff;
    m_env_state = EG_RELEASE;
    m_ssg_inverted = 0;
    m_key_state = 0;
    m_keyon_live = 0;
}

//-------------------------------------------------
//  save_restore - save or restore the data
//-------------------------------------------------

template<class RegisterType>
void fm_operator<RegisterType>::save_restore(ymfm_saved_state &state)
{
    state.save_restore(m_phase);
    state.save_restore(m_env_attenuation);
    state.save_restore(m_env_state);
    state.save_restore(m_ssg_inverted);
    state.save_restore(m_key_state);
    state.save_restore(m_keyon_live);
}

//-------------------------------------------------
//  prepare - prepare for clocking
//-------------------------------------------------

template<class RegisterType>
bool fm_operator<RegisterType>::prepare()
{
    // cache the data
    m_regs.cache_operator_data(m_choffs, m_opoffs, m_cache);

    // clock the key state
    clock_keystate(uint32_t(m_keyon_live != 0));
    m_keyon_live &= ~(1 << KEYON_CSM);

    // we're active until we're quiet after the release
    return (m_env_state != (RegisterType::EG_HAS_REVERB ? EG_REVERB : EG_RELEASE) || m_env_attenuation < EG_QUIET);
}

//-------------------------------------------------
//  clock - master clocking function
//-------------------------------------------------

template<class RegisterType>
void fm_operator<RegisterType>::clock(uint32_t env_counter, int32_t lfo_raw_pm)
{
    // clock the SSG-EG state (OPN/OPNA)
    if (m_regs.op_ssg_eg_enable(m_opoffs))
        clock_ssg_eg_state();

    // clock the envelope if on an envelope cycle; env_counter is a x.2 value
    if (bitfield(env_counter, 0, 2) == 0)
        clock_envelope(env_counter >> 2);

    // clock the phase
    clock_phase(lfo_raw_pm);
}

//-------------------------------------------------
//  compute_volume - compute the 14-bit signed
//  volume of this operator, given a phase
//  modulation and an AM LFO offset
//-------------------------------------------------

template<class RegisterType>
int32_t fm_operator<RegisterType>::compute_volume(uint32_t phase, uint32_t am_offset) const
{
    // the low 10 bits of phase represents a full 2*PI period over
    // the full sin wave

#if 0
// temporary envelope logging
if (m_choffs == 0)
{
    printf("  %c@%02X:%03X", "PADSRV"[m_env_state], m_cache.eg_rate[m_env_state], envelope_attenuation(am_offset));
    if (m_opoffs == 0x18) printf("\n");
}
#endif

    // early out if the envelope is effectively off
    if (m_env_attenuation > EG_QUIET)
        return 0;

    // get the absolute value of the sin, as attenuation, as a 4.8 fixed point value
    uint32_t sin_attenuation = m_cache.waveform[phase & (RegisterType::WAVEFORM_LENGTH - 1)];

    // get the attenuation from the evelope generator as a 4.6 value, shifted up to 4.8
    uint32_t env_attenuation = envelope_attenuation(am_offset) << 2;

    // combine into a 5.8 value, then convert from attenuation to 13-bit linear volume
    int32_t result = attenuation_to_volume((sin_attenuation & 0x7fff) + env_attenuation);

    // negate if in the negative part of the sin wave (sign bit gives 14 bits)
    return bitfield(sin_attenuation, 15) ? -result : result;
}

//-------------------------------------------------
//  compute_noise_volume - compute the 14-bit
//  signed noise volume of this operator, given a
//  noise input value and an AM offset
//-------------------------------------------------

template<class RegisterType>
int32_t fm_operator<RegisterType>::compute_noise_volume(uint32_t am_offset) const
{
    // application manual says the logarithmic transform is not applied here, so we
    // just use the raw envelope attenuation, inverted (since 0 attenuation should be
    // maximum), and shift it up from a 10-bit value to an 11-bit value
    int32_t result = (envelope_attenuation(am_offset) ^ 0x3ff) << 1;

    // QUESTION: is AM applied still?

    // negate based on the noise state
    return bitfield(m_regs.noise_state(), 0) ? -result : result;
}

//-------------------------------------------------
//  keyonoff - signal a key on/off event
//-------------------------------------------------

template<class RegisterType>
void fm_operator<RegisterType>::keyonoff(uint32_t on, keyon_type type)
{
    m_keyon_live = (m_keyon_live & ~(1 << int(type))) | (bitfield(on, 0) << int(type));
}

//-------------------------------------------------
//  start_attack - start the attack phase; called
//  when a keyon happens or when an SSG-EG cycle
//  is complete and restarts
//-------------------------------------------------

template<class RegisterType>
void fm_operator<RegisterType>::start_attack(bool is_restart)
{
    // don't change anything if already in attack state
    if (m_env_state == EG_ATTACK)
        return;
    m_env_state = EG_ATTACK;

    // generally not inverted at start, except if SSG-EG is enabled and
    // one of the inverted modes is specified; leave this alone on a
    // restart, as it is managed by the clock_ssg_eg_state() code
    if (RegisterType::EG_HAS_SSG && !is_restart)
        m_ssg_inverted = m_regs.op_ssg_eg_enable(m_opoffs) & bitfield(m_regs.op_ssg_eg_mode(m_opoffs), 2);

    // reset the phase when we start an attack due to a key on
    // (but not when due to an SSG-EG restart except in certain cases
    // managed directly by the SSG-EG code)
    if (!is_restart)
        m_phase = 0;

    // if the attack rate >= 62 then immediately go to max attenuation
    if (m_cache.eg_rate[EG_ATTACK] >= 62)
        m_env_attenuation = 0;
}

//-------------------------------------------------
//  start_release - start the release phase;
//  called when a keyoff happens
//-------------------------------------------------

template<class RegisterType>
void fm_operator<RegisterType>::start_release()
{
    // don't change anything if already in release state
    if (m_env_state >= EG_RELEASE)
        return;
    m_env_state = EG_RELEASE;

    // if attenuation if inverted due to SSG-EG, snap the inverted attenuation
    // as the starting point
    if (RegisterType::EG_HAS_SSG && m_ssg_inverted)
    {
        m_env_attenuation = (0x200 - m_env_attenuation) & 0x3ff;
        m_ssg_inverted = false;
    }
}

//-------------------------------------------------
//  clock_keystate - clock the keystate to match
//  the incoming keystate
//-------------------------------------------------

template<class RegisterType>
void fm_operator<RegisterType>::clock_keystate(uint32_t keystate)
{
    assert(keystate == 0 || keystate == 1);

    // has the key changed?
    if ((keystate ^ m_key_state) != 0)
    {
        m_key_state = keystate;

        // if the key has turned on, start the attack
        if (keystate != 0)
        {
            // OPLL has a DP ("depress"?) state to bring the volume
            // down before starting the attack
            if (RegisterType::EG_HAS_DEPRESS && m_env_attenuation < 0x200)
                m_env_state = EG_DEPRESS;
            else
                start_attack();
        }

        // otherwise, start the release
        else
            start_release();
    }
}

//-------------------------------------------------
//  clock_ssg_eg_state - clock the SSG-EG state;
//  should only be called if SSG-EG is enabled
//-------------------------------------------------

template<class RegisterType>
void fm_operator<RegisterType>::clock_ssg_eg_state()
{
    // work only happens once the attenuation crosses above 0x200
    if (!bitfield(m_env_attenuation, 9))
        return;

    // 8 SSG-EG modes:
    //    000: repeat normally
    //    001: run once, hold low
    //    010: repeat, alternating between inverted/non-inverted
    //    011: run once, hold high
    //    100: inverted repeat normally
    //    101: inverted run once, hold low
    //    110: inverted repeat, alternating between inverted/non-inverted
    //    111: inverted run once, hold high
    uint32_t mode = m_regs.op_ssg_eg_mode(m_opoffs);

    // hold modes (1/3/5/7)
    if (bitfield(mode, 0))
    {
        // set the inverted flag to the end state (0 for modes 1/7, 1 for modes 3/5)
        m_ssg_inverted = bitfield(mode, 2) ^ bitfield(mode, 1);

        // if holding, force the attenuation to the expected value once we're
        // past the attack phase
        if (m_env_state != EG_ATTACK)
            m_env_attenuation = m_ssg_inverted ? 0x200 : 0x3ff;
    }

    // continuous modes (0/2/4/6)
    else
    {
        // toggle invert in alternating mode (even in attack state)
        m_ssg_inverted ^= bitfield(mode, 1);

        // restart attack if in decay/sustain states
        if (m_env_state == EG_DECAY || m_env_state == EG_SUSTAIN)
            start_attack(true);

        // phase is reset to 0 in modes 0/4
        if (bitfield(mode, 1) == 0)
            m_phase = 0;
    }

    // in all modes, once we hit release state, attenuation is forced to maximum
    if (m_env_state == EG_RELEASE)
        m_env_attenuation = 0x3ff;
}

//-------------------------------------------------
//  clock_envelope - clock the envelope state
//  according to the given count
//-------------------------------------------------

template<class RegisterType>
void fm_operator<RegisterType>::clock_envelope(uint32_t env_counter)
{
    // handle attack->decay transitions
    if (m_env_state == EG_ATTACK && m_env_attenuation == 0)
        m_env_state = EG_DECAY;

    // handle decay->sustain transitions; it is important to do this immediately
    // after the attack->decay transition above in the event that the sustain level
    // is set to 0 (in which case we will skip right to sustain without doing any
    // decay); as an example where this can be heard, check the cymbals sound
    // in channel 0 of shinobi's test mode sound #5
    if (m_env_state == EG_DECAY && m_env_attenuation >= m_cache.eg_sustain)
        m_env_state = EG_SUSTAIN;

    // fetch the appropriate 6-bit rate value from the cache
    uint32_t rate = m_cache.eg_rate[m_env_state];

    // compute the rate shift value; this is the shift needed to
    // apply to the env_counter such that it becomes a 5.11 fixed
    // point number
    uint32_t rate_shift = rate >> 2;
    env_counter <<= rate_shift;

    // see if the fractional part is 0; if not, it's not time to clock
    if (bitfield(env_counter, 0, 11) != 0)
        return;

    // determine the increment based on the non-fractional part of env_counter
    uint32_t relevant_bits = bitfield(env_counter, (rate_shift <= 11) ? 11 : rate_shift, 3);
    uint32_t increment = attenuation_increment(rate, relevant_bits);

    // attack is the only one that increases
    if (m_env_state == EG_ATTACK)
    {
        // glitch means that attack rates of 62/63 don't increment if
        // changed after the initial key on (where they are handled
        // specially); nukeykt confirms this happens on OPM, OPN, OPL/OPLL
        // at least so assuming it is true for everyone
        if (rate < 62)
            m_env_attenuation += (~m_env_attenuation * increment) >> 4;
    }

    // all other cases are similar
    else
    {
        // non-SSG-EG cases just apply the increment
        if (!m_regs.op_ssg_eg_enable(m_opoffs))
            m_env_attenuation += increment;

        // SSG-EG only applies if less than mid-point, and then at 4x
        else if (m_env_attenuation < 0x200)
            m_env_attenuation += 4 * increment;

        // clamp the final attenuation
        if (m_env_attenuation >= 0x400)
            m_env_attenuation = 0x3ff;

        // transition from depress to attack
        if (RegisterType::EG_HAS_DEPRESS && m_env_state == EG_DEPRESS && m_env_attenuation >= 0x200)
            start_attack();

        // transition from release to reverb, should switch at -18dB
        if (RegisterType::EG_HAS_REVERB && m_env_state == EG_RELEASE && m_env_attenuation >= 0xc0)
            m_env_state = EG_REVERB;
    }
}

//-------------------------------------------------
//  clock_phase - clock the 10.10 phase value; the
//  OPN version of the logic has been verified
//  against the Nuked phase generator
//-------------------------------------------------

template<class RegisterType>
void fm_operator<RegisterType>::clock_phase(int32_t lfo_raw_pm)
{
    // read from the cache, or recalculate if PM active
    uint32_t phase_step = m_cache.phase_step;
    if (phase_step == opdata_cache::PHASE_STEP_DYNAMIC)
        phase_step = m_regs.compute_phase_step(m_choffs, m_opoffs, m_cache, lfo_raw_pm);

    // finally apply the step to the current phase value
    m_phase += phase_step;
}

//-------------------------------------------------
//  envelope_attenuation - return the effective
//  attenuation of the envelope
//-------------------------------------------------

template<class RegisterType>
uint32_t fm_operator<RegisterType>::envelope_attenuation(uint32_t am_offset) const
{
    uint32_t result = m_env_attenuation >> m_cache.eg_shift;

    // invert if necessary due to SSG-EG
    if (RegisterType::EG_HAS_SSG && m_ssg_inverted)
        result = (0x200 - result) & 0x3ff;

    // add in LFO AM modulation
    if (m_regs.op_lfo_am_enable(m_opoffs))
        result += am_offset;

    // add in total level and KSL from the cache
    result += m_cache.total_level;

    // clamp to max, apply shift, and return
    return std::min<uint32_t>(result, 0x3ff);
}

//*********************************************************
//  FM CHANNEL
//*********************************************************

//-------------------------------------------------
//  fm_channel - constructor
//-------------------------------------------------

template<class RegisterType>
fm_channel<RegisterType>::fm_channel(fm_engine_base<RegisterType> &owner, uint32_t choffs) :
    m_choffs(choffs),
    m_feedback{ 0, 0 },
    m_feedback_in(0),
    m_op{ nullptr, nullptr, nullptr, nullptr },
    m_regs(owner.regs()),
    m_owner(owner)
{
}

//-------------------------------------------------
//  reset - reset the channel state
//-------------------------------------------------

template<class RegisterType>
void fm_channel<RegisterType>::reset()
{
    // reset our data
    m_feedback[0] = m_feedback[1] = 0;
    m_feedback_in = 0;
}

//-------------------------------------------------
//  save_restore - save or restore the data
//-------------------------------------------------

template<class RegisterType>
void fm_channel<RegisterType>::save_restore(ymfm_saved_state &state)
{
    state.save_restore(m_feedback[0]);
    state.save_restore(m_feedback[1]);
    state.save_restore(m_feedback_in);
}

//-------------------------------------------------
//  keyonoff - signal key on/off to our operators
//-------------------------------------------------

template<class RegisterType>
void fm_channel<RegisterType>::keyonoff(uint32_t states, keyon_type type, uint32_t chnum)
{
    for (uint32_t opnum = 0; opnum < array_size(m_op); opnum++)
        if (m_op[opnum] != nullptr)
            m_op[opnum]->keyonoff(bitfield(states, opnum), type);

    if (debug::LOG_KEYON_EVENTS && ((debug::GLOBAL_FM_CHANNEL_MASK >> chnum) & 1) != 0)
        for (uint32_t opnum = 0; opnum < array_size(m_op); opnum++)
            if (m_op[opnum] != nullptr)
                debug::log_keyon("%c%s\n", bitfield(states, opnum) ? '+' : '-', m_regs.log_keyon(m_choffs, m_op[opnum]->opoffs()).c_str());
}

//-------------------------------------------------
//  prepare - prepare for clocking
//-------------------------------------------------

template<class RegisterType>
bool fm_channel<RegisterType>::prepare()
{
    uint32_t active_mask = 0;

    // prepare all operators and determine if they are active
    for (uint32_t opnum = 0; opnum < array_size(m_op); opnum++)
        if (m_op[opnum] != nullptr)
            if (m_op[opnum]->prepare())
                active_mask |= 1 << opnum;

    return (active_mask != 0);
}

//-------------------------------------------------
//  clock - master clock of all operators
//-------------------------------------------------

template<class RegisterType>
void fm_channel<RegisterType>::clock(uint32_t env_counter, int32_t lfo_raw_pm)
{
    // clock the feedback through
    m_feedback[0] = m_feedback[1];
    m_feedback[1] = m_feedback_in;

    for (uint32_t opnum = 0; opnum < array_size(m_op); opnum++)
        if (m_op[opnum] != nullptr)
            m_op[opnum]->clock(env_counter, lfo_raw_pm);
}

//-------------------------------------------------
//  output_2op - combine 4 operators according to
//  the specified algorithm, returning a sum
//  according to the rshift and clipmax parameters,
//  which vary between different implementations
//-------------------------------------------------

template<class RegisterType>
void fm_channel<RegisterType>::output_2op(output_data &output, uint32_t rshift, int32_t clipmax) const
{
    // The first 2 operators should be populated
    assert(m_op[0] != nullptr);
    assert(m_op[1] != nullptr);

    // AM amount is the same across all operators; compute it once
    uint32_t am_offset = m_regs.lfo_am_offset(m_choffs);

    // operator 1 has optional self-feedback
    int32_t opmod = 0;
    uint32_t feedback = m_regs.ch_feedback(m_choffs);
    if (feedback != 0)
        opmod = (m_feedback[0] + m_feedback[1]) >> (10 - feedback);

    // compute the 14-bit volume/value of operator 1 and update the feedback
    int32_t op1value = m_feedback_in = m_op[0]->compute_volume(m_op[0]->phase() + opmod, am_offset);

    // now that the feedback has been computed, skip the rest if all volumes
    // are clear; no need to do all this work for nothing
    if (m_regs.ch_output_any(m_choffs) == 0)
        return;

    // Algorithms for two-operator case:
    //    0: O1 -> O2 -> out
    //    1: (O1 + O2) -> out
    int32_t result;
    if (bitfield(m_regs.ch_algorithm(m_choffs), 0) == 0)
    {
        // some OPL chips use the previous sample for modulation instead of
        // the current sample
        opmod = (RegisterType::MODULATOR_DELAY ? m_feedback[1] : op1value) >> 1;
        result = m_op[1]->compute_volume(m_op[1]->phase() + opmod, am_offset) >> rshift;
    }
    else
    {
        result = op1value + (m_op[1]->compute_volume(m_op[1]->phase(), am_offset) >> rshift);
        int32_t clipmin = -clipmax - 1;
        result = clamp(result, clipmin, clipmax);
    }

    // add to the output
    add_to_output(m_choffs, output, result);
}

//-------------------------------------------------
//  output_4op - combine 4 operators according to
//  the specified algorithm, returning a sum
//  according to the rshift and clipmax parameters,
//  which vary between different implementations
//-------------------------------------------------

template<class RegisterType>
void fm_channel<RegisterType>::output_4op(output_data &output, uint32_t rshift, int32_t clipmax) const
{
    // all 4 operators should be populated
    assert(m_op[0] != nullptr);
    assert(m_op[1] != nullptr);
    assert(m_op[2] != nullptr);
    assert(m_op[3] != nullptr);

    // AM amount is the same across all operators; compute it once
    uint32_t am_offset = m_regs.lfo_am_offset(m_choffs);

    // operator 1 has optional self-feedback
    int32_t opmod = 0;
    uint32_t feedback = m_regs.ch_feedback(m_choffs);
    if (feedback != 0)
        opmod = (m_feedback[0] + m_feedback[1]) >> (10 - feedback);

    // compute the 14-bit volume/value of operator 1 and update the feedback
    int32_t op1value = m_feedback_in = m_op[0]->compute_volume(m_op[0]->phase() + opmod, am_offset);

    // now that the feedback has been computed, skip the rest if all volumes
    // are clear; no need to do all this work for nothing
    if (m_regs.ch_output_any(m_choffs) == 0)
        return;

    // OPM/OPN offer 8 different connection algorithms for 4 operators,
    // and OPL3 offers 4 more, which we designate here as 8-11.
    //
    // The operators are computed in order, with the inputs pulled from
    // an array of values (opout) that is populated as we go:
    //    0 = 0
    //    1 = O1
    //    2 = O2
    //    3 = O3
    //    4 = (O4)
    //    5 = O1+O2
    //    6 = O1+O3
    //    7 = O2+O3
    //
    // The s_algorithm_ops table describes the inputs and outputs of each
    // algorithm as follows:
    //
    //      ---------x use opout[x] as operator 2 input
    //      ------xxx- use opout[x] as operator 3 input
    //      ---xxx---- use opout[x] as operator 4 input
    //      --x------- include opout[1] in final sum
    //      -x-------- include opout[2] in final sum
    //      x--------- include opout[3] in final sum
    #define ALGORITHM(op2in, op3in, op4in, op1out, op2out, op3out) \
        ((op2in) | ((op3in) << 1) | ((op4in) << 4) | ((op1out) << 7) | ((op2out) << 8) | ((op3out) << 9))
    static uint16_t const s_algorithm_ops[8+4] =
    {
        ALGORITHM(1,2,3, 0,0,0),    //  0: O1 -> O2 -> O3 -> O4 -> out (O4)
        ALGORITHM(0,5,3, 0,0,0),    //  1: (O1 + O2) -> O3 -> O4 -> out (O4)
        ALGORITHM(0,2,6, 0,0,0),    //  2: (O1 + (O2 -> O3)) -> O4 -> out (O4)
        ALGORITHM(1,0,7, 0,0,0),    //  3: ((O1 -> O2) + O3) -> O4 -> out (O4)
        ALGORITHM(1,0,3, 0,1,0),    //  4: ((O1 -> O2) + (O3 -> O4)) -> out (O2+O4)
        ALGORITHM(1,1,1, 0,1,1),    //  5: ((O1 -> O2) + (O1 -> O3) + (O1 -> O4)) -> out (O2+O3+O4)
        ALGORITHM(1,0,0, 0,1,1),    //  6: ((O1 -> O2) + O3 + O4) -> out (O2+O3+O4)
        ALGORITHM(0,0,0, 1,1,1),    //  7: (O1 + O2 + O3 + O4) -> out (O1+O2+O3+O4)
        ALGORITHM(1,2,3, 0,0,0),    //  8: O1 -> O2 -> O3 -> O4 -> out (O4)         [same as 0]
        ALGORITHM(0,2,3, 1,0,0),    //  9: (O1 + (O2 -> O3 -> O4)) -> out (O1+O4)   [unique]
        ALGORITHM(1,0,3, 0,1,0),    // 10: ((O1 -> O2) + (O3 -> O4)) -> out (O2+O4) [same as 4]
        ALGORITHM(0,2,0, 1,0,1)     // 11: (O1 + (O2 -> O3) + O4) -> out (O1+O3+O4) [unique]
    };
    uint32_t algorithm_ops = s_algorithm_ops[m_regs.ch_algorithm(m_choffs)];

    // populate the opout table
    int16_t opout[8];
    opout[0] = 0;
    opout[1] = op1value;

    // compute the 14-bit volume/value of operator 2
    opmod = opout[bitfield(algorithm_ops, 0, 1)] >> 1;
    opout[2] = m_op[1]->compute_volume(m_op[1]->phase() + opmod, am_offset);
    opout[5] = opout[1] + opout[2];

    // compute the 14-bit volume/value of operator 3
    opmod = opout[bitfield(algorithm_ops, 1, 3)] >> 1;
    opout[3] = m_op[2]->compute_volume(m_op[2]->phase() + opmod, am_offset);
    opout[6] = opout[1] + opout[3];
    opout[7] = opout[2] + opout[3];

    // compute the 14-bit volume/value of operator 4; this could be a noise
    // value on the OPM; all algorithms consume OP4 output at a minimum
    int32_t result;
    if (m_regs.noise_enable() && m_choffs == 7)
        result = m_op[3]->compute_noise_volume(am_offset);
    else
    {
        opmod = opout[bitfield(algorithm_ops, 4, 3)] >> 1;
        result = m_op[3]->compute_volume(m_op[3]->phase() + opmod, am_offset);
    }
    result >>= rshift;

    // optionally add OP1, OP2, OP3
    int32_t clipmin = -clipmax - 1;
    if (bitfield(algorithm_ops, 7) != 0)
        result = clamp(result + (opout[1] >> rshift), clipmin, clipmax);
    if (bitfield(algorithm_ops, 8) != 0)
        result = clamp(result + (opout[2] >> rshift), clipmin, clipmax);
    if (bitfield(algorithm_ops, 9) != 0)
        result = clamp(result + (opout[3] >> rshift), clipmin, clipmax);

    // add to the output
    add_to_output(m_choffs, output, result);
}

//-------------------------------------------------
//  output_rhythm_ch6 - special case output
//  computation for OPL channel 6 in rhythm mode,
//  which outputs a Bass Drum instrument
//-------------------------------------------------

template<class RegisterType>
void fm_channel<RegisterType>::output_rhythm_ch6(output_data &output, uint32_t rshift, int32_t clipmax) const
{
    // AM amount is the same across all operators; compute it once
    uint32_t am_offset = m_regs.lfo_am_offset(m_choffs);

    // Bass Drum: this uses operators 12 and 15 (i.e., channel 6)
    // in an almost-normal way, except that if the algorithm is 1,
    // the first operator is ignored instead of added in

    // operator 1 has optional self-feedback
    int32_t opmod = 0;
    uint32_t feedback = m_regs.ch_feedback(m_choffs);
    if (feedback != 0)
        opmod = (m_feedback[0] + m_feedback[1]) >> (10 - feedback);

    // compute the 14-bit volume/value of operator 1 and update the feedback
    int32_t opout1 = m_feedback_in = m_op[0]->compute_volume(m_op[0]->phase() + opmod, am_offset);

    // compute the 14-bit volume/value of operator 2, which is the result
    opmod = bitfield(m_regs.ch_algorithm(m_choffs), 0) ? 0 : (opout1 >> 1);
    int32_t result = m_op[1]->compute_volume(m_op[1]->phase() + opmod, am_offset) >> rshift;

    // add to the output
    add_to_output(m_choffs, output, result * 2);
}

//-------------------------------------------------
//  output_rhythm_ch7 - special case output
//  computation for OPL channel 7 in rhythm mode,
//  which outputs High Hat and Snare Drum
//  instruments
//-------------------------------------------------

template<class RegisterType>
void fm_channel<RegisterType>::output_rhythm_ch7(uint32_t phase_select, output_data &output, uint32_t rshift, int32_t clipmax) const
{
    // AM amount is the same across all operators; compute it once
    uint32_t am_offset = m_regs.lfo_am_offset(m_choffs);
    uint32_t noise_state = bitfield(m_regs.noise_state(), 0);

    // High Hat: this uses the envelope from operator 13 (channel 7),
    // and a combination of noise and the operator 13/17 phase select
    // to compute the phase
    uint32_t phase = (phase_select << 9) | (0xd0 >> (2 * (noise_state ^ phase_select)));
    int32_t result = m_op[0]->compute_volume(phase, am_offset) >> rshift;

    // Snare Drum: this uses the envelope from operator 16 (channel 7),
    // and a combination of noise and operator 13 phase to pick a phase
    uint32_t op13phase = m_op[0]->phase();
    phase = (0x100 << bitfield(op13phase, 8)) ^ (noise_state << 8);
    result += m_op[1]->compute_volume(phase, am_offset) >> rshift;
    result = clamp(result, -clipmax - 1, clipmax);

    // add to the output
    add_to_output(m_choffs, output, result * 2);
}

//-------------------------------------------------
//  output_rhythm_ch8 - special case output
//  computation for OPL channel 8 in rhythm mode,
//  which outputs Tom Tom and Top Cymbal instruments
//-------------------------------------------------

template<class RegisterType>
void fm_channel<RegisterType>::output_rhythm_ch8(uint32_t phase_select, output_data &output, uint32_t rshift, int32_t clipmax) const
{
    // AM amount is the same across all operators; compute it once
    uint32_t am_offset = m_regs.lfo_am_offset(m_choffs);

    // Tom Tom: this is just a single operator processed normally
    int32_t result = m_op[0]->compute_volume(m_op[0]->phase(), am_offset) >> rshift;

    // Top Cymbal: this uses the envelope from operator 17 (channel 8),
    // and the operator 13/17 phase select to compute the phase
    uint32_t phase = 0x100 | (phase_select << 9);
    result += m_op[1]->compute_volume(phase, am_offset) >> rshift;
    result = clamp(result, -clipmax - 1, clipmax);

    // add to the output
    add_to_output(m_choffs, output, result * 2);
}

//*********************************************************
//  FM ENGINE BASE
//*********************************************************

//-------------------------------------------------
//  fm_engine_base - constructor
//-------------------------------------------------

template<class RegisterType>
fm_engine_base<RegisterType>::fm_engine_base(ymfm_interface &intf) :
    m_intf(intf),
    m_env_counter(0),
    m_status(0),
    m_clock_prescale(RegisterType::DEFAULT_PRESCALE),
    m_irq_mask(STATUS_TIMERA | STATUS_TIMERB),
    m_irq_state(0),
    m_timer_running{0,0},
    m_active_channels(ALL_CHANNELS),
    m_modified_channels(ALL_CHANNELS),
    m_prepare_count(0)
{
    // inform the interface of their engine
    m_intf.m_engine = this;

    // create the channels
    for (uint32_t chnum = 0; chnum < CHANNELS; chnum++)
        m_channel[chnum] = std::make_unique<fm_channel<RegisterType>>(*this, RegisterType::channel_offset(chnum));

    // create the operators
    for (uint32_t opnum = 0; opnum < OPERATORS; opnum++)
        m_operator[opnum] = std::make_unique<fm_operator<RegisterType>>(*this, RegisterType::operator_offset(opnum));

    // do the initial operator assignment
    assign_operators();
}

//-------------------------------------------------
//  reset - reset the overall state
//-------------------------------------------------

template<class RegisterType>
void fm_engine_base<RegisterType>::reset()
{
    // reset all status bits
    set_reset_status(0, 0xff);

    // register type-specific initialization
    m_regs.reset();

    // explicitly write to the mode register since it has side-effects
    // QUESTION: old cores initialize this to 0x30 -- who is right?
    write(RegisterType::REG_MODE, 0);

    // reset the channels
    for (auto &chan : m_channel)
        chan->reset();

    // reset the operators
    for (auto &op : m_operator)
        op->reset();
}

//-------------------------------------------------
//  save_restore - save or restore the data
//-------------------------------------------------

template<class RegisterType>
void fm_engine_base<RegisterType>::save_restore(ymfm_saved_state &state)
{
    // save our data
    state.save_restore(m_env_counter);
    state.save_restore(m_status);
    state.save_restore(m_clock_prescale);
    state.save_restore(m_irq_mask);
    state.save_restore(m_irq_state);
    state.save_restore(m_timer_running[0]);
    state.save_restore(m_timer_running[1]);

    // save the register/family data
    m_regs.save_restore(state);

    // save channel data
    for (uint32_t chnum = 0; chnum < CHANNELS; chnum++)
        m_channel[chnum]->save_restore(state);

    // save operator data
    for (uint32_t opnum = 0; opnum < OPERATORS; opnum++)
        m_operator[opnum]->save_restore(state);

    // invalidate any caches
    invalidate_caches();
}

//-------------------------------------------------
//  clock - iterate over all channels, clocking
//  them forward one step
//-------------------------------------------------

template<class RegisterType>
uint32_t fm_engine_base<RegisterType>::clock(uint32_t chanmask)
{
    // if something was modified, prepare
    // also prepare every 4k samples to catch ending notes
    if (m_modified_channels != 0 || m_prepare_count++ >= 4096)
    {
        // reassign operators to channels if dynamic
        if (RegisterType::DYNAMIC_OPS)
            assign_operators();

        // call each channel to prepare
        m_active_channels = 0;
        for (uint32_t chnum = 0; chnum < CHANNELS; chnum++)
            if (bitfield(chanmask, chnum))
                if (m_channel[chnum]->prepare())
                    m_active_channels |= 1 << chnum;

        // reset the modified channels and prepare count
        m_modified_channels = m_prepare_count = 0;
    }

    // if the envelope clock divider is 1, just increment by 4;
    // otherwise, increment by 1 and manually wrap when we reach the divide count
    if (RegisterType::EG_CLOCK_DIVIDER == 1)
        m_env_counter += 4;
    else if (bitfield(++m_env_counter, 0, 2) == RegisterType::EG_CLOCK_DIVIDER)
        m_env_counter += 4 - RegisterType::EG_CLOCK_DIVIDER;

    // clock the noise generator
    int32_t lfo_raw_pm = m_regs.clock_noise_and_lfo();

    // now update the state of all the channels and operators
    for (uint32_t chnum = 0; chnum < CHANNELS; chnum++)
        if (bitfield(chanmask, chnum))
            m_channel[chnum]->clock(m_env_counter, lfo_raw_pm);

#if 0
//Temporary debugging...
static double curtime = 0;
//for (uint32_t chnum = 0; chnum < CHANNELS; chnum++)
uint32_t chnum = 4;
{
    printf("t=%.4f ch%d: ", curtime, chnum);
    for (uint32_t opnum = 0; opnum < 4; opnum++)
    {
        auto op = debug_channel(chnum)->debug_operator(opnum);
        auto eg_state = op->debug_eg_state();
        printf(" %c%03X[%02X]%c ", "PADSRV"[eg_state], op.debug_eg_attenuation(), op.debug_cache().eg_rate[eg_state], m_regs.op_ssg_eg_enable(op.opoffs()) ? '*' : ' ');
    }
    printf(" -- ");
}
curtime += 1.0 / double(sample_rate(7670454));
#endif

    // return the envelope counter as it is used to clock ADPCM-A
    return m_env_counter;
}

//-------------------------------------------------
//  output - compute a sum over the relevant
//  channels
//-------------------------------------------------

template<class RegisterType>
void fm_engine_base<RegisterType>::output(output_data &output, uint32_t rshift, int32_t clipmax, uint32_t chanmask) const
{
    // mask out some channels for debug purposes
    chanmask &= debug::GLOBAL_FM_CHANNEL_MASK;

    // mask out inactive channels
    chanmask &= m_active_channels;

    // handle the rhythm case, where some of the operators are dedicated
    // to percussion (this is an OPL-specific feature)
    if (m_regs.rhythm_enable())
    {
        // we don't support the OPM noise channel here; ensure it is off
        assert(m_regs.noise_enable() == 0);

        // precompute the operator 13+17 phase selection value
        uint32_t op13phase = m_operator[13]->phase();
        uint32_t op17phase = m_operator[17]->phase();
        uint32_t phase_select = (bitfield(op13phase, 2) ^ bitfield(op13phase, 7)) | bitfield(op13phase, 3) | (bitfield(op17phase, 5) ^ bitfield(op17phase, 3));

        // sum over all the desired channels
        for (uint32_t chnum = 0; chnum < CHANNELS; chnum++)
            if (bitfield(chanmask, chnum))
            {
                if (chnum == 6)
                    m_channel[chnum]->output_rhythm_ch6(output, rshift, clipmax);
                else if (chnum == 7)
                    m_channel[chnum]->output_rhythm_ch7(phase_select, output, rshift, clipmax);
                else if (chnum == 8)
                    m_channel[chnum]->output_rhythm_ch8(phase_select, output, rshift, clipmax);
                else if (m_channel[chnum]->is4op())
                    m_channel[chnum]->output_4op(output, rshift, clipmax);
                else
                    m_channel[chnum]->output_2op(output, rshift, clipmax);
            }
    }
    else
    {
        // sum over all the desired channels
        for (uint32_t chnum = 0; chnum < CHANNELS; chnum++)
            if (bitfield(chanmask, chnum))
            {
                if (m_channel[chnum]->is4op())
                    m_channel[chnum]->output_4op(output, rshift, clipmax);
                else
                    m_channel[chnum]->output_2op(output, rshift, clipmax);
            }
    }
}

//-------------------------------------------------
//  write - handle writes to the OPN registers
//-------------------------------------------------

template<class RegisterType>
void fm_engine_base<RegisterType>::write(uint16_t regnum, uint8_t data)
{
    debug::log_fm_write("%03X = %02X\n", regnum, data);

    // special case: writes to the mode register can impact IRQs;
    // schedule these writes to ensure ordering with timers
    if (regnum == RegisterType::REG_MODE)
    {
        m_intf.ymfm_sync_mode_write(data);
        return;
    }

    // for now just mark all channels as modified
    m_modified_channels = ALL_CHANNELS;

    // most writes are passive, consumed only when needed
    uint32_t keyon_channel;
    uint32_t keyon_opmask;
    if (m_regs.write(regnum, data, keyon_channel, keyon_opmask))
    {
        // handle writes to the keyon register(s)
        if (keyon_channel < CHANNELS)
        {
            // normal channel on/off
            m_channel[keyon_channel]->keyonoff(keyon_opmask, KEYON_NORMAL, keyon_channel);
        }
        else if (CHANNELS >= 9 && keyon_channel == RegisterType::RHYTHM_CHANNEL)
        {
            // special case for the OPL rhythm channels
            m_channel[6]->keyonoff(bitfield(keyon_opmask, 4) ? 3 : 0, KEYON_RHYTHM, 6);
            m_channel[7]->keyonoff(bitfield(keyon_opmask, 0) | (bitfield(keyon_opmask, 3) << 1), KEYON_RHYTHM, 7);
            m_channel[8]->keyonoff(bitfield(keyon_opmask, 2) | (bitfield(keyon_opmask, 1) << 1), KEYON_RHYTHM, 8);
        }
    }
}

//-------------------------------------------------
//  status - return the current state of the
//  status flags
//-------------------------------------------------

template<class RegisterType>
uint8_t fm_engine_base<RegisterType>::status() const
{
    return m_status & ~STATUS_BUSY & ~m_regs.status_mask();
}

//-------------------------------------------------
//  assign_operators - get the current mapping of
//  operators to channels and assign them all
//-------------------------------------------------

template<class RegisterType>
void fm_engine_base<RegisterType>::assign_operators()
{
    typename RegisterType::operator_mapping map;
    m_regs.operator_map(map);

    for (uint32_t chnum = 0; chnum < CHANNELS; chnum++)
        for (uint32_t index = 0; index < 4; index++)
        {
            uint32_t opnum = bitfield(map.chan[chnum], 8 * index, 8);
            m_channel[chnum]->assign(index, (opnum == 0xff) ? nullptr : m_operator[opnum].get());
        }
}

//-------------------------------------------------
//  update_timer - update the state of the given
//  timer
//-------------------------------------------------

template<class RegisterType>
void fm_engine_base<RegisterType>::update_timer(uint32_t tnum, uint32_t enable)
{
    // if the timer is live, but not currently enabled, set the timer
    if (enable && !m_timer_running[tnum])
    {
        // period comes from the registers, and is different for each
        uint32_t period = (tnum == 0) ? (1024 - m_regs.timer_a_value()) : 16 * (256 - m_regs.timer_b_value());

        // reset it
        m_intf.ymfm_set_timer(tnum, period * OPERATORS * m_clock_prescale);
        m_timer_running[tnum] = 1;
    }

    // if the timer is not live, ensure it is not enabled
    else if (!enable)
    {
        m_intf.ymfm_set_timer(tnum, -1);
        m_timer_running[tnum] = 0;
    }
}

//-------------------------------------------------
//  engine_timer_expired - timer has expired - signal
//  status and possibly IRQs
//-------------------------------------------------

template<class RegisterType>
void fm_engine_base<RegisterType>::engine_timer_expired(uint32_t tnum)
{
    // update status
    if (tnum == 0 && m_regs.enable_timer_a())
        set_reset_status(STATUS_TIMERA, 0);
    else if (tnum == 1 && m_regs.enable_timer_b())
        set_reset_status(STATUS_TIMERB, 0);

    // if timer A fired in CSM mode, trigger CSM on all relevant channels
    if (tnum == 0 && m_regs.csm())
        for (uint32_t chnum = 0; chnum < CHANNELS; chnum++)
            if (bitfield(RegisterType::CSM_TRIGGER_MASK, chnum))
                m_channel[chnum]->keyonoff(1, KEYON_CSM, chnum);

    // reset
    m_timer_running[tnum] = false;
    update_timer(tnum, 1);
}

//-------------------------------------------------
//  check_interrupts - check the interrupt sources
//  for interrupts
//-------------------------------------------------

template<class RegisterType>
void fm_engine_base<RegisterType>::engine_check_interrupts()
{
    // update the state
    uint8_t old_state = m_irq_state;
    m_irq_state = ((m_status & m_irq_mask & ~m_regs.status_mask()) != 0);

    // set the IRQ status bit
    if (m_irq_state)
        m_status |= STATUS_IRQ;
    else
        m_status &= ~STATUS_IRQ;

    // if changed, signal the new state
    if (old_state != m_irq_state)
        m_intf.ymfm_update_irq(m_irq_state ? true : false);
}

//-------------------------------------------------
//  engine_mode_write - handle a mode register write
//  via timer callback
//-------------------------------------------------

template<class RegisterType>
void fm_engine_base<RegisterType>::engine_mode_write(uint8_t data)
{
    // mark all channels as modified
    m_modified_channels = ALL_CHANNELS;

    // actually write the mode register now
    uint32_t dummy1, dummy2;
    m_regs.write(RegisterType::REG_MODE, data, dummy1, dummy2);

    // reset IRQ status -- when written, all other bits are ignored
    // QUESTION: should this maybe just reset the IRQ bit and not all the bits?
    //   That is, check_interrupts would only set, this would only clear?
    if (m_regs.irq_reset())
        set_reset_status(0, 0x78);
    else
    {
        // reset timer status
        uint8_t reset_mask = 0;
        if (m_regs.reset_timer_b())
            reset_mask |= RegisterType::STATUS_TIMERB;
        if (m_regs.reset_timer_a())
            reset_mask |= RegisterType::STATUS_TIMERA;
        set_reset_status(0, reset_mask);

        // load timers
        update_timer(1, m_regs.load_timer_b());
        update_timer(0, m_regs.load_timer_a());
    }
}

...
// Many of the Yamaha FM chips emit a floating-point value, which is sent to
// a DAC for processing. The exact format of this floating-point value is
// documented below. This description only makes sense if the "internal"
// format treats sign as 1=positive and 0=negative, so the helpers below
// presume that.
//
// Internal OPx data      16-bit signed data     Exp Sign Mantissa
// =================      =================      === ==== ========
// 1 1xxxxxxxx------  ->  0 1xxxxxxxx------  ->  111   1  1xxxxxxx
// 1 01xxxxxxxx-----  ->  0 01xxxxxxxx-----  ->  110   1  1xxxxxxx
// 1 001xxxxxxxx----  ->  0 001xxxxxxxx----  ->  101   1  1xxxxxxx
// 1 0001xxxxxxxx---  ->  0 0001xxxxxxxx---  ->  100   1  1xxxxxxx
// 1 00001xxxxxxxx--  ->  0 00001xxxxxxxx--  ->  011   1  1xxxxxxx
// 1 000001xxxxxxxx-  ->  0 000001xxxxxxxx-  ->  010   1  1xxxxxxx
// 1 000000xxxxxxxxx  ->  0 000000xxxxxxxxx  ->  001   1  xxxxxxxx
// 0 111111xxxxxxxxx  ->  1 111111xxxxxxxxx  ->  001   0  xxxxxxxx
// 0 111110xxxxxxxx-  ->  1 111110xxxxxxxx-  ->  010   0  0xxxxxxx
// 0 11110xxxxxxxx--  ->  1 11110xxxxxxxx--  ->  011   0  0xxxxxxx
// 0 1110xxxxxxxx---  ->  1 1110xxxxxxxx---  ->  100   0  0xxxxxxx
// 0 110xxxxxxxx----  ->  1 110xxxxxxxx----  ->  101   0  0xxxxxxx
// 0 10xxxxxxxx-----  ->  1 10xxxxxxxx-----  ->  110   0  0xxxxxxx
// 0 0xxxxxxxx------  ->  1 0xxxxxxxx------  ->  111   0  0xxxxxxx

//*********************************************************
//  GLOBAL HELPERS
//*********************************************************

//-------------------------------------------------
//  bitfield - extract a bitfield from the given
//  value, starting at bit 'start' for a length of
//  'length' bits
//-------------------------------------------------

inline uint32_t bitfield(uint32_t value, int start, int length = 1)
{
    return (value >> start) & ((1 << length) - 1);
}

//-------------------------------------------------
//  clamp - clamp between the minimum and maximum
//  values provided
//-------------------------------------------------

inline int32_t clamp(int32_t value, int32_t minval, int32_t maxval)
{
    if (value < minval)
        return minval;
    if (value > maxval)
        return maxval;
    return value;
}

//-------------------------------------------------
//  array_size - return the size of an array
//-------------------------------------------------

template<typename ArrayType, int ArraySize>
constexpr uint32_t array_size(ArrayType (&array)[ArraySize])
{
    return ArraySize;
}

//-------------------------------------------------
//  count_leading_zeros - return the number of
//  leading zeros in a 32-bit value; CPU-optimized
//  versions for various architectures are included
//  below
//-------------------------------------------------

#if defined(__GNUC__)

inline uint8_t count_leading_zeros(uint32_t value)
{
    if (value == 0)
        return 32;
    return __builtin_clz(value);
}

#elif defined(_MSC_VER)

inline uint8_t count_leading_zeros(uint32_t value)
{
    unsigned long index;
    return _BitScanReverse(&index, value) ? uint8_t(31U - index) : 32U;
}

#else

inline uint8_t count_leading_zeros(uint32_t value)
{
    if (value == 0)
        return 32;
    uint8_t count;
    for (count = 0; int32_t(value) >= 0; count++)
        value <<= 1;
    return count;
}

#endif

// Many of the Yamaha FM chips emit a floating-point value, which is sent to
// a DAC for processing. The exact format of this floating-point value is
// documented below. This description only makes sense if the "internal"
// format treats sign as 1=positive and 0=negative, so the helpers below
// presume that.
//
// Internal OPx data      16-bit signed data     Exp Sign Mantissa
// =================      =================      === ==== ========
// 1 1xxxxxxxx------  ->  0 1xxxxxxxx------  ->  111   1  1xxxxxxx
// 1 01xxxxxxxx-----  ->  0 01xxxxxxxx-----  ->  110   1  1xxxxxxx
// 1 001xxxxxxxx----  ->  0 001xxxxxxxx----  ->  101   1  1xxxxxxx
// 1 0001xxxxxxxx---  ->  0 0001xxxxxxxx---  ->  100   1  1xxxxxxx
// 1 00001xxxxxxxx--  ->  0 00001xxxxxxxx--  ->  011   1  1xxxxxxx
// 1 000001xxxxxxxx-  ->  0 000001xxxxxxxx-  ->  010   1  1xxxxxxx
// 1 000000xxxxxxxxx  ->  0 000000xxxxxxxxx  ->  001   1  xxxxxxxx
// 0 111111xxxxxxxxx  ->  1 111111xxxxxxxxx  ->  001   0  xxxxxxxx
// 0 111110xxxxxxxx-  ->  1 111110xxxxxxxx-  ->  010   0  0xxxxxxx
// 0 11110xxxxxxxx--  ->  1 11110xxxxxxxx--  ->  011   0  0xxxxxxx
// 0 1110xxxxxxxx---  ->  1 1110xxxxxxxx---  ->  100   0  0xxxxxxx
// 0 110xxxxxxxx----  ->  1 110xxxxxxxx----  ->  101   0  0xxxxxxx
// 0 10xxxxxxxx-----  ->  1 10xxxxxxxx-----  ->  110   0  0xxxxxxx
// 0 0xxxxxxxx------  ->  1 0xxxxxxxx------  ->  111   0  0xxxxxxx

//-------------------------------------------------
//  encode_fp - given a 32-bit signed input value
//  convert it to a signed 3.10 floating-point
//  value
//-------------------------------------------------

inline int16_t encode_fp(int32_t value)
{
    // handle overflows first
    if (value < -32768)
        return (7 << 10) | 0x000;
    if (value > 32767)
        return (7 << 10) | 0x3ff;

    // we need to count the number of leading sign bits after the sign
    // we can use count_leading_zeros if we invert negative values
    int32_t scanvalue = value ^ (int32_t(value) >> 31);

    // exponent is related to the number of leading bits starting from bit 14
    int exponent = 7 - count_leading_zeros(scanvalue << 17);

    // smallest exponent value allowed is 1
    exponent = std::max(exponent, 1);

    // mantissa
    int32_t mantissa = value >> (exponent - 1);

    // assemble into final form, inverting the sign
    return ((exponent << 10) | (mantissa & 0x3ff)) ^ 0x200;
}

//-------------------------------------------------
//  decode_fp - given a 3.10 floating-point value,
//  convert it to a signed 16-bit value
//-------------------------------------------------

inline int16_t decode_fp(int16_t value)
{
    // invert the sign and the exponent
    value ^= 0x1e00;

    // shift mantissa up to 16 bits then apply inverted exponent
    return int16_t(value << 6) >> bitfield(value, 10, 3);
}

//-------------------------------------------------
//  roundtrip_fp - compute the result of a round
//  trip through the encode/decode process above
//-------------------------------------------------

inline int16_t roundtrip_fp(int32_t value)
{
    // handle overflows first
    if (value < -32768)
        return -32768;
    if (value > 32767)
        return 32767;

    // we need to count the number of leading sign bits after the sign
    // we can use count_leading_zeros if we invert negative values
    int32_t scanvalue = value ^ (int32_t(value) >> 31);

    // exponent is related to the number of leading bits starting from bit 14
    int exponent = 7 - count_leading_zeros(scanvalue << 17);

    // smallest exponent value allowed is 1
    exponent = std::max(exponent, 1);

    // apply the shift back and forth to zero out bits that are lost
    exponent -= 1;
    return (value >> exponent) << exponent;
}

//*********************************************************
//  HELPER CLASSES
//*********************************************************

// various envelope states
enum envelope_state : uint32_t
{
    EG_DEPRESS = 0,     // OPLL only; set EG_HAS_DEPRESS to enable
    EG_ATTACK = 1,
    EG_DECAY = 2,
    EG_SUSTAIN = 3,
    EG_RELEASE = 4,
    EG_REVERB = 5,      // OPQ/OPZ only; set EG_HAS_REVERB to enable
    EG_STATES = 6
};

// external I/O access classes
enum access_class : uint32_t
{
    ACCESS_IO = 0,
    ACCESS_ADPCM_A,
    ACCESS_ADPCM_B,
    ACCESS_PCM,
    ACCESS_CLASSES
};

//*********************************************************
//  HELPER CLASSES
//*********************************************************

// ======================> ymfm_output

// struct containing an array of output values
template<int NumOutputs>
struct ymfm_output
{
    // clear all outputs to 0
    ymfm_output &clear()
    {
        for (uint32_t index = 0; index < NumOutputs; index++)
            data[index] = 0;
        return *this;
    }

    // clamp all outputs to a 16-bit signed value
    ymfm_output &clamp16()
    {
        for (uint32_t index = 0; index < NumOutputs; index++)
            data[index] = clamp(data[index], -32768, 32767);
        return *this;
    }

    // run each output value through the floating-point processor
    ymfm_output &roundtrip_fp()
    {
        for (uint32_t index = 0; index < NumOutputs; index++)
            data[index] = ymfm::roundtrip_fp(data[index]);
        return *this;
    }

    // internal state
    int32_t data[NumOutputs];
};

// ======================> ymfm_saved_state

// this class contains a managed vector of bytes that is used to save and
// restore state
class ymfm_saved_state
{
public:
    // construction
    ymfm_saved_state(std::vector<uint8_t> &buffer, bool saving) :
        m_buffer(buffer),
        m_offset(saving ? -1 : 0)
    {
        if (saving)
            buffer.resize(0);
    }

    // are we saving or restoring?
    bool saving() const { return (m_offset < 0); }

    // generic save/restore
    template<typename DataType>
    void save_restore(DataType &data)
    {
        if (saving())
            save(data);
        else
            restore(data);
    }

public:
    // save data to the buffer
    void save(bool &data) { write(data ? 1 : 0); }
    void save(int8_t &data) { write(data); }
    void save(uint8_t &data) { write(data); }
    void save(int16_t &data) { write(uint8_t(data)).write(data >> 8); }
    void save(uint16_t &data) { write(uint8_t(data)).write(data >> 8); }
    void save(int32_t &data) { write(data).write(data >> 8).write(data >> 16).write(data >> 24); }
    void save(uint32_t &data) { write(data).write(data >> 8).write(data >> 16).write(data >> 24); }
    void save(envelope_state &data) { write(uint8_t(data)); }
    template<typename DataType, int Count>
    void save(DataType (&data)[Count]) { for (uint32_t index = 0; index < Count; index++) save(data[index]); }

    // restore data from the buffer
    void restore(bool &data) { data = read() ? true : false; }
    void restore(int8_t &data) { data = read(); }
    void restore(uint8_t &data) { data = read(); }
    void restore(int16_t &data) { data = read(); data |= read() << 8; }
    void restore(uint16_t &data) { data = read(); data |= read() << 8; }
    void restore(int32_t &data) { data = read(); data |= read() << 8; data |= read() << 16; data |= read() << 24; }
    void restore(uint32_t &data) { data = read(); data |= read() << 8; data |= read() << 16; data |= read() << 24; }
    void restore(envelope_state &data) { data = envelope_state(read()); }
    template<typename DataType, int Count>
    void restore(DataType (&data)[Count]) { for (uint32_t index = 0; index < Count; index++) restore(data[index]); }

    // internal helper
    ymfm_saved_state &write(uint8_t data) { m_buffer.push_back(data); return *this; }
    uint8_t read() { return (m_offset < int32_t(m_buffer.size())) ? m_buffer[m_offset++] : 0; }

    // internal state
    std::vector<uint8_t> &m_buffer;
    int32_t m_offset;
};

//*********************************************************
//  INTERFACE CLASSES
//*********************************************************

// ======================> ymfm_engine_callbacks

// this class represents functions in the engine that the ymfm_interface
// needs to be able to call; it is represented here as a separate interface
// that is independent of the actual engine implementation
class ymfm_engine_callbacks
{
public:
    // timer callback; called by the interface when a timer fires
    virtual void engine_timer_expired(uint32_t tnum) = 0;

    // check interrupts; called by the interface after synchronization
    virtual void engine_check_interrupts() = 0;

    // mode register write; called by the interface after synchronization
    virtual void engine_mode_write(uint8_t data) = 0;
};

// ======================> ymfm_interface

// this class represents the interface between the fm_engine and the outside
// world; it provides hooks for timers, synchronization, and I/O
class ymfm_interface
{
    // the engine is our friend
    template<typename RegisterType> friend class fm_engine_base;

public:
    // the following functions must be implemented by any derived classes; the
    // default implementations are sufficient for some minimal operation, but will
    // likely need to be overridden to integrate with the outside world; they are
    // all prefixed with ymfm_ to reduce the likelihood of namespace collisions

    //
    // timing and synchronizaton
    //

    // the chip implementation calls this when a write happens to the mode
    // register, which could affect timers and interrupts; our responsibility
    // is to ensure the system is up to date before calling the engine's
    // engine_mode_write() method
    virtual void ymfm_sync_mode_write(uint8_t data) { m_engine->engine_mode_write(data); }

    // the chip implementation calls this when the chip's status has changed,
    // which may affect the interrupt state; our responsibility is to ensure
    // the system is up to date before calling the engine's
    // engine_check_interrupts() method
    virtual void ymfm_sync_check_interrupts() { m_engine->engine_check_interrupts(); }

    // the chip implementation calls this when one of the two internal timers
    // has changed state; our responsibility is to arrange to call the engine's
    // engine_timer_expired() method after the provided number of clocks; if
    // duration_in_clocks is negative, we should cancel any outstanding timers
    virtual void ymfm_set_timer(uint32_t tnum, int32_t duration_in_clocks) { }

    // the chip implementation calls this to indicate that the chip should be
    // considered in a busy state until the given number of clocks has passed;
    // our responsibility is to compute and remember the ending time based on
    // the chip's clock for later checking
    virtual void ymfm_set_busy_end(uint32_t clocks) { }

    // the chip implementation calls this to see if the chip is still currently
    // is a busy state, as specified by a previous call to ymfm_set_busy_end();
    // our responsibility is to compare the current time against the previously
    // noted busy end time and return true if we haven't yet passed it
    virtual bool ymfm_is_busy() { return false; }

    //
    // I/O functions
    //

    // the chip implementation calls this when the state of the IRQ signal has
    // changed due to a status change; our responsibility is to respond as
    // needed to the change in IRQ state, signaling any consumers
    virtual void ymfm_update_irq(bool asserted) { }

    // the chip implementation calls this whenever data is read from outside
    // of the chip; our responsibility is to provide the data requested
    virtual uint8_t ymfm_external_read(access_class type, uint32_t address) { return 0; }

    // the chip implementation calls this whenever data is written outside
    // of the chip; our responsibility is to pass the written data on to any consumers
    virtual void ymfm_external_write(access_class type, uint32_t address, uint8_t data) { }

protected:
    // pointer to engine callbacks -- this is set directly by the engine at
    // construction time
    ymfm_engine_callbacks *m_engine;
};

}

## Attenuation

Most of the computations of the FM engines are done in terms of attenuation, and thus are logarithmic in nature.
The maximum resolution used internally is 12 bits, as returned by the sin table:

Bit | 11 | 10 |  9 |  8 |  7 |  6 |   5 |    4 |     3 |      2 |       1 |        0
----|----|----|----|----|----|----|-----|------|-------|--------|---------|---------
 dB | -96| -48| -24| -12|  -6|  -3| -1.5| -0.75| -0.375| -0.1875| -0.09375| -0.046875

The envelope generator internally uses 10 bits:

Bit |  9 |  8 |  7 |  6 |  5 |   4 |    3 |     2 |      1 |       0 |
----|----|----|----|----|----|-----|------|-------|--------|---------|
 dB | -48| -24| -12|  -6|  -3| -1.5| -0.75| -0.375| -0.1875| -0.09375|

Total level for operators is usually represented by 7 bits:

Bit |  6 |  5 |  4 |  3 |  2 |   1 |    0 |
----|----|----|----|----|----|-----|------|
 dB | -48| -24| -12|  -6|  -3| -1.5| -0.75|

Sustain level in the envelope generator is usually represented by 4 bits:

Bit |  3 |  2 |  1 |  0 |
----|----|----|----|----|
 dB | -24| -12|  -6|  -3|

## Status and Timers

Generically, all chips (except OPLL) support two timers that can be programmed to fire and signal IRQs.
These timers also set bits in the status register.
The behavior of these bits is shared across all implementations, even if the exact bit positions shift (this is controlled by constants in the registers class).

In addition, several chips incorporate ADPCM decoders which also may set bits in the same status register.
For this reason, it is possible to control various bits in the status register via the `set_reset_status()` function directly.
Any active bits that are set and which are not masked (mask is controlled by `set_irq_mask()`), lead to an IRQ being signalled.

Thus, it is possible for the chip-specific implementations to set the mask and control the status register bits such that IRQs are signalled via the same mechanism as timer signals.

In addition, the OPM and OPN families have a "busy" flag, which is set after each write, indicating that another write should not be performed.
Historically, the duration of this flag was constant and had nothing to do with the internals of the chip.
However, since the details can potentially vary chip-to-chip, it is the chip's responsibility to insert the busy flag into the status before returning it to the caller.

## Clocking

Each of the Yamaha chips works by cycling through all operators one at a time.
Thus, the effective output rate of the chips is related to the input clock divided by the number of operators.
In addition, the input clock is prescaled by an amount.
Generally, this is a fixed value, though some early OPN chips allow this to be selected at runtime from a small
number of values.

## Channel Frequencies

One major difference between OPM and later families is in how frequencies are specified.
OPM specifies frequency via a 3-bit 'block' (aka octave), combined with a 4-bit 'key code' (note number) and a 6-bit 'key fraction'.
The key code and fraction are converted on the chip into an x.11 fixed-point value and then shifted by the block to produce the final step value for the phase.

Later families, on the other hand, specify frequencies via a 3-bit 'block' just as on OPM, but combined with a 9-12-bit 'frequency number' or 'fnum', which is directly shifted by the block to produce the step value.
So essentially, later chips make the user do the conversion from note value to phase increment, while OPM is programmed in a more 'musical' way, specifying notes and cents.

Internally, this is abstracted away into a 'block_freq' value, which is a 16-bit value containing the block and frequency info concatenated together as follows:

* OPM:  `[3-bit block]:[4-bit keycode]:[6-bit fraction] = 13 bits total`

* OPZ:  `[3-bit block]:[12-bit fnum]     = 15 bits total`
* OPN:  `[3-bit block]:[11-bit fnum] 0   = 15 bits total`
* OPL:  `[3-bit block]:[10-bit fnum]:00  = 15 bits total`
* OPLL: `[3-bit block]:[ 9-bit fnum]:000 = 15 bits total`

The register classes handle the raw format directly and convert it into a phase increment which can be used by the generic engine.

## Low Frequency Oscillator (LFO)

The LFO engines are different in several key ways.
The OPM LFO engine is fairly intricate.
It has a 4.4 floating-point rate which allows for a huge range of frequencies, and can select between four different waveforms (sawtooth, square, triangle, or noise).
Separate 7-bit depth controls for AM and PM control the amount of modulation applied in each case.
This global LFO value is then further controlled at the channel level by a 2-bit AM sensitivity and a 3-bit PM sensitivity, and each operator has a 1-bit AM on/off switch.

For OPN the LFO engine was removed entirely, but a limited version was put back in OPNA and later chips.
This stripped-down version offered only a 3-bit rate setting (versus the 4.4 floating-point rate in OPN), and no
global depth control.
It did bring back the channel-level sensitivity controls and the operator-level on/off control.

For OPL, the LFO is simplified again, with AM and PM running at fixed frequencies, and simple enable flags at the operator level for each controlling their application.

The table below provides some high level functional differences between the differnet families:

subfamily:   |   OPM  |   OPN  |  OPNA  |   OPL  |  OPL2  |  OPLL  |  OPL3  |
------------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
outputs:     |    2   |    1   |    2   |    1   |    1   |    1   |    4   |
channels:    |    8   |    3   |    6   |    9   |    9   |    9   |   18   |
operators:   |   32   |   12   |   24   |   18   |   18   |   18   |   36   |
waveforms:   |    1   |    1   |    1   |    1   |    4   |    2   |    8   |
instruments: |   no   |   no   |   no   |   yes  |   yes  |   yes  |   yes  |
ryhthm:      |   no   |   no   |   no   |   no   |   no   |   yes  |   no   |
dynamic ops: |   no   |   no   |   no   |   no   |   no   |   no   |   yes  |
prescale:    |    2   |  2/3/6 |  2/3/6 |    4   |    4   |    4   |    8   |
EG divider:  |    3   |    3   |    3   |    1   |    1   |    1   |    1   |
EG DP:       |   no   |   no   |   no   |   no   |   no   |   yes  |   no   |
EG SSG:      |   no   |   yes  |   yes  |   no   |   no   |   no   |   no   |
mod delay:   |   no   |   no   |   no   |   yes  |   yes  |   yes? |   no   |
CSM:         |   yes  |  ch 2  |  ch 2  |   yes  |   yes  |   yes  |   no   |
LFO:         |   yes  |   no   |   yes  |   yes  |   yes  |   yes  |   yes  |
noise:       |   yes  |   no   |   no   |   no   |   no   |   no   |   no   |

* Outputs represents the number of output channels: 1=mono, 2=stereo, 4=stereo+.
* Channels represents the number of independent FM channels.
* Operators represents the number of operators, or "slots" which are assembled into the channels.
* Waveforms represents the number of different sine-derived waveforms available.
* Instruments indicates whether the family has built-in instruments.
* Rhythm indicates whether the family has a built-in rhythm
* Dynamic ops indicates whether it is possible to switch between 2-operator and 4-operator modes dynamically.
* Prescale specifies the default clock divider; some chips allow this to be controlled via register writes.
* EG divider represents the divider applied to the envelope generator clock.
* EG DP indicates whether the envelope generator includes a DP (depress?) phase at the beginning of each key on.
* SSG EG indicates whether the envelope generator has SSG-style support.
* Mod delay indicates whether the connection to the first modulator's input is delayed by 1 sample.
* CSM indicates whether CSM mode is supported, triggered by timer A.
* LFO indicates whether LFO is supported.
* Noise indicates whether one of the operators can be replaced with a noise source.

chip ID:  | YM2203 | YM2608 | YMF288 | YM2610 | YM2610B | YM2612 | YM3438 | YMF276 |
---------:|:------:|:------:|:------:|:------:|:-------:|:------:|:------:|:------:|
aka:      |   OPN  |  OPNA  |  OPN3L |  OPNB  |  OPNB2  |  OPN2  |  OPN2C |  OPN2L |
FM:       |    3   |    6   |    6   |    4   |    6    |    6   |    6   |    6   |
AY-8910:  |    3   |    1   |    1   |    1   |    1    |    -   |    -   |    -   |
ADPCM-A:  |    -   |  6 int |  6 int |  6 ext |  6 ext  |    -   |    -   |    -   |
ADPCM-B:  |    -   |  1 ext |    -   |  1 ext |  1 ext  |    -   |    -   |    -   |
DAC:      |   no   |   no   |   no   |   no   |   no    |   yes  |   yes  |   yes  |
output:   | 10.3fp | 16-bit | 16-bit | 16-bit |  16-bit |  9-bit |  9-bit | 16-bit |
summing:  |  adder |  adder |  adder |  adder |  adder  |  muxer |  muxer |  adder |

* FM represents the number of FM channels available.
* AY-8910 represents the number of AY-8910-compatible outputs.
* ADPCM-A represents the number of internal/external ADPCM-A channels present.
* ADPCM-B represents the number of internal/external ADPCM-B channels present.
* DAC indicates if a directly-accessible DAC output exists, replacing one channel.
* Output indicates the output format to the final DAC.
* Summing indicates whether channels are added or time divided in the output.


//*********************************************************
//  YM2203 DEVICE
//*********************************************************

DEFINE_DEVICE_TYPE(YM2203, ym2203_device, "ym2203", "YM2203 OPN")

//-------------------------------------------------
//  ym2203_device - constructor
//-------------------------------------------------

ym2203_device::ym2203_device(const machine_config &mconfig, const char *tag, device_t *owner, uint32_t clock) :
    ymfm_ssg_device_base<ymfm::ym2203>(mconfig, tag, owner, clock, YM2203)
{
}

//-------------------------------------------------
//  device_start - start of emulation
//-------------------------------------------------

void ym2203_device::device_start()
{
    // set our target output fidelity
    m_chip.set_fidelity(SSG_FIDELITY);

    // call our parent
    parent::device_start();
}

ymopn.h
    map(0xe000, 0xe001).rw("ym1", FUNC(ym2203_device::read), FUNC(ym2203_device::write));
    map(0xe002, 0xe003).rw("ym2", FUNC(ym2203_device::read), FUNC(ym2203_device::write));

*****************************************************************************************
* PMD/MMF NOTES:                                                                        *
*****************************************************************************************

General Instruments datasheet for the AY-3-8910A

I didn't get the lpt working, but I did manage to get it working with the avr, thank you for the offer of the fax though,
Cliff (the first computer I owned was a cpc464 btw, go Amstrad!) Turns out I wasn't sending an inactive signal to the Bus
Direction/Control lines after sending a bus control signal.

In case anyone else tries this:

Remember that registers R0-R17 are in octal form in some data sheets, so R10 = 0x08, R11 = 0x09, R12 = 0x0A etc
(the YM2149 datasheet uses hex numbering) Assuming that PORTD0-7 outputs to the PSG data ports DA0-DA7.
PORTC0 = BDIR and PORTC1 = BC1 (BC2 is tied to 5+v) Remember to toggle the reset line when appropriate, otherwise you
will get unpredictable sounds.

A send function:

void send_ay(int reg, int data){
PORTC = 0x00; //send 'inactive', logical 0 to BDIR/BC1
PORTD = reg; //put register number on data port
PORTC = 0x03; //send 1 to BDIR/BC1 to latch register address
PORTC = 0x00; //inactive
PORTD = data; //data to send to previously selected register
PORTC = 0x01; //send 1 to BDIR, 0 to BC1 to latch data to register
}

Test sound:

Output tone on all channels -

send_ay(0x00,0xFE);//Set Channel A Tone Period
send_ay(0x01,0x00);

send_ay(0x02,0xFE);//Set Channel B Tone Period
send_ay(0x03,0x00);

send_ay(0x04,0xFE);//Set Channel C Tone Period
send_ay(0x05,0x00);

send_ay(0x07,0xF8); //Output on channels ABC
send_ay(0x08,0x0F);//Channel A Amplitude
send_ay(0x09,0x0F);//Channel B Amplitude
send_ay(0x0A,0x0F);//Channel C Amplitude

*****************************************************************************************
* LINKS:                                                                                *
*****************************************************************************************

https://delmunsoft.com/PMD%20Programming.html
https://github.com/gzaffin/pmdmini
https://battleofthebits.org/lyceum/View/Professional+Music+Driver+%28PMD%29/

https://github.com/mamedev/mame/blob/master/src/devices/sound/ymopn.h
https://github.com/mamedev/mame/blob/master/3rdparty/ymfm/src/ymfm.h
https://github.com/mamedev/mame/blob/master/3rdparty/ymfm/src/ymfm_fm.h
https://github.com/mamedev/mame/blob/master/3rdparty/ymfm/src/ymfm_opn.h
https://github.com/mamedev/mame/blob/master/3rdparty/ymfm/src/ymfm_adpcm.h
https://github.com/mamedev/mame/blob/master/src/devices/sound/ymfm_mame.h
https://github.com/mamedev/mame/blob/master/3rdparty/ymfm/src/ymfm_ssg.h
https://github.com/mamedev/mame/blob/master/3rdparty/ymfm/src/ymfm_ssg.cpp

===============================================================================

    MusicCompiler "MC.EXE" ver.4.8 Document for PMD
                        by M.Kajihara(KAJA)

===============================================================================

>MC [/Option[/Option]...] MML file name [.MML] FM voice file name [.FF] extension can be omitted

    When used as, a .M file will be created from the .MML unless there is an error.
    If there is an error, the program will display the error location and error message at that point and exit.
    M file.

    Most of the uploaded MML data is stored in
>MC /V/P filename[.MML].
    Most of the uploaded MML data can be compiled and played by using >MC /V/P filename[.MML].

    See PMDMML.MAN for MML specifications.

(Note) If you use this compiler after PMD is resident, the size of the PMD voice data buffer will be
    (Note: When using this compiler after PMD is resident, keep the default size of the PMD voice data buffer at 8KB. (->PMD's /V option)

===============================================================================
    About options
-------------------------------------------------------------------------------
    If the environment variable "MCOPT=" is defined, the string will be automatically
    option.

    If there is a conflict with an option on the command line that cannot be used at the same time
    If there is a conflict with an option that cannot be used on the command line at the same time, the option on the command line will take precedence.

    The available options are as follows

-------------------------------------------------------------------------------
/V
-------------------------------------------------------------------------------
    Attach the FM tone data used in the song to the compiled song data.
    The FM tone data used in the song is attached to the compiled song data. If the FM voice data file name is specified after the MML file
    If the FM voice data file name is specified after the MML file name, and if it exists, this option is automatically
    If the FM voice data file name is specified after the MML file name and it exists, this option is automatically specified.

-------------------------------------------------------------------------------
/VW
-------------------------------------------------------------------------------
    Use this option to create or modify a .FF file from a .MML file.

    FF from .MML. It is effective only when the FM tone data file name is specified.

1) When the FM voice data file does not exist
    1) If no FM voice data file exists, a new FM voice data file is created after compilation.
    In this case, the data is created by adding the FM voice data defined in MML to the voice data buffer in PMD.
    In this case, the data created is an updated version of the FM voice data defined in MML.

2) When an FM voice data file exists
    After compilation, the FM voice data file is rewritten.
    The data to be written will overwrite the specified tone file in the tone data buffer in the PMD.
    overwrites the specified tone file in the tone data buffer in PMD, and updates the FM tone data specified in MML.
    The data to be written overwrites the specified tone file in the PMD's tone data buffer and updates the FM tone data specified in the MML.

-------------------------------------------------------------------------------
/N
-------------------------------------------------------------------------------
    Compile with OPN specification (no DT2/ABCDEF=FM,GHI=SSG).
    This is the default, so you don't need to specify it.

-------------------------------------------------------------------------------
/L
-------------------------------------------------------------------------------
    Compile with OPL specification (2op tones/ABCDEFGHI=FM).
    Use this only when creating songs for PMD on IBMPC.

-------------------------------------------------------------------------------
/M
-------------------------------------------------------------------------------
    Compile with OPM specification (with DT2/ABCDEFGH=FM).
    Used only when creating songs for PMD on X68000.

-------------------------------------------------------------------------------
/T
-------------------------------------------------------------------------------
    Compile with TOWNS specification (no DT2/ABCDEF=FM, JK=PCM).
    Use only when creating songs for FM-TOWNS PMD.

-------------------------------------------------------------------------------
/P
-------------------------------------------------------------------------------
    Plays immediately after compiling; invalid if PMD is not resident.

-------------------------------------------------------------------------------
/S
-------------------------------------------------------------------------------
    Play immediately after compiling without saving the data.

    If you want to play .MML without creating .M, or if you are creating a floppy-based song, you can use this function to reduce compilation time.
    MML without creating .M, or to shorten the compilation time when creating a floppy-based song.

    MML without creating .
    There is no point in specifying it.

-------------------------------------------------------------------------------
/A
-------------------------------------------------------------------------------
    Do not load PCM data.
    When PMDB2/PMDVA/PMD86 is resident, PCM data specified by #PCMFile etc. in MML is loaded when playing a song.
    This option suppresses this.

    This option is meaningless unless the performance option (/P,/S) is specified.

-------------------------------------------------------------------------------
/O
-------------------------------------------------------------------------------
    Suppresses the display of the Title string.
    As soon as the performance starts, the PCM file name, song title, composer/arranger name, and notes will be displayed.
    If they are defined in MML, they will be displayed.

    This option suppresses them. It is useless unless the performance option (/P,/S) is specified.

-------------------------------------------------------------------------------
/C
-------------------------------------------------------------------------------
    Displays the length of each part after compiling. ( Whole / After specifying L )
    This is useful for CHECKing if there is a gap in the loop.

    However, if there is a local infinite loop such as [ ... ] 0, the length will not be displayed.
    However, if there is a local infinite loop such as [ ... ] 0, the length will not be displayed.

-------------------------------------------------------------------------------

Note! Note! The maximum compileable size of MML data and #include files specified in MML is 61KB.
    MML data and #include files specified in MML is 61KB (62,464bytes).
    If the total size of MML files larger than this, or files specified in #include
    The maximum size of the compiled data is 61KB (62,464bytes).
    Also, the maximum size of the compiled data is 63KB (64,512bytes).

===============================================================================
    How to handle FM sound data (hereinafter referred to as "sound")
-------------------------------------------------------------------------------

    The handling of voices in MC.EXE is complicated in many ways. At first, you need to

1) Define all voices to be used in the song in MML.
2) Always specify the /V option.

    As long as you keep these two points in mind, you shouldn't be too confused.
    When you get used to it, please read the following explanations and try to use it more.

-------------------------------------------------------------------------------

    Most other music drivers define all their tones in MML.
    In the case of MC.EXE, however, the following types of tone sources are available.

-------------------------------------------------------------------------------
1) Tones defined in MML.
-------------------------------------------------------------------------------
    1) Voices defined in MML, which are automatically used by specifying the /V option.

It is a tone that is normally defined in MML. Even if this is all you need
    There is no problem.

ex.
>mc /v sample1.mml
Condition/ All the voices used in the song are defined in sample1.mml.
Result/ All the tones are defined in MML, and
    A song data with tone data is created.

-------------------------------------------------------------------------------
2) A file with the extension .FF, created by the supplied voice editor "VED.EXE".
------------------------------------------------------------------------------- 1.
1. voice file name is specified in the command line. 2.
2. the voice used is not defined in MML.
    If the following two conditions are met, the file will be used.

    For example, if you create a song using only 88 preset tones, you can use the included "PC88.
    If you want to create a song with only 88 preset sounds, you only need to add the voice file name "PC88.FF" to the command line at compile time.
    For example, if you want to create a song with only 88 preset tones, you can simply add the attached "PC88.FF" voice file name to the command line at compile time.

ex.1
>mc sample2 effec
Condition1/ None of the voices are defined in sample2.mml.
Condition 2: effec.ff has a maximum of 256 voices defined in it.
Result: All the voices are used from effec.ff.
    A song data with tone data is created.

ex.2
>mc sample3 effec
Condition 1: Only some of the voices are defined in sample3.mml.
Condition 2: effec.ff has the maximum of 256 voices defined in it.
Result: Undefined voices are used from within effec.ff, and
    The undefined voices are used from within effec.ff, and song data with tone data is created.

-------------------------------------------------------------------------------
3) Tones in the PMD internal tone data area.
------------------------------------------------------------------------------- 1.
1. the /V option or a tone file name is specified on the command line. 2.
The voice used is not defined in MML. 3.
If a tone file name is specified, it is not defined in the tone file either.
    (For example, if a voice file with voice data up to @128 is specified, and @200 is used in the MML, and
     200 is used in the MML and the voice is not defined in the MML). 4.
4) PMD is resident.
    PMD is automatically used when the following four conditions are met.
    If only condition 4 is not met, the PMD voice data area is assumed to be 00H.
    If only 4. is not met, it is assumed that all the tone data areas in the PMD are 00H.

    FF format voices created by VED.EXE can be transferred to the PMD using VSET.COM.
    FF format created by VED.EXE can be transferred to PMD by VSET.
    FF to PMD by VSET, it is not necessary to specify PC88.FF in the command line when compiling.
    FF to the command line during compilation.

ex.1
>mc /v sample4
Condition 1: There are no voices defined in sample4.mml.
Condition 2: PMD is resident.
Result: A song data with tone data is generated by using a tone in the PMD tone data area.
    A song data with tone data is created using the tones in the PMD tone data area.

ex.2
>mc sample5 pc88
Condition 1: There is no tone defined in sample5.mml.
Condition 2/ In sample5.mml, all the voices from @0 to @255 are used evenly.
Condition 3/ Data from @0 to @126 is defined in pc88.ff.
Condition 4: PMD is resident.
FF up to @126, and PMD voice data area from @127.
    FF up to @126, and PMD tone data area from @127 onwards.

ex.3 (Failure example)
>mc /v sample6
Condition 1: Only some voices are defined in sample6.mml.
Condition 2: PMD is not resident.
Result: The rest of the tones not defined in MML are not pronounced.
    A song data with tone data is created.

-------------------------------------------------------------------------------
4) Do not include any tones in the song data.
-------------------------------------------------------------------------------
    If neither the /V option nor the tone file name is specified on the command line, the following error message is displayed
    If neither the /V option nor the voice file name is specified in the command line, the voice is not defined in the song data even if it is defined in the MML.

    In this case, the voice in the PMD's internal voice buffer will be used when playing.
    In a sense, this is a special case.

    In a sense, this is special and hardly used, but the song data created in this way can be used for multiple voices of the same song data.
The same song data can be played with multiple tone sets.
    It is possible to do the following

ex.1
>mc sample7
Condition/ All the voices are defined in sample7.mml.
Result: All defined voices are ignored and a song data without voice data is created.

ex.2
>mc /vw sample8 test
Condition1/ All the voices are defined in sample8.mml.
Condition 2: test.ff does not exist.
Result: "test.ff" is created by adding the voices in sample8.mml to the voice data in PMD.
    The song data without tone data is created.

===============================================================================
    About the PMD environment variable
-------------------------------------------------------------------------------
    Compile-time MML file, tone file, #Include file, and
    PCM files at the time of performance (/P,/S option), if they are not found in the current
    If they are not found in the current directory, they will be searched for in the environment variable specified by SET PMD=.
    The format is exactly the same as SET PATH=.

    Also, in the current version, even if the path name is written in the file, if it is not found
    In the current version, even if the path name is written in the file, if it is not found, the specified path will be deleted and SET PMD= will search for the specified path.
    If the path is not found, it will be deleted and SET PMD= will search for the specified path.

    As with the PATH environment variable, it is better to write the path you use most often first, especially if you are using a DISK-based system.
    As with the PATH environment variable, especially for DISK-based use, it is better to write the most frequently used paths first to speed up the search.
    Please think carefully about the order in which you set them.

===============================================================================
    About the environment variables USER, COMPOSER, and ARRANGER
-------------------------------------------------------------------------------
    If #Composer and #Arranger are not specified in the MML, the following environment variables are used

    In the case of #Composer, the
    In the case of #Composer, look for the environment variables "COMPOSER=" and "USER=".

    In the case of #Arranger, search for the environment variables "ARRANGER=" and "USER=".

    and if found, use the string defined there.
    In case of duplication, the environment variables "COMPOSER" and "ARRANGER" will take precedence.

===============================================================================
--------Exsamples
-------------------------------------------------------------------------------

>mc /v/p sam1
    Compile and play sam1.mml.
    Attach the tone data in the song data.

>mc /o/p sam2
    Compile and play sam2.mml. In this case, the title string is not displayed.
    The tone data is not attached to the song data, but is played using the PMD internal tone data.
    The tone data is not attached to the song data.

>mc /a/p sam4
    Compile and play sam4.mml. In this case, ADPCM data is not defined.
    The tone data is not attached to the song data, but is played using the PMD internal tone data.
    The tone data is not attached to the song data.

>mc /v/vw/p sam3 effec
    Compile and play sam3.mml.
    Update the FM tone data defined in MML in effec.ff.
    Attach the tone data in the song data.

===============================================================================
            ----- End of MC.DOC -----
===============================================================================

...............

===============================================================================

Professinal Music Driver [P.M.D.] version4.8 MML Command Manual*.

                    Apr.4th 1997 by M.Kajihara (KAJA)

===============================================================================
*******************************************************************************
1 [[[[ Basic information ]]]]
*******************************************************************************
===============================================================================

    This section describes the basics of MML notation.

===============================================================================
1-1 Part notation
-------------------------------------------------------------------------------
1-1-1 Part notation methods
-------------------------------------------------------------------------------
    At the beginning of a line, specify the letter of the alphabet that is assigned to each part.
    The MML is compiled in order from the beginning.

    MMLs are compiled and played in order from the beginning.

    The part symbol and MML must be separated by SPACE or TAB.

[Example]
A @1v13cdefg
    The MML will be played in part A. [Result] The MML will be played in part B.

[Failure Example 1] A @1v13cdefg
 A @1v13cdefg
    [Cause] Part symbol is not at the beginning of a line.
    [Result: This MML will not be recognized and will be treated as a comment.

[Failure Example 2]
A@1v13cdefg
    [Cause] There is no SPACE or TAB between the part symbol and the MML.
    [Result: The MML is treated as a multi-part notation (->1-1-2).

-------------------------------------------------------------------------------
1-1-2 Multiple part notation
-------------------------------------------------------------------------------
    You can specify multiple part symbols.

    If you want to specify more than one part, do not leave any space between them.
    When specifying multiple part symbols, do not leave any space between them.

    If you specify a part symbol that does not exist, it will not cause an error and will be skipped.

    This can also be used to make MML easier to read by placing numbers immediately after part symbols.
    This can be used to make the MML easier to read. This is especially useful for rhythm parts (->1-2).

[Example 1]
AC @1v13cdefg
    This MML will be played in parts A and C. [Result

[Example 2]
AC1 @1v13cdefg
    [Result] This MML will be played in parts A and C.
        The "1" is ignored.

[Failure example]
A C @1v13cdefg
    [Cause] The part symbols are far apart.
    [Result] "C" is recognized as an MML command.

[Related] A C @1v13cdefg
    | command (->16-3)

-------------------------------------------------------------------------------
1-1-3 Correspondence between part symbols and sound sources
-------------------------------------------------------------------------------
    The assignment of part symbols to sound sources differs depending on the driver (sound source).

    The table below shows how the part symbols and sound sources are assigned to each driver (sound source), and the parts marked "optional" can be set by the user.
    (->2-18,->) (->2-18,->2-25) 1.

PMD.COM / PMDVA1.COM (98,88VA1 normal sound source)
    A FM sound source 1
    B FM sound source 2
    C FM sound source 3
    Dor optional FM sound source 3
    For optional FM sound source 3
    For any FM sound source 3
    G SSG 1
    H SSG 2
    I SSG sound source 3
    K Rhythm pattern specification
    R Rhythm pattern definition
[Related]
    #FM3Extend command (->2-18) 2.

PMDB2.COM / PMD86.COM / PMDVA.COM (SpeakBoard, OtoBei, 86, VA2)
    A FM sound source 1
    B FM sound source 2
    C FM sound source 3
    D FM sound source 4
    E FM sound source 5
    F FM sound source 6
    G SSG 1
    H SSG 2
    I SSG 3
    J PCM sound source
    K Rhythm pattern specification
    R Rhythm pattern definition
    Optional 1 FM sound source 3
    Optional 2 FM sound source 3
    Optional 3 FM sound source 3
[Related]
    #FM3Extend command (->2-18) 3.

3. PMD.X (X68000)
    A FM source 1
    B FM source 2
    C FM source 3
    D FM sound source 4
    E FM sound source 5
    F FM sound source 6
    G FM sound source 7
    H FM sound source 8
    J PCM sound source
[Related]
    MC.EXE /m option (-> MC.DOC) 4.

4. for PMD.EXP (FM-TOWNS)
    A FM sound source 1
    B FM sound source 2
    C FM sound source 3
    D FM sound source 4
    E FM sound source 5
    F FM sound source 6
    J PCM source 1
    K PCM sound source 2
[Related]
    MC.EXE /t option (-> MC.DOC) 5.

5. for PMDIBM.COM (IBMPC)
    A FM sound source 1
    B FM sound source 2
    C FM sound source 3
    D FM source 4
    E FM source 5
    F FM sound source 6
    G FM sound source 7
    H FM sound source 8
    I FM sound source 9
[Related]
    MC.EXE /l option (-> MC.DOC)

6. for PMDPPZ.COM (86)
    A FM source 1
    B FM Source 2
    C FM source 3
    D FM source 4
    E FM source 5
    F FM sound source 6
    G SSG 1
    H SSG 2
    I SSG sound source 3
    J PCM sound source (played only when Chibi-oto is installed)
    K Rhythm pattern specification
    R Rhythm pattern definition
    Optional 1 FM sound source 3
    Optional 2 FM sound source 3
    Optional 3 FM sound source 3
    Optional 4 PCM sound source 1 for PPZ8
    Optional 5 PCM sound source 2 for PPZ8
    6 optional PCM sound source 3 for PPZ8
    7 optional PCM sound source 4 for PPZ8
    8 optional PCM sound source 5 for PPZ8
    9 optional PCM sound source 6 for PPZ8
    10 optional PCM sound source 7 for PPZ8
    11 optional PCM sound source 8 for PPZ8

[Related]
    #FM3Extend command (->2-18)
    #PPZExtend command (->2-25)

===============================================================================
1-2 How to use the rhythm part (K/R)
-------------------------------------------------------------------------------
1-2-1 When playing the PMD built-in SSG drums
-------------------------------------------------------------------------------
    The K/R part is basically a part for playing the SSG drums built into PMD.
    The K/R part is basically the part that plays the SSG drums built into the PMD.

    However, if PPSDRV (->PPSDRV.DOC) is resident and PMD supports it, you can use
    (DOC is resident and PMD supports it, this part plays the SSGPCM voice.

    Note that this is not a dedicated part for the YM2608 rhythm instrument. (->1-2-2)

    The R part defines the pattern, and the K part specifies the order in which the pattern is played.

    The R part is internally numbered from 0 to 255 in the order of definition.
    To specify the order in which the patterns are played, use the R command (->6-7) in the K part.
    You can use the R command (->6-7) in the K part to specify the performance order.

[Example]
K R0 L [R1]3R2
R0 l16[@64c]4
R1 l8 @1c@128c@2c@128c
R2 @1c@16c@8c@4c
    [The intro contains the Snare2 roll (line 2, R0) and the 8-beat pattern (line 3, R0).
        The 8-beat pattern (line 3, R1) is repeated three times, and
        This is followed by a tumb fill-in (line 4, R2), and then a loop.

    The numbers after the part symbol R are dummies and can be omitted, but it is easier to understand if they are written down.
    (->1-1-2) (->1-1-2)

[Related]
    R command (->6-7)
    @ command (->6-1)

-------------------------------------------------------------------------------
1-2-2 To play the YM2608 rhythm instrument
-------------------------------------------------------------------------------
    PMD does not have a dedicated part for the YM2608 rhythm instrument, but you can use the
    However, the rhythm instrument commands (->14) can be written in any part, so you can use
    However, the rhythm instrument commands (->14) can be written in any part, so it is convenient to specify the SSG rhythm part (K/R) that plays the same rhythm.

[Example.]
K \V63\vs31\vb31\vh15\vt31 ;Set the rhythm sound volume
K R0 L [R1]3R2
R0 l16[\sr]4
R1 l8\br\hr\\sr\hr
R2 \br\tr\tr\tr\tr
    [The same rhythmic pattern as in the example in 1-2-1, but without the rise and fall of the toms
        The same rhythmic pattern as in the example in 1-2-1, but without the up and down toms, will be played using the rhythm sound source.

    However, the rhythm source command (->14) can be used in basically any part.
    However, the rhythm sound command (->14) can be used in basically any part, so there is no harm in using it in the FM or SSG sound parts.
    However, the rhythm sound command (->14) can be used in basically any part.

[It can be used in FM or SSG parts.]
    MML commands and rhythm commands (->14)

-------------------------------------------------------------------------------
1-2-3 About the SSG sound part used by SSG rhythm in the K/R part
-------------------------------------------------------------------------------
    The SSG rhythm played by the K/R part uses the third channel of SSG.
    The SSG rhythm played by the K/R part uses the third channel of SSG, which will cause a conflict with the I part.

    It is best not to use them at the same time, but if you do
    However, if you do, the following rules apply

1) When one of the two parts is keyed on, the other part will be muffled.
2) If both parts are turned on at the same time, the K and R parts will take priority.

===============================================================================
1-3 Numerical notation method
-------------------------------------------------------------------------------
    Numeric values can be written in decimal or hexadecimal notation.

    For hexadecimal notation, prefix the number with "$".

    The internal counter value can be specified directly by prefixing "%" only when specifying the tone length.
    You can specify the internal counter value directly by prefixing "%".

    You can use space or tab to leave a space between the command name and the parameter value.
    However, a comma must be placed immediately after the numerical value.
    [Example 1

[Example 1] c4
[The result is a quarter-note do.

[Example 2] c$10
[The result is a 16th note do.

[Example 3] c%12
[Result] The do of an eighth note (internal clock 12) will be specified.

[Example 4] MA 12, 1, 8, 2
[Result] The space between the two is ignored, and the result is equivalent to MA12,1,8,2.

[failure example]
    MB 12 , 1 , 8 , 2
[Result: Error. No space is allowed between a number and a comma.

===============================================================================
1-4 Notation for comments
-------------------------------------------------------------------------------
    If you want to write a comment inside MML, you should basically write
    If you want to write a comment in MML, you should write a ; symbol (->16-5) and a newline as a comment.

[Example 1]
A @13 v13 ; A.Piano
            ~~~~~~~~~~ comment

    However, if there is a SPACE or TAB at the beginning of a line, the entire line is treated as a comment, even if there is no ; symbol.
    However, if a line is prefixed with SPACE or TAB, the entire line is treated as a comment, even if there is no ; symbol.

[Example 2]
    Part A (<-Comment)
A ...
B ...

    If you want to treat all lines in MML as comments, use the ` symbol (->16-6) at the beginning of a line.
    (->16-6) at the beginning of a line, and all lines up to the next ` symbol become comments.

[Example 3]
` MML Coded by M.
MML Coded by M. Kajihara.
Copyright(c)1994.

    If you want to write a comment between MML lines, you can use the ` symbol.

[Example 4]
A @13 v13 `c major` cdefgab>c< `c minor` cde-fga-b->c<

    In addition, all double-byte characters in MML are ignored except for special cases such as
    If a comment consists of only double-byte characters, the
    If the comment consists of only double-byte characters, the ` symbol does not need to be used.

[Example 5]
A @13 v13 C major -> cdefgab>c< C minor -> cde-fga-b->c<

    However, the following cases are special and no comments can be written.

1) In the string of the instruction that defines the string in the #define instruction.
2) ! 2) In a variable string in a definition or use instruction
3) In the = tone name string in the @define instruction

[Failure example]
#Title Sample Music ;music title
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ All underlined parts are defined as #title.

[Related] ; command (->16-5)
    ` command (->16-6)

===============================================================================
*******************************************************************************
2 [[[[ General control commands ]]]]
*******************************************************************************
===============================================================================

    The following commands can be specified at the beginning of a line to control the effect on all parts and
    The following commands can be specified at the beginning of a line to control things that affect all parts and various definitions of the song itself.

    Alphabetic strings such as "Filename," "Composer," "Extend," etc. can be in either lower or upper case.
    The command name, string, and numeric value are the same.

    The command name, string, and number must be separated by at least one SPACE or TAB character.
    The command name, string and number must be separated by one or more SPACE or TAB characters.

    The command name, string, and number must be separated by at least one SPACE or TAB character. Since the command is processed in the first pass, it can be located anywhere in the MML file.
    However, if you specify a command other than #Memo, the one on the next line is
    However, if you duplicate a command other than #Memo, the one on the next line will take effect.

===============================================================================
2-1 Specify output file name
    #Filename
-------------------------------------------------------------------------------
[Format 1] #Filename File name
[Format 2] #Filename . . extension
-------------------------------------------------------------------------------
    Changes the file name of the compiled song data output by MC.EXE.

    By default, the file name extension of the MML file is changed to ".M".
    M".

    If only the file extension is specified, only the file extension will be changed from the default ".M".
    If only the extension is specified, only the extension will be changed from the default ".

    The file name will be defined until a CTRL code other than TAB/ESC is encountered.
    (The filename is defined until the end of the line (usually CR).

[The file name is defined until a CTRL code other than TAB/ESC is reached.

[Example 1] #Filename SAMPLE.M
M. [Result] The song data file name will be "SAMPLE.M" regardless of the MML file name.
    [Example 2

[Example 2] #Filename .M2
[M2" is the name of the song data file to be created, regardless of the MML file name.
    M2".

===============================================================================
2-2 Specify the SSGPCM file name to be used
    #PPSFile
-------------------------------------------------------------------------------
[format] #PPSFile file name
-------------------------------------------------------------------------------
    Define the PPS(SSGPCM)File name to be used. (->PPS.DOC)

    The file name will be defined until a CTRL code other than TAB/ESC is encountered.
    (The file name is defined until the CTRL code except for TAB/ESC, which is usually until the end of the line (CR).

[The file name is defined until a CTRL code other than TAB/ESC comes.

[Note 2] The file extension cannot be omitted.

[Note 3] When you use MC.EXE, you need to define the tone data in the song data (->MC.DOC).
    Otherwise, the file will be loaded only when you play immediately with the /P or /S option of MC.EXE.
    DOC), the file will only be loaded when you play it immediately with the /P or /S option of MC.EXE.

[Example] #PPSFile PPS01.PPS
[PPS01.PPS is used for the SSGPCM voice of the K/R part.

===============================================================================
2-3 Specify the name of PCM file to be used
    #PCMFile , #PPCFile
-------------------------------------------------------------------------------
[Format 1] #PCMFile file name
[Format 2] #PPCFile file name
-------------------------------------------------------------------------------
    Define the PCM (.PPC/.PVI/.P86) file name to be used in J-part.
    (->PMDPCM.DOC)
    Indicate the .PVI/.PZI file name if PMDPPZE is used.

    #PCMFile and #PPCFile are exactly the same.

    The file name is defined until a CTRL code other than TAB/ESC comes along.
    (The filename is defined until the end of the line (usually CR).

[The file name is defined until a CTRL code other than TAB/ESC comes.

[Note 2] The file extension cannot be omitted.

[Note 3] When you use MC.EXE, you need to define the tone data in the song data (->MC.DOC).
    Otherwise, the file will be loaded only when you play immediately with the /P or /S option of MC.EXE.
    If this is not done, the file will only be loaded when playing immediately with the /P or /S option of MC.EXE.

[Example] #PCMFile SAMPLE.PPC
[Result] Use SAMPLE.PPC for PCM voice of J-part.
===============================================================================
2-4 Specifying the tone file name to use
    #FFFile
-------------------------------------------------------------------------------
[Format] #FFFile File name [.FF/.FFL].
-------------------------------------------------------------------------------
    Defines the name of the voice (.FF/.FFL) file to be used.

    The file name will be defined until a CTRL code other than TAB/ESC is reached.
    (The file name is defined until the end of the line (CR).

    If you write the tone file name on the command line of MC.EXE (->MC.DOC), it works exactly the same as
    DOC), and
    If the file exists, the /V option is automatically added at the same time.
    If the file does not exist, the specified file name will be used when writing with the /VW option.
    If the file does not exist, the specified file name is used when writing with the /VW option.

    If the extension is omitted, the file name will be .FFL if the OPL option (/L) is present, or .
    If the extension is omitted, the file name will be .FFL if the OPL option (/L) is present, or .FF if it is not.

[Note 1] When using this command with the tone definition command (@), be sure to use FFFile -> tone definition in that order.
    FFFile -> tone definition.
    If you write it after the tone definition command, it may overwrite the defined tone
    Note 2] If you want to use FFFile in conjunction with the

[Note 2] Even if a tone is specified on the command line, if this command is specified, this one will be effective.
    Example 1] #FFFile

[Example 1] #FFFile EFFEC.FF
[Result] Loads and uses the FM sound file "EFFEC.FF".

[Related] FM tone definition (@) (->3-1)
    MC.DOC

===============================================================================
2-5 Compiler option settings
    #Option
-------------------------------------------------------------------------------
[Format] #Option string
-------------------------------------------------------------------------------
    Sets the compiler options.

    The specified string is exactly the same as the one shown on the command line.
    (->MC.DOC)

[Note 1] The options are appended to the command line options.
    If two options that cannot be set at the same time, such as /N and /L, conflict, the later option will be used.
    Note 2] The /N and /L options are added to the command line options.

[Note 2] When setting options related to FM tone definition, such as /N, /M, /L, etc.
    [Note 2] When setting options related to FM tone definition, such as /N, /M, and /L, be sure to set them before the tone definition (@).

[Example] #Option /L/S/A/O
[Result] Sets the MC command line option /L/S/A/O.

[Related] FM tone definition (@) (->3-1)
    MC.DOC

===============================================================================
2-6 Title definition
    #Title
-------------------------------------------------------------------------------
[format] #Title Title string
-------------------------------------------------------------------------------
    Defines the title of the song.

    The string is defined until a CTRL code other than TAB/ESC.
    (Usually until the end of the line (CR).

[Note 1] Comments and the like cannot be written with a ; at the end.

[Note 2] When using MC.EXE, you need to define the tone data in the song data (->MC.DOC).
    If you don't, you will only see this string when you play immediately with MC.EXE's /P or /S option.
    This string will only be displayed when you play the song immediately with the /P or /S option of MC.EXE.

[Example] #Title Sample song
[If you do not use the /P or /S option of MC.EXE, this string will only be displayed if you play the song immediately.

===============================================================================
2-7 Defining the composer
    #Composer
-------------------------------------------------------------------------------
[format] #Composer composer name string
-------------------------------------------------------------------------------
    Defines the name of the composer.

    By default, if the environment variable "COMPOSER=" or "USER=" is defined, the defined string is used.
    If the environment variables "COMPOSER=" or "USER=" are defined, the defined string will be used. (->MC.DOC)

    The string will be defined until a CTRL code other than TAB/ESC is encountered.
    (Usually until the end of the line (CR).

[Note 1] Comments cannot be written with ; at the end.

[Note 2] When using MC.EXE, you need to define the tone data in the song data (->MC.DOC).
    If you don't, you will only see this string when you play immediately with MC.EXE's /P or /S option.
    DOC), this string will only be displayed when you play immediately with the /P or /S option of MC.

[Example] #Composer M.Kajihara
[Result] Let's say the composer's name is "M.Kajihara".

===============================================================================
2-8 Arranger definition
    #Arranger
-------------------------------------------------------------------------------
[Format] #Arranger arranger name string
-------------------------------------------------------------------------------
    Defines the name of the arranger.

    By default, if the environment variable "ARRANGER=" or "USER=" is defined, the defined string is used.
    If the environment variables "ARRANGER=" or "USER=" are defined, the defined string will be used. (->MC.DOC)

    The string will be defined until a CTRL code other than TAB/ESC is encountered.
    (Usually until the end of the line (CR).

[Note 1] Comments cannot be written with ; at the end.

[Note 2] When using MC.EXE, you need to define the tone data in the song data (->MC.DOC).
    If you don't, you will only see this string when you play immediately with MC.EXE's /P or /S option.
    DOC), this string will only be displayed when you play immediately with the /P or /S option of MC.

[Example] #Arranger M.Kajihara
[Result] The name of the arranger is "M.Kajihara".

===============================================================================
2-9 Memo definition
    #Memo
-------------------------------------------------------------------------------
[format] #Memo memo string
-------------------------------------------------------------------------------
    Defines a memo string.

    Multiple memo strings can be specified, and they are defined in order. The maximum number of lines is 128.

The maximum number of lines is 128. [Note 1] Comments and the like cannot be written with ; at the end.

[Note 2] When using MC.EXE, make sure to define the tone data in the song data (->MC.DOC).
    If you don't, you will only see this string when you play immediately with MC.EXE's /P or /S option.
    This string will only be displayed when you play the song immediately with the /P or /S option of MC.EXE.

[Example] #Memo: Created on March 25, 1994.
[Result] Define "Created on March 25, 1994" as a memo.

===============================================================================
2-10 Specifying tempo
    #Tempo #Timer
-------------------------------------------------------------------------------
[Format 1] #Tempo Number
[Format 2] #Timer number
-------------------------------------------------------------------------------
[Range] [Format 1] 18-255
    [Format 2] 0 to 250
-------------------------------------------------------------------------------
    Specifies the tempo.

    #Tempo specifies how many times per minute the internal clock 48 will be.
    The internal clock 48 is a half note by default, but can be changed with the #Zenlen command
    or the C command to change it.

    In the case of #Timer, it directly specifies how many times TimerB will be used.

    If you specify this command, a t or T command will be automatically issued at the beginning of part G.
    This command will automatically issue a t or T command at the beginning of part G.

[Example 1] #Tempo 60
This command will automatically issue a t or T command at the beginning of part G. [Example 1] #Tempo 60 [Result] This command sets the tempo to 60 (half note = 60). (Quarter note = 120).

[Example 2] #Timer 100
[Result] Set the tempo to 100 using the internal TimerB value.

[Related] t command (->11-1)
    T command (->11-2)
    C command (->4-11)
    #Zenlen command (->2-11)
===============================================================================
2-11 Specifying total note length
    #Zenlen
-------------------------------------------------------------------------------
[format] #Zenlen number
-------------------------------------------------------------------------------
[Range] 1 to 255
-------------------------------------------------------------------------------
    Specifies the total note length.

    Similar to MML's C command, if you specify a value other than 96, a C command will be automatically issued at the beginning of part G.
    If you specify a value other than 96, the C command is automatically issued at the beginning of part G.

    All note lengths you specify must be approximately this number.

    The default is 96, so the available note lengths are
    1,2,3,4,6,8,12,16,24,32,48,96
    The available note lengths are 1,2,3,4,6,8,12,16,24,32,48,96.

[If you change this setting, the tempo value will change, as will the number of notes per minute that can be played at the specified tempo value.
    [Note] If you change the tempo value, the number of notes per minute that will have the specified tempo will change.

[Example: #Zenlen 192
[If you change the tempo value, it will change which notes per minute will have the specified tempo value.
    [Result] All notes are set to internal clock 192, and the available note lengths are increased to 14: 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 192.
    The value specified by the #Tempo and t commands will be the value of the quarter note.

[If you use this command to increase the total note length, you will be able to express more detail, but you will also be able to play more notes.
    However, the larger the note length, the more CPU power will be consumed during performance.

    If you are creating a piece of music to be used as background music for a scene that requires high-speed processing, you may want to
    In particular, if you are creating a piece of music to be used as background music in a scene that requires high-speed processing, you can reduce the CPU power required for the performance process by reducing this value.
    [Related] C command (->)

[Related] C command (->4-11)
    #Tempo command (->2-10)
    t command (->11-1)

===============================================================================
2-12 Designating octave up/down symbol functions
    #Octave
-------------------------------------------------------------------------------
[Format 1] #Octave Reverse
[Format 2] #Octave Normal
-------------------------------------------------------------------------------
    >, < command's role is reversed with reverse and normal with normal.

    Like MML's X command, when specified, the X command is automatically issued at the beginning of part A.
    The X command is automatically issued at the beginning of part A.

[Example] #Octave Reverse
The X command is automatically issued at the beginning of part A. [Result] > command is octave down, < command is octave up.

[Related] X command (->4-6)
    > < command (->4-5)

===============================================================================
2-13 Setting the default loop count
    #LoopDefault
-------------------------------------------------------------------------------
[format] #LoopDefault number
-------------------------------------------------------------------------------
[Range] 0 to 255
-------------------------------------------------------------------------------
    Set the value to be specified when the numeric value is omitted in the [ End of loop command ].
    The default is 0 (infinite loop).

    The default value is 0 (infinite loop).

[Example] #LoopDefault 2
If no value is specified in the [[Result]] command, the default value is 2 loops.

[Related]] commands (->10-1)

===============================================================================
2-14 Setting whether or not to include DT2 in tone data.
    #DT2Flag
-------------------------------------------------------------------------------
[Format 1] #DT2Flag on
[Format 2] #DT2Flag off
-------------------------------------------------------------------------------
    Sets whether or not DT2 is included in the tone data format.

    The default varies depending on the MC options and is
    If /m is specified -> on
    If /m is not specified -> off
    When /m is not specified, the default is off.

    If DT2 is required for a sound source and this flag is not specified as off, then
    If this flag is not specified by off, DT2 is set to 0 for all slots.

[Example] #DT2Flag on
[If this flag is not set to off, DT2 will be set to all slots 0.

[Related] FM tone definition (@) (->3-1)

===============================================================================
2-15 Bend range setting
    #Bendrange
-------------------------------------------------------------------------------
[Format] #Bendrange value
-------------------------------------------------------------------------------
[Range] 0 to 255
-------------------------------------------------------------------------------
    Sets the bend width. The default value is 0.

    This is the same as MML's B command, which automatically issues a B command at the beginning of part A.
    The B command is automatically issued at the beginning of part A.

    If a non-zero value is specified, the I command is enabled and the bend width is set to
    If a non-zero value is specified, the I command is enabled and the bend width is shifted by 8192 semitones.

[Note: Bend specification requires a lot of attention to the I command (->7-5), and may make MML difficult to read.
    In addition, it may make MML difficult to read.
    It should not be used except for MIDI conversion.

[Example] #Bendrange 12
[The result is I8192, which shifts the pitch by exactly one octave.

[Related] B command (->7-4)
    I command (->7-5)

===============================================================================
2-16 SSG pitch extended/normal selection
    #Detune
-------------------------------------------------------------------------------
[Format 1] #Detune Extend
[Format 2] #Detune Normal
-------------------------------------------------------------------------------
    Select whether you want the SSG Detune/LFO to be extended or normal.

    When "Extend" is selected, it is the same as specifying the "DX1" command at the beginning of all SSG parts (G, H, and I).
    If you select Extend, it is the same as specifying the "DX1" command at the beginning of all SSG parts (G, H, I).

    In the normal specification, if the DETUNE/LFO is shifted by 1, the pitch value sent to the sound source will also be shifted by 1.
    If the DETUNE/LFO is shifted by 1, the pitch value sent to the sound source will also be shifted by 1. (Even with the same DETUNE value, the higher the pitch value, the larger the shift.)

    In the case of the extended specification, the higher the pitch, the smaller the DETUNE value will be.
    In the case of extended specifications, the DETUNE value will be reduced as you move into the higher registers, and the same DETUNE value will be used to compensate for the same amount of shift at all pitches.

[Example] #Detune Extend
[Result] Changes the detune value of SSG to the extended specification.

[Related] DX command (->7-3)
    D DD command (->7-1)
    M MA MB command (->9-1)

===============================================================================
2-17 Software LFO speed Extended/Normal selection
    #LFOSpeed
-------------------------------------------------------------------------------
[Format 1] #LFOSpeed Extend
[Format 2] #LFOSpeed Normal
-------------------------------------------------------------------------------
    Selects whether the speed of software LFOs should be extended to be tempo-independent.
    software LFO speed to a tempo-independent extended specification.

    When "Extend" is selected, it is equivalent to specifying the command "MXA1 MXB1" at the beginning of all FM, SSG, and ADPCM parts (A to J).
    This is the same as specifying the command "MXA1 MXB1".

    If you want to change only one of the two LFOs, use the MX command.

[Example] #LFOSpeed Extend
[If you want to change only one of the two LFOs, use the MX command.

[Related] MX MXA MXB command (->9-5)
    M MA MB command (->9-1)
===============================================================================
2-18 Software envelope speed expansion/normal selection
    #EnvelopeSpeed
-------------------------------------------------------------------------------
[Format 1] #EnvelopeSpeed Extend
[Format 2] #EnvelopeSpeed Normal
-------------------------------------------------------------------------------
    Selects whether or not to extend the SSG/PCM software envelope speed to a tempo-independent
    Selects whether the SSG/PCM software envelope speed should be tempo independent or not.

    If "Extend" is selected, it is the same as specifying the "EX1" command at the beginning of all SSG and PCM parts (G to J).
    This is the same as specifying the "EX1" command at the beginning of all SSG and PCM parts (G to J).

[Example] #EnvelopeSpeed Extend
[This command is equivalent to specifying "EX1" at the beginning of all PCM parts (G to J).

[Related] EX command (->8-2)
    E command (->8-1)

===============================================================================
2-19 PCM volume value Extended/normal selection
    #PCMVolume
-------------------------------------------------------------------------------
[Format 1] #PCMVolume Extend
[Format 2] #PCMVolume Normal
-------------------------------------------------------------------------------
    The conversion method of "v" value->"V" value in PCM part is
    Normal: V = v16
    Extend: V = vv
    Select the conversion method from Normal: V = v16 to Extend: V = vv.

    If you select Extend for PMDB2 and PMDVA, or Normal for PMD86, the volume curve at "v" value will be almost linear.
    If you select Extend for PMDB2 and PMDVA, and Normal for PMD86, the volume curve at the "v" value seems to be almost linear.

[Example] #PCMVolume Extend
[Result] The PCM part's "v" value->"V" value conversion method is V=vv.

[Related] v command (->5-1)
    V command (->5-2)

===============================================================================
2-20 Extension of the third FM channel part
    #FM3Extend
-------------------------------------------------------------------------------
[format] #FM3Extend part symbol 1[part symbol 2[part symbol 3]]]
-------------------------------------------------------------------------------
[symbol] One of LMNOPQSTUUVWXYZabcdefghijklmnopqrstuvwxyz
-------------------------------------------------------------------------------
    Extends the FM Sound Source 3 part with the specified part symbol.
    Can be set for up to 3 channels.

    The third FM channel can play up to four independent parts.
    The third channel of the FM source can play up to four independent parts, but only one part is defined by default, except for PMD/PMDVA1.
    By default, however, only one part is defined, except for PMD/PMDVA1, so use this command to define a new part symbol.

    However, by default, only one part is defined, except for PMD/PMDVA1.
    This command will change that.

[Example] #FM3Extend XYZ
[This command extends parts X, Y, and Z to create a new FM source 3 part.
    In the case of PMD/PMDVA1, change the part names D, E, F to X, Y, Z.

[Related] Correspondence between part symbols and sound sources (->1-1-3)

===============================================================================
2-21 Inserting an MML file
    #Include
-------------------------------------------------------------------------------
[format] #Include file name
-------------------------------------------------------------------------------
    Reads and adds an MML file between the #Include line and the next line of MML.
    The extension cannot be omitted.

    The default # instruction, @ tone, ! It is very useful to read MML files that define default #instructions, @tones, variables, etc. from outside.
    This is very useful. However, be careful of the MML length limit (61KB).

    It is also possible to load (nest) INCLUDE files in an INCLUDE file.

[Example] #Include default.mml
Example] #Include default.mml [Result] The default.mml is read and inserted in its place.

===============================================================================
2-22 Setting volume down by sound source
    #Volumedown
-------------------------------------------------------------------------------
[Format] #Volumedown [F[S[P[R]]]][]numeric[,[F[S[P[R]]]][]numeric,]
-------------------------------------------------------------------------------
[Range] [Without ] 0 to 255
    [With ] -128 to +127
-------------------------------------------------------------------------------
    Changes the volume down value by sound source.

    F is for FM, S is for SSG, and
    S is for SSG, P is for PCM, and
    P is for PCM, and R is for rhythm.
    R represents the rhythm source.

    If set, the DF, DS, DP, and DR commands will be automatically issued at the beginning of the G part.
    When set, the DF, DS, DP, and DR commands are automatically issued at the beginning of the G part.

    If the value is preceded by + -, it will be changed relative to the value of the /DF,/DS,/DP,/DR option in PMD.
    If the value is preceded by + or -, it is changed relative to the value of the /DF, /DS, /DP, and /DR options of PMD.
    Note that + decreases the volume.

[Note that the volume down value set here is a local value that is effective only for that song.
    When you start playing the song again, the values specified in the /DF, /DS, /DP, and /DR options of PMD will be reset and the volume will be restored.
    When you start playing again, the values specified in the /DF, /DS, /DP, and /DR options of PMD will be reset and then restored.

[Example 1].
#Volumedown FR+16,P+128,S+32
[The result is that FM and Rhythm are added relative to 16, PCM to 128, SSG to 32, and PMD to 32.
    [Example 2] #Volumedown

[Example 2]
#Volumedown F-16
[Result: FM is subtracted (made louder) from 16, relative to the PMD option setting.

[Example 2]
#Volumedown P96
[Result: PCM volume down value is set to 96, regardless of PMD option setting.

[Related] DF DS DP DR command (->15-4)
    PMD /DF /DS /DP /DR options (->PMD.DOC)

===============================================================================
2-23 Setting PCM part specifications
    #ADPCM
-------------------------------------------------------------------------------
[Format 1] #ADPCM on
[Format 2] #ADPCM off
-------------------------------------------------------------------------------
    Only valid when playing with PMD86.

    If on, adjust volume/loop to ADPCM (with /s option)
    When "off" is selected, volume and loop are not adjusted to ADPCM (no /s option).

    When off, ADPCM volume/loop is disabled (no /s option).

    Regardless of the state of the /s option, it will change the state to that.

    This is a local setting, effective only for that song, and when playing other songs, the
    It will revert back to the original.

    When this command is used, an A command will be issued at the beginning of the J part.

[Example.]
#ADPCM on
[If the song is played using PMD86, the PCM part will be played with the same specifications as ADPCM.

[Related] A command (->15-10)

===============================================================================
2-24 Specifying the measure to start playing
    #Jump
-------------------------------------------------------------------------------
[Format 1] #Jump Measure number
-------------------------------------------------------------------------------
[range] 0-65535
-------------------------------------------------------------------------------
    This is valid only when starting a performance with the /P,/S option of MCH.EXE or MC.EXE.
    Specifies the measure number to start playing.

    M file, so if you replay the file using PMP.COM, etc.
    M file, so if you replay the file using PMP.COM, etc., it will play from the beginning of the song.

    Also, if you specify a large measure number on a model with a slow CPU, it may take a while before the performance starts.
    If you specify a large measure number on a slow CPU model, it may take some time before the performance starts.

[Example]
#Jump 16
[If you start playing with the /P,/S option of MCH.EXE or MC.EXE, playback will start at measure 16.
    If you start playing with the /P,/S option of MCH.EXE or MC.EXE, playback will begin at measure 16.

===============================================================================
2-25 Part extension for PPZ8
    #PPZExtend
-------------------------------------------------------------------------------
[format] #PPZExtend part symbol 1[part symbol 2[part symbol 3](up to 8)]]
-------------------------------------------------------------------------------
[symbol] One of LMMNOPQSTUUVWXYZabcdefghijklmnopqrstuvwxyz
-------------------------------------------------------------------------------
    Extends the part for PPZ8 with the specified part symbol.
    It can be set for up to 8 channels.

[Example] #PPZExtend abcdefgh
[Result] Parts a, b, c, d, e, f, g, and h are newly extended to become PPZ8 parts.

[Related] Correspondence between part symbols and sound sources (->1-1-3)

===============================================================================
2-26 Specify PCM file name for PPZ used
    #PPZFile
-------------------------------------------------------------------------------
[Format] #PPZFile file name [.PVI/.PZI][,file name [.PVI/.PZI]]
-------------------------------------------------------------------------------
    Defines the PCM (.PVI/.PZI) file name to be used in the PPZ extension part.
    If the extension is omitted, the files are normally searched in the order PZI->PVI when loaded.

    Up to two files can be defined.
    For the second PCM file defined, 128 is added to the tone number and
    The second PCM file is defined as @128 to @255.

    The file name is defined until a CTRL code other than TAB/ESC is reached.
    (Usually until the end of the line (CR).

[Note 1] You cannot add comments with ; at the end.

[Note 2] When defining the second PCM file, do not put spaces, tabs, etc. on either side of the comma [,] symbol.
    Note 2] When defining the second PCM file, no spaces, tabs, etc. can be placed on either side of the comma [,] symbol.

[Note 3] When using MC.EXE, the voice data must be defined in the song data (->MC.DOC).
    When using MC.EXE, make sure that the tone data is defined in the song data (->MC.DOC), otherwise the file will only be loaded when playing immediately with the /P or /S option of MC.EXE.
    DOC), the file will only be loaded when it is played immediately with the /P or /S option of MC.EXE.

[Example] #PPZFile SAMPLE.PZI
[PZI is used as the PCM tone for the part specified by #PPZExtend.

[Example 2] #PPZFile BASEPCM.PZI,EXTEND.PVI
[PZI to the PCM tone of the part specified by #PPZExtend @0 to @127, and
    PZI as @0 to @127 and EXTEND.PVI as @128 to @255.

[PZI as @0 to @127 and EXTEND.PVI as @128 to @255.
[No space is allowed on either side of the comma symbol.
    An error will occur when reading PCM.

===============================================================================
2-27 General transpose setting
    #Transpose
-------------------------------------------------------------------------------
[Format] #Transpose Value
-------------------------------------------------------------------------------
[Range] -128 to +127
-------------------------------------------------------------------------------
    Sets the transpose value for the entire song.

    If specified, this is the same as specifying the "_M" command at the beginning of all parts except Rhythm.
    This is the same as specifying the "_M" command at the beginning of all parts except Rhythm.

    If there is a part that you do not want to transpose, such as a track used for rhythm, specify "_M0" at the beginning of the track.
    If there is a part that you do not want to transpose, such as a track used for rhythm, issue the "_M0" command at the beginning of that track to cancel it.

[Example] #Transpose 1
[This will move the entire song up a semitone.

[Related] _M command (->4-16)

===============================================================================
===============================================================================
*******************************************************************************
3 [[[[ Definition commands ]]]]
*******************************************************************************
===============================================================================

    This command defines the FM tone and MML variables.

    It is processed in the first pass, so it does not matter where it is located in the MML file.

    It does not matter where it is located in the MML file. However, if a duplicate is specified, the one in the later line will take effect.

===============================================================================
3-1 FM tone definition
    @
-------------------------------------------------------------------------------
[Format 1] @ Tone number ALG FB
     AR DR SR RR SL TL KS ML DT AMS
     AR DR SR RR SL TL KS ML DT AMS
     AR DR SR RR SL TL KS ML DT AMS
     AR DR SR RR SL TL KS ML DT AMS
[Format 2] @ Tone number ALG FB
     AR DR SR RR SL TL KS ML DT DT2 AMS
     AR DR SR RR SL TL KS ML DT DT2 AMS
     AR DR SR RR SL TL KS ML DT DT2 AMS
     AR DR SR RR SL TL KS ML DT DT2 AMS
[Form 3] @ Tone number ALG FB
     AR DR RR SL TL KSL ML KSR EGT VIB AM
     AR DR RR SL TL KSL ML KSR EGT VIB AM
-------------------------------------------------------------------------------
[Note] The = tone name can be written in any position.
-------------------------------------------------------------------------------
[Range] [Format 1 and 2] ALG  07
            FB  07
            AR  031
            DR  031
            SR  0 to 31
            RR  0 to 15
            SL  0 to 15
            TL  0 to 127
            KS  0 to 3
            ML  0 to 15
            DT  -3 to 3 or 0 to 7
            AMS  0 to 1
    [Format 2] DT2  0 to 3
    [Format 3] ALG  0 to 1
            FB  0 to 7
            AR  015
            DR  015
            RR  015
            SL  0 to 15
            TL  0 to 63
            KSL  0 to 3
            ML  0 to 15
            KSR  01
            EGT  0 to 1
            VIB  0 to 1
            AM  0 to 1
-------------------------------------------------------------------------------
    This command defines the tone of the FM sound source.

    The @ symbol is always written at the beginning of the line, and one or more
    The @ symbol must be at the beginning of the line, and one or more SPACE, TAB, comma, or line feeds are required between numbers.
    However, only TAB and newline are allowed to separate tone names.

    [Format 1] requires that MC.EXE does not have the /M option, or that
            Format 1] is for MC.EXE without the /M option or with #DT2Flag off.
    [Format 2] is for MC.EXE with the /M option or with #DT2Flag on.
            Format 2] is the format when MC.EXE has the /M option or #DT2Flag is on.
    [Format 3] is the format of MC.EXE with the /L option.
    The format is as follows.

    If you write any non-numeric character from @ to the last value without a; or =, you will get an error.
    This will result in an error.
    You cannot omit any numerical values other than the tone name.

    For the meaning of each parameter, refer to the main unit manual or FM manual.
    For the meaning of each parameter, refer to the main unit manual or FM sound manual.

[Note] When using MC.EXE, make sure to define the tone data in the song data (->MC.DOC).
    If you do not, it will be invalid even if it is defined.

[Example 1]
@ 0 4 5 =falsyn?
    31 0 0 0 0 22 0 2 3 0
    18 10 0 6 0 0 0 8 3 0
    31 0 0 0 0 23 0 4 -3 0
    18 10 0 6 0 0 0 4 -3 0
[Define "falsyn?" for tone number 0.
[Example 2] When MC.EXE /M option is specified or #DT2Flag on is specified
NM AG FB Falcom Synth(?)
@ 0 4 5 =falsyn?
; AR DR SR RR SL TL KS ML DT DT2 AMS
    31 0 0 0 0 22 0 2 3 0 0
    18 10 0 6 0 0 0 8 3 0 0
    31 0 0 0 0 23 0 4 -3 0 0
    18 10 0 6 0 0 0 4 -3 0 0
[Result] Define "falsyn?" for tone number 0.

[Example 3] When MC.EXE /L option is specified
L option; NM AG FB E.Bass
@ 2 0 5 =E.Bass
When MC.EXE /L option is specified ; AR DR RR SL TL KSL ML KSR EGT VIB AM
    11 5 2 2 29 0 0 0 0 0 1 0
    12 8 6 1 0 0 1 1 1 1 0
[Define E.Bass as tone number 2.

[Related] @ command (MML) (->6-1)
    #DT2Flag command (->2-14)
    MC.EXE /N /M /L option (->MC.DOC)

===============================================================================
3-2 MML variable definitions
    !
-------------------------------------------------------------------------------
[Format 1] ! String MML string
[format 2] ! Numeric MML string
-------------------------------------------------------------------------------
[string] Any character type and number of characters. Any type and number of characters, up to 30 characters from the beginning.
[Range] 0 to 255
-------------------------------------------------------------------------------
    Defines MML variables.

    Up to 256 types of string definitions and 256 types of numeric definitions are available.
    Each of them can be defined independently.

    String definitions can be any character, as long as the first character is not a number.
    ( ! Snare, etc. can be specified in double-byte characters.)

    There must be at least one space or tab between strings, numbers, and MML strings.
    A space or tab is required between strings, numbers, and MML strings.

    Variables can be nested, but never recursive.

    Variables are used in MML by the ! command (MML).

[Note 1] The maximum length of a string is 30 characters. If you define more than 30 characters, the rest of the string will be ignored.
    If you define more than 30 characters, the rest of the string will be ignored.

[Note 2] If the program recurses and becomes a permanent loop, it will run out of control in the worst case.
    Please be very careful.

[Example 1]
A cde
1 !A fga
A l8 !1 b
[Result] !
Equivalent to A l8 cdefgab.

[Example 2]
BassDrum @0v12
SnareDrum @1v14
A !BassDrum cc !SnareDrum g !BassDrum c
[Result] A @0v12 cc @1v14
A @0v12 cc @1v14 g @0v12 c

[Failure] !
A cde !B
B cde !A
A !A
[A and !B keep referring to each other, causing the stack to overflow, and in the worst case, runaway.

[Related] ! Command (MML) (->16-1)

===============================================================================
*******************************************************************************
4 [[[[ MML command, pitch/tone length part ]]]]
*******************************************************************************
===============================================================================

    The following is an explanation of the MML commands.

    Parameters enclosed in [ ] are optional.

    The [sound source] indicates the part (sound source) where the command can be used.
    The following parts are available

FM FM sound part (A-F for 98 and 88 and FM3 extension part, A-H for 68, A-I for IBM)
SSG SSG sound part (G to I)
PCM PCM sound part (J (J and K for towns only) and PPZ extended part)
R selection Rhythm selection part (K)
R definition Rhythm definition part (R)
FM(OPNA) FM sound source part (dedicated to PMDB2/VA/86 A to F and FM3 extended parts)
FM(OPM) FM sound source part (PMD.X A to H only)
FM(ch3) FM sound source part (dedicated for PMD.COM C to F, PMDB2/VA/86 C and FM3 extended part)
PCM (AD) PCM data part (dedicated to J part of PMDB2/VA)
PCM (86) PCM data source part (PMD86 J part only)
PCM (68) PCM data part (PMD.X J-part only)
PCM(PPZ) PCM sound part (for PPZ extension part only)

    This section contains commands related to pitch and note length.

    In the K (Rhythm Selection) part, these commands are mostly not available.

===============================================================================
4-1 Specifying pitch and duration
    c/d/e/f/g/a/b/x
-------------------------------------------------------------------------------
[format 1] c/d/e/f/g/a/b [=] [+/-] [note length] [.] [format 2] x
[format 2] x [note length] [.]
-------------------------------------------------------------------------------
[range] a value between 1 and 255 that is approximately the length of all notes (->2-11), or a clock value with %.
-------------------------------------------------------------------------------
[Sound source] FM / SSG / PCM / R definition
-------------------------------------------------------------------------------
    Represents a single note. Each
    c = Do
    d = re
    e = mi
    f = F
    g = So
    a = la
    b = C
    Corresponds to

    Also, if x is used in the note data, the note played immediately before will be adopted.
    (e.g., c4x8 will be played as c4c8).

    The octave can be raised or lowered by using the o < > commands.
    However, the octave of the previous note will be used as the pitch x.

    In R part and J part (PCM) in PMD.
    X, c, b, and x will sound the same no matter which is specified.

    If the transposition is specified by the _{ } command (->4-15), the pitches c to b are automatically transposed.
    You can avoid this by adding the = sign (natural).

    +However, you can avoid this by adding the = symbol (natural).
    The + sign (sharp) is a semitone higher, and the - sign (flat) is a semitone lower.
    It is also possible to specify more than one + sign and - sign. (Double flat, etc.)
    However, they cannot be attached to the pitch x.

    If you omit the tone length, the tone length specified by the l command will be used.

    . If you add the symbol (dot), the note length will be multiplied by 1.5.
    If two or more are added, the note length will be increased by 1.5 times.
[Example 1] c2...
[Result] c2&c4&c8

    Use the 3 and 6 series notes after calculating them as 3, 6, 12, 24, 48, and 96th notes.
[Example 2] c12d12e12
[result] cde of eighth note triplets (equivalent to {CDE}4 in N88Basic)
[Supplemental] If you add three twelfths, you get a quarter, so a twelfth note is a quarter note divided into
    So a twelfth note is a quarter note divided into three parts (= eighth note triplet).

    Since fifths, seventh notes, etc. are not divisible, they can be specified in detail using %.
[Example 3] c%4 d%5 e%5 f%5 g%5
[result] cdefg (equivalent to {CDEFG}4 in N88Basic), which is a whole quarter note length with five consecutive notes.
[In the case of C96 (total note length = 96), the internal step for a quarter note is 96  4 = 24.
    If we divide 24 by 5, we get 4 more than 4.
    Therefore, if we make four notes of length %5 and one note of length %4
    It will sound like a series of five notes.

    If you are using the W S command, it will automatically add a software echo or
    When using the W S command, the note is automatically processed and expanded so that a software echo or ornamental note is applied.

[Note 1] In PMD.X, c, c+, d in octave 1 are played as d+.

X, c, c+, and d of octave 1 are played as d+. [Note 2] In the PCM part of PMDB2/VA, octave 6 or higher is played as octave 6.
    In the PCM part of PMDB2/VA, octave 6 or higher is played as octave 6.

[Note 3] Scale marks (c/d/e/f/g/a/b) to note points (.) are played without pause. Note 3] Do not leave any space between the
    In particular, the = + - symbols should be written with no space between them. In particular, note that the = + - symbols will be recognized as l= l+ l- commands if there is a gap between them.
    Note that the = + - symbols in particular will be recognized as the respective l= l+ l- commands if there is a gap between them.

[Note 4] Note that in some cases it may not be possible to specify a note length that exceeds the internal clock 255.
[Example of failure] C192 W24,-2 c1.
[Result: Over-length error.
[Note 4] If you want to specify a note length that exceeds 255 clocks, you must execute the W and S commands.

[Note 5] If pitch x is specified in the R part, it will be taken as note data unconditionally, and will not be displayed.
    If you specify a pitch x in the R part, it is unconditionally taken as note data, and is not considered a rest, even if the immediately preceding note is a rest.

[Related] o command (->4-4)
    > < command (->4-5)
    _{ } command (->4-15)
    l command (->4-8)
    W command (->12-2)
    S command (->12-1)

===============================================================================
4-2 Specifying rests and note lengths
    r
-------------------------------------------------------------------------------
[format] r [note length] [.]
-------------------------------------------------------------------------------
[range] 1-255 (->2-11) or clock value with %.
-------------------------------------------------------------------------------
[Sound source] FM / SSG / PCM / R definition
-------------------------------------------------------------------------------
    Represents a single rest.

    If the note length is omitted, it will be the note length specified by the l command.

    . If the symbol (dot) is added, the note length will be multiplied by 1.5.
    If two or more are added, the note length will be increased by 1.5 times.

[Example: r4.
[Result] A quarter note rest.

[Related] l command (->4-8)

===============================================================================
4-3 Portamento specification
    { }
-------------------------------------------------------------------------------
[format] {tone1 tone2} [tone length1] [.] [,note length 2]
-------------------------------------------------------------------------------
[range] [note length 1] 1-255, where 1 is the approximate number of all note lengths (->2-11)
        or clock value with %.
    [Note length 2] The above plus a value shorter than note length 1.
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,PPZ)
-------------------------------------------------------------------------------
    Specifies a note to be connected smoothly from pitch 1 to pitch 2 with a length equal to the note length.
    When pitch 2 is specified, the length of time to wait between the start of the sound and the pitch shift, the so-called delay, is set.
    The delay is set.

    The note length and note point are the same as for the c d e f g a b r command.
    You cannot specify a note length longer than 255 steps.

    Only the c d e f g a b o > < command should be specified in { }.

    It cannot be specified in the R part.

[Note 1] Portamento is not applied to the PCM part of PMD86 and PMD.
    X. If it is specified, pitch 1 will be ignored. ( {cd}2 is equivalent to d2 )

[Note 2] This command does not reflect the effect of the W S command.

[Example 1] {cg}4
[The result is a portamento of quarter-note length, rising from Do to So.

[Example 2] {cg}4,8
[Result] A portamento of quarter-note length, rising from Do to So after an eighth-note delay.
    In fact
    c8&{cg}8
    The result is the same as

[Related] W command (->12-2)
    S command (->12-1)

===============================================================================
4-4 Specifying the octave
    o
-------------------------------------------------------------------------------
[Format] o Numeric
-------------------------------------------------------------------------------
[Range] 1 to 8
    1 to 6 (PCM part in PMDB2)
    1 to 5 (PCM part in PMD.X)
X) -------------------------------------------------------------------------------
[Source] FM / SSG / PCM
-------------------------------------------------------------------------------
    Specify the octave.

    1 to 8 for FM/PSG, 1 to 6 for PCM on 88/VA/98.

    In the X68000 version of the PCM part, 1 to 5 can be specified, and the pitch changes roughly in octave units.
    The default is 4.

    The default is 4.

[Example: o6
[Result] Set octave to 6.

===============================================================================
4-5 Octave up/down.
    > <
-------------------------------------------------------------------------------
[Format 1] >
[Form 2] <
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM
-------------------------------------------------------------------------------
    If >, move up one octave.
    If < is selected, the octave will be lowered by one octave.

    The X #Octave command allows you to invert the function.

[Example 1] o4 c8>c8
[The eighth note do of octave 4 is followed by the eighth note do of octave 5.

[Note: If you specify a note in a loop, and then go back to the beginning of the loop, the octave will be different.
    If you specify a different octave, it will return to the original octave.
    If you want to specify such an octave, use the __ command.
[Example 2] o4[cdefgab>]2cde
[Result] o4cdefgab o4cdefgab o5cde

[Example 3] o4[cdefgab__12]2__-24cde
[Result] o4cdefgab o5cdefgab o4cde

[Related] X command (->4-6)
    #Octave command (->2-12)
    __ command (->4-14)

===============================================================================
4-6 Inverting octave up/down symbols
    X
-------------------------------------------------------------------------------
[format] X
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM
-------------------------------------------------------------------------------
    Reverses the function of the > and < commands. Equivalent to the #Octave command, but
    This command is equivalent to the #Octave command, but allows local and temporary changes.

[Example] c>c< X d<d> X
[Result] Equivalent to c>c< d>d<.

[Note 1] If you make a temporary change, be sure to undo it.
    If you do not, all parts will be affected from the next part.

[Note 2] If you want to change the whole MML with this command, you must put it at the beginning of part A.
    [Note 2] If you want to change the whole MML with this command, you need to write it at the beginning of part A. In that case, use #Octave command. If you want to change the entire MML with this command, you must put it at the beginning of part A. In that case, it is exactly the same as the #Octave command.

[Related] #Octave command (->2-12)
    > < command (->4-5)

===============================================================================
4-7 Whole octave change
    o+ o-
-------------------------------------------------------------------------------
[Format 1] o+ number
[Format 2] o- Numeric
-------------------------------------------------------------------------------
[range] -7 to +7
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM
-------------------------------------------------------------------------------
    Increases or decreases all the specified values of the o command from there in the part by the specified number.

    Also increases or decreases the current octave by the specified value at the same time.
    (Issue the o command.) [Example

[Example]
G o-1
H o-0
GH o4 cdefg
[Result] cdefg will be played with o3 for G part and o4 for H part.
    (octave overlap).

===============================================================================
4-8 Default note length specification
    l
-------------------------------------------------------------------------------
[format] l[%]note length [.].
-------------------------------------------------------------------------------
[range] 1-255, where the value is a fraction of the total note length (->2-11), or a clock value with %.
-------------------------------------------------------------------------------
[Sound source] FM / SSG / PCM / R selection / R definition
-------------------------------------------------------------------------------
    c d e f g a b r { } l= l+ l- l^ Specifies the length of the note to be used if the length is omitted in the command.
    The default is 4. The default is 4.

[Example 1] l8cdefg
The default is 4. [Example 1] l8cdefg [Result] Play cdefg in eighth-note length.

[Note: When used in a rhythm selection ( K ) part, only the last value specified will be used as the default value from the beginning of the R part.
    When used in a rhythm selection ( K ) part, only the last value specified will be the default value from the beginning of the R part.

    If used in a Rhythm Definition ( R ) part, it will affect the subsequent R parts.
    For example, if you specify a value in R0, it will be affected in R1.

[Example 2]
K l8R0l2
R0 @1c@2c
[The BD and SD of the SSG rhythm will be the length of a half note. (l8 will be ignored.)

[Related] c~b command (->4-1)
    r command (->4-2)
    { } command (->4-3)
    l= l+ l- l^ command (->4-9)

===============================================================================
4-9 Processing the previously specified tone length
    l= l+ l- l^
-------------------------------------------------------------------------------
[format 1] [l] [=] [tone length] [.] [format 2] [l
[Format 2] [l] + tone length [.].
[Format 3] [l] - tone length [.].
[Format 4] [l] ^ number
-------------------------------------------------------------------------------
[range] [note length] A value between 1 and 255 that is approximately the length of all notes (->2-11)
        or clock value with %.
    [number] 1-255
-------------------------------------------------------------------------------
[Sound source] FM / SSG / PCM / R definition
-------------------------------------------------------------------------------
    Changes the length of the previous note.

    If l=, change to the specified note length.
    If l+, add the specified note length.
    If l-, subtracts the specified note length
    If l^, multiplies by the specified value.
    The l and = signs can be omitted.

    The l and = signs can be omitted.

    . If you add a symbol, the note length will be multiplied by 1.5.
    If two or more are added, the length of the note will be increased by another 1.5 times.
    However, note points that exceed 255 steps cannot be used.

    If only a note point is specified with the l= command, the note point will be added to the previous note length specification.
    If both the note length and the note point are omitted, the note length specified by the l command will be used.

    The l+ command works the same as the & command with the notation of the note length immediately after it.
    (->4-10 & command)

    The l= command is usually used in combination with MML variables.
[Example 1].
!b @0c ;Bass Drum
s @1c ;Snare Drum
J [!b4!s4!b8!b8!s4]2
[Result]
J [ @0c4 @1c4 @0c8 @0c8 @1c4 ]2

    The l- command is useful for undoing the delay part.
[Example 2]
G l4v10 cdefg ab>c<
H l4v07r8cdefg l-8 v10fg a
[In the last three notes, the timing and volume of the G and H parts are aligned.

[Example 3] a8l=4.
    a8=4.
    a8 4.
    a8l+4
    a4+8
    a4&8
    a2l-8
    a2-8
    a8l^3
    a16^6
    a4.
[The result is all la dotted quarter notes.

[Note 1] The l= and l^ commands will produce an error if the previously specified note length has been compressed or processed.
    Note 1] The l= and l^ commands will result in an error if the previous note length has been compressed or processed.
    An error will also occur if the l- command specifies a note length longer than the previously specified note length.
    If the note length is longer than the previous note length specified with the l- command, an error will also occur.
 x c2&c2 =4 (because the previous note is compressed as c1)
 x W24,-2 c2 =4 (because the previous note is processed as c4(^2c4))
 W24,-2 c2 =4 (because the previous note is processed as c4(^2c4))  c2&c2^4 (because the previous note is compressed as c1)
 W24,-2 c2^4 (because the previous note is processed as c4(^2c4))
 C192 c1.^4 (because the previous note is decompressed as c%255&c%33)
 x c4-2
 W24,-2 c1-2 (because c1 is processed as c4(^2c4(^4c4(^6c4)))

[Note 2] The note length added by the l+ command is not affected by the W S command.

[Note 3] If the pitch symbol c d e f g a b is immediately followed by = + -, it is considered a natural sharp/flat symbol.
    If a = + - immediately follows the pitch symbol c d e f g a b, it will be judged as a natural, sharp, or flat symbol. In this case, either leave a space or use the
    In this case, leave a space or use the -l symbol.

[Example 4] Natural quarter note with c=4 c
    c =4 c quarter note (equivalent to c4)
    cl=4 c quarter note (equivalent to c4)
    l2c -8 eighth note of c flat
    l2c -8 c dotted quarter note
    l2cl-8 c dotted quarter note
    l4c+8 c sharp eighth note
    l4c +8 c dotted quarter note
    l4cl+8 c dotted quarter note

[Related] & Commands (->4-10)

===============================================================================
4-10 Specifying a tie slur
    && &&
-------------------------------------------------------------------------------
[Format 1] & [Format 2
[Format 2] && [Format 3] && [Tone length][.
[Format 3] & [Tone length][.]
[format 4] && [tone length][.]
-------------------------------------------------------------------------------
[Sound Source] FM / SSG / PCM / R Definition
-------------------------------------------------------------------------------
    Connect the preceding and following notes as a tie (&) or slur (&&).

    The difference between the two is that in the case of a tie, the previous note is not keyed off, but in the case of a slur, it is keyed off.
    The difference between the two is that in the case of a tie, the previous note is not keyed off, but in the case of a slur, it is keyed off, so the attack of the key on is either known (=&&) or not known (=&).
    The difference is whether the attack is known (=&&) or not (=&).

    Be sure to specify it immediately after the pitch command.

    If you specify the note length immediately after the & command, it will be treated as the same as the l+ command.
    If a note length is specified immediately after &, it is treated the same as the l+ command, and the specified note length is added to the previous note length.

[Example 1] a8&2
    a8l+2
    a8&a2
[The result is an eighth note plus a half note, all in la.

    If a note length is specified immediately after &&, a note of the same pitch as the previous note will be added immediately after the command.
    If a note length is specified immediately after &&, a note with the same pitch as the previous note will be issued immediately after the command with the specified note length.

[Example 2] a8&&2
[Result] a8&&a2

[Note 1] While the W and S commands are being executed, only the last note of the volume/tone after processing will be changed. Also, the note immediately after the
    Note 1] While the W and S commands are being executed, only the last volume and pitch of the processed note will be changed, and the note immediately after the & command will not be affected by the W and S commands.

[Note 2] In the Rhythm Definition (R) part, only Format 3 is valid.
    Format 1, 2, and 4 cannot be used.

[Example 3]
R0 @1 c4&c4
[Result: Error, use c2 or c4 r4.
    In the SSG rhythm part, the note does not break when a rest comes.

[Related] l+ command (->4-9)

===============================================================================
4-11 Setting the total note length
    C
-------------------------------------------------------------------------------
[Format] C Numeric
-------------------------------------------------------------------------------
[Range] 1 to 255
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R select / R define
-------------------------------------------------------------------------------
    This command determines the length of all notes. It is equivalent to the #Zenlen command.

    If set at the beginning of one of the parts, it will be valid for all parts.

    All note lengths you specify must be approximately this number.

    The default is 96, so the available note lengths are
    1,2,3,4,6,8,12,16,24,32,48,96
    The available note lengths are

    If you want to specify up to 64th notes, specify C192, etc.

If you want to specify up to 64th notes, specify C192, etc. [Note 1] If you change the value, the tempo value will change in terms of which notes per minute will have the specified tempo value.
    [Note 2

[If you change the value, the tempo value will change to the value of notes per minute.

[Example: C192
[This command is used to set the internal clock to 192 for all notes, and to set the available note lengths to 1, 2, 3, and 5.
    Increase the number of available note lengths to 14: 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, and 192.
    The value of the #Tempo and t commands will be the value of the quarter note.

[Related] #Zenlen command (->2-11)
    #Tempo command (->2-10)
    t command (->11-1)
    l command (->4-8)

===============================================================================
4-12 Specifying how to cut sound1
    Q
-------------------------------------------------------------------------------
[format] Q [%] number
-------------------------------------------------------------------------------
[Range] 0 to 8 (0 to 255 with %)
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM
-------------------------------------------------------------------------------

    Specifies how the sound is cut.

    As with N88Basic's MML, you can specify from 0 to 8 in 1/8 units.
    When "%" is specified, it is possible to specify in 1/256 units from 0 to 255.

    If 0 is specified, the sound is not cut off until the end.
    The default is 0.

    In practice, the keyoff position is determined by subtracting the value specified by the q command from the position where the sound is to be cut off, as specified by this command.
    In fact, the keyoff will be performed at the timing specified by the q command minus the value specified by this command.

[Example: Q4c4
[This command cuts off the note at the half of the note length.

[Related] q command (->4-13)

===============================================================================
4-13 Specifying how to cut a note2
    q
-------------------------------------------------------------------------------
[format 1] q [number 1][-[number 2]] [,number 3]]
[Format 2] q [l-note length [.]] [-[l tone length]] [,l tone length[.]]
-------------------------------------------------------------------------------
[Range] [Number 1] 0 to 255
    [Number 2] 0 to 255, but the difference from Number 1 must be within +127 to -127.
    [Number 3] 0 to 255
    [Note length] A value between 1 and 255 that is approximately the length of all notes.
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM
-------------------------------------------------------------------------------
    Specifies how the sound is cut.

    The sound from here will be

1) If the value 2 is not specified.
    [1) If the value 2 is not specified, the sound will be played for the duration of the value 1.

2) If number 2 is specified
    2) If number 2 is specified, the sound will be played [randomly within the range of number 1 to number 2].
                ~~~~~~~~
    The sound will be cut from behind.

    However, if the length of the cut is shorter than the time specified by value 3, the time specified by value 3 will be used.
    However, if the cut-off length is shorter than the time specified in numerical value 3, the time specified in numerical value 3 will be the actual length of the sound.
    (Please note that the number 3 = the length of the note that you want to be pronounced at least this long.)

    The value is set by the length of the sound when l is added, or by the internal clock value when l is not added.
    If not, it is set by the internal clock value.

    If 0 is specified as the value 1, the sound will not be cut off until the end.
    The default value is 0.

    If the same value as number 1 is specified for number 2, or if it is omitted, the cutting time is fixed to the value of number 1.
    The default is fixed. The default is fixed.

    If 0 is specified for number 3, the minimum guaranteed tone length is 1.
    The default is 0.

    The values 1 to 3 can be omitted.
    However, if you specify number 2, number 1 is always required.

    If omitted, no value is specified for numbers 1 and 3, and the previous value is retained.
    To specify only the number 3, specify q,4.

    In practice, the timing is determined by subtracting the values 1 and 2 specified by this command from the position where the sound is cut off, as specified by the Q command.
    If the timing is beyond the timing of numerical value 3, the timing specified by numerical value 3 is used.
    If the timing is beyond the timing of numerical value 3, Keyoff will be performed at the timing specified by numerical value 3.

[Example] Q4 q2 c4
[The internal clock for a quarter note is 24 in C96, so
    Therefore, the keyoff will be performed at the 10th clock, which is the value obtained by subtracting 2 from 12, half of 24.

[Example 2] ql8,l16 c4 c8
[As a result, c4 is actually equivalent to c8 r8, while c8 is equivalent to
    [Example 2] ql8,l16 c4 c8 [Result] c4 is actually equivalent to c8 r8, and c8 is actually equivalent to c16 r16 because the lowest pronunciation length is valid.

[Example 3] q2-4 c4 c4 c4 c4 c4
[For each pronunciation, one of the states q2, q3, or q4 is randomly selected.

[The randomization of volume and pitch can be done with the random wave of the LFO. (9-1-4)
    (Example) M0,255,1,6MW3*2

[Related] Q command (->4-12)

===============================================================================
[Related] Q command (->4-12)


-------------------------------------------------------------------------------
[Format 1] _ +numeric
[Format 2] _ -numeric
[Format 3] __ +numeric
[Format 4] __ -numeric
-------------------------------------------------------------------------------
[range] -128 to +127
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM
-------------------------------------------------------------------------------
    All pitch commands from there will be changed by the specified number of semitones.

    The _ is an absolute value, and the __ is a relative value.

    This command is useful for gliss, etc. as well as for modulation.

    If the _M command (4-16) is specified, the master modulation value and the
    If the _M command (4-16) is specified, the master modulation value and the modulation value specified here will be added together and set.

[Example] _-2[e__+1]8_0
[Result] dd+eff+gg+a

[Related] _M command (->4-16)

===============================================================================
4-15 Transposition settings
    _{ }
-------------------------------------------------------------------------------
[Format 1] _{+ pitch 1 pitch 2 ... }
[Format 2] _{- Intervals 1 Intervals 2...}
[Format 3] _{= Intervals 1 Intervals 2...}
-------------------------------------------------------------------------------
[Sound Source] FM / SSG / PCM
-------------------------------------------------------------------------------
    Sets the transposition settings.

    After specifying this command for the specified part, the specified pitch will be automatically
    After specifying this command in the specified part, sharp, flat, and natural will be automatically added to the specified pitch.

[Example 1] _{-eab}
[Result] Automatically adds flats to M, R, and C. (E flat major, C minor)

[Example 2] _{=eab}
[Result] Restores the settings of Example 1.

===============================================================================
4-16 Master transposition value setting
    _M
-------------------------------------------------------------------------------
[Format 1] _M + number
[Format 2] _M - numeric
-------------------------------------------------------------------------------
[range] -128 to +127
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM
-------------------------------------------------------------------------------
    This command sets the master modulation value for each part.

    When this command is recognized, the modulation setting will be made immediately.
    When this command is recognized, an immediate transposition setting is made, and the specified value will be increased or decreased by the transposition value of the subsequent _ command.
    When this command is recognized, an immediate modulation setting is made, and the modulation value set by subsequent _ commands will be increased or decreased by the specified value.

[Related] ___ command (->4-14)
    #Transpose command (->2-27)

===============================================================================
*******************************************************************************
5 [[[[ MML command and volume section ]]]]
*******************************************************************************
===============================================================================

    This section contains a list of commands related to volume.

===============================================================================
5-1 Specifying volume1
    v
-------------------------------------------------------------------------------
[format] v volume value
-------------------------------------------------------------------------------
[Range] 0 to 15 (SSG, SSG rhythm sound part)
    0 to 16 (FM, PCM sound part)
-------------------------------------------------------------------------------
[Sound] FM / SSG / PCM(AD,86,PPZ) / R selection / R definition
-------------------------------------------------------------------------------
    Roughly specify the volume.

    For the SSG rhythm (K/R) part, this is disabled if PPSDRV is not resident.

[Reference] For FM sound sources, v0 to v16 are converted to the following V command values.
v | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9| 10| 11| 12| 13| 14| 15| 16|
V | 85| 87| 90| 93| 95| 98| 101|103|106|109|111|114|117|119|122|125|127|

    For PCM sources, the conversion is as follows
    V(2) is when #PCMVolume is Extend.
v | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9| 10| 11| 12| 13| 14| 15| 16
V(1) | 0| 16| 32| 48| 64| 80| 96|112|128|144|160|176|192|208|224|240|255|
V(2) | 0| 1| 4| 9| 16| 25| 36| 49| 64| 81|100|121|144|169|196|225|255|

[Example] v13
[Result] Sets the volume to 13.

[Related] #PCMVolume command (->2-19)
    V command (->5-2)

===============================================================================
5-2 Specifying volume 2
    V
-------------------------------------------------------------------------------
[format] V volume value
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,86,PPZ) / R selection / R definition
-------------------------------------------------------------------------------
[Range] 0 to 127 (FM sound part)
    0 to 255 (PCM sound source part)
    0 to 15 (SSG sound source, SSG rhythm, PPZ part)
-------------------------------------------------------------------------------
    Specify the volume in detail.

    The K/R part is disabled if PPSDRV is not resident.

[Example: V120
[Result] Set the volume to 120.

===============================================================================
5-3 Overall volume change 1
    v+ v-
-------------------------------------------------------------------------------
[Format 1] v+ Number
[Format 2] v- Numeric
-------------------------------------------------------------------------------
[range] + 0 to 127
    - 0 to 128
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,86,PPZ) / R select / R define
-------------------------------------------------------------------------------
    Increases or decreases the volume of all volume commands from the part by the specified value.
    The current volume is also increased or decreased by the specified value.

    It also increases or decreases the current volume by the specified value at the same time.
    (Issues the V command)

    The value is specified by the V command level (fine value).

    This is useful when you want to change the overall volume.

[Example 1] v-8
[Subtracts 8 from the volume value of each subsequent volume command for that part.

[Note: If you use this command twice in the same part, the first command becomes invalid after the second one is specified.
    (There is no relative change. (No relative change will be made.) [Example 2

[Example 2] v-4 V100 c4 v-6 V100 d4
[As a result, c4 becomes volume V96 and d4 becomes volume V94 (not V90).

[Related] V command (->5-2)

===============================================================================
5-3 Overall volume change 2
    v) v(
-------------------------------------------------------------------------------
[Format 1] v) Numeric
[Format 2] v( number
-------------------------------------------------------------------------------
[range] 0 to 16
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,86,PPZ)
-------------------------------------------------------------------------------
    Increases or decreases the volume of all volume commands from that part by the specified value.
    The difference between this and volume change 1 is that the volume of the command is increased or decreased by the specified value.

    This differs from volume change 1 in the following ways

1) The specified value is the v command level (rough value).
2) The effect is applied only to the v command. (The v command does not change.)
3) Does not increase or decrease the current volume by the specified value when specified.
    (Effective only for the next v command.)

    The following are the three.

[Example 1] v(2)
[Subtracts 2 from the specified value of the v command each time from that part.

[Note: If you use this command twice in the same part, the first command becomes invalid when you specify the second one.
    (There is no relative change. (No relative change is made.) [Related] v command (->)

[Related] v command (->5-1)

===============================================================================
5-5 Relative volume change
    ) (
-------------------------------------------------------------------------------
[Format 1] ) [^] [%] [number] ( [^] [%] [number] )
[Format 2] ( [^] [%] [number] )
-------------------------------------------------------------------------------
[range] 0-255
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,86,PPZ) / R select / R define
-------------------------------------------------------------------------------
    This function changes the volume relative to the specified value.
    If the value is ( ), it will be added, and if the value is ( ), it will be subtracted.

    If a number is omitted, it will be set to 1.

    If a ^ symbol is added, it limits the notes to be changed to only one of the following
    (accent)

    If the % symbol is added, the change is fine (equivalent to the V command), otherwise it is rough.
    If the % symbol is added, the change will be fine (equivalent to a v command), otherwise it will be rough (equivalent to a v command).

[Note: If % is not specified, the volume value will simply be the same as the value specified in the
    For FM sources, 4 times the specified value.
    For PCM sound sources, the value is changed by 16 times the specified value.
    If no % is specified, the volume value is simply changed by 4 times the specified value for FM sources and by 16 times the specified value for PCM sources.

    So, in the FM section and in the PCM section with #PCMVolume set to Extend
    Therefore, in the FM part and in the PCM part with #PCMVolume in Extend state, there will be a deviation from the expected volume value after the change.
[Example 1] v12 c ) c (FM part)
[Result] V117 c V121 c (louder than v13)
[Example 2] v13 c ( c (FM source)
[Result] V119 c V115 c (smaller than v12)

[Related] V command (->5-2)
    v command (->5-1)

===============================================================================
*******************************************************************************
6 [[[[ MML command and tone specification section ]]]]
*******************************************************************************
===============================================================================

    This section contains commands for specifying tone numbers and defining tones.
    This section contains a summary of commands for specifying tone numbers and defining tones.

===============================================================================
6-1 Specifying tone number
    @voice
-------------------------------------------------------------------------------
[Format 1] @[@] Tone number
[Format 2] @[@] Tone number [,Number 1[,Number 2[,Number 3]]]
-------------------------------------------------------------------------------
[Range] Tone number FM, PCM 0 to 255
    Tone number SSG 0 to 9
    Tone number SSG Rhythm 0 to 16383
    Value 1 PCM -32768 to +32767
    Value 2 PCM -32768 to +32767
    Value 3 PCM -32768 to +32767
-------------------------------------------------------------------------------
[Sound Source] FM / SSG / PCM / R Definition
-------------------------------------------------------------------------------
    Thereafter, the voice of the specified voice number is set to be used.
    If @@ is indicated, 128 is added to the tone number.
    (The second PPZFile tone selection convenience)
-------------------------------------------------------------------------------
6-1-1 Specifying tone numbers/FM sound part
-------------------------------------------------------------------------------
    Use the tone number to indicate the tone to be used.

[Example] @1 cde @2 fga
[The tone number 1 will play do-re-mi, and the tone number 2 will play fasola.

[Note: If a slot has been masked with the s command, only the specified slot will be played in that part.
    If a slot is masked by the -s command, voices will be defined only for the specified slot in that part.
    If you use the s command, it is safer to redefine the voices as much as possible.

[Related] s command (->6-2)
    FM tone definition (@) (->3-1)

-------------------------------------------------------------------------------
[Related] s command (->6-2) FM tone definition (@) (->3-1)
-------------------------------------------------------------------------------
    Select one of the 10 SSG software envelopes available in the MML compiler with the tone number.
    The following is a list of SSG software envelopes that are selected and expanded as E commands.

    The expanded contents are as follows.
@0 E0,0,0,0,0 Standard
@1 E2,-1,0,1 Synth type 1
@2 E2,-2,0,1 Synth type 2
@3 E2,-2,0,8 Synth type 3
@4 E2,-1,24,1 Piano type 1
@5 E2,-2,24,1 Piano type 2
@6 E2,-2,4,1 Glocken/Malimba type
@7 E2,1,0,1 Strings type
@8 E1,2,0,1 Brass type 1
@9 E1,2,24,1 Brass type 2
Do not specify @10 or later.

[Example] @6v10l8 cegb>c<gec
[Result] Play CM7 arpeggio with percussion type software envelope.

[Related] E command (->8-1)

-------------------------------------------------------------------------------
6-1-3 Specifying tone number/SSG rhythm definition part (without PPSDRV)
-------------------------------------------------------------------------------
    In the R part, select which of the SSG drum tones defined in the PMD will be used.
    R part selects which of the SSG drum tones defined in the PMD will be used.

    The correspondence between the tone number and the rhythm sound is as follows.
@1 Bass Drum
2 Snare Drum 1
4 Low Tom
8 Middle Tom
@16 High Tom
@32 Rim Shot
@64 Snare Drum 2
@128 Hi-Hat Close
@256 Hi-Hat Open
@512 Crash Cymbal
@1024 Ride Cymbal

    In PMDB2/PMDVA/PMD86, if the /N option (->PMD.DOC) is not specified
    DOC) is not specified, the appropriate sound will be played by the rhythm sound source at the same time.
    In that case, if you add up the values, you can make it sound like several sounds are being played at the same time.
    (SSG rhythms have small numbers. (For SSG rhythmic tones, the tone with the lower number has priority.

[Example 1] @2c
(For SSG rhythm sounds, the lower numbered tone has priority.

[Example 2] @129c
[Result] In case of PMD.COM, @1 bass drum will be played.
    In the case of PMDB2/VA/86, in addition to the above, the hi-hat of the rhythm source will sound at the same time.

-------------------------------------------------------------------------------
6-1-4 In the case of tone number specification/SSG rhythm definition part (with PPSDRV)
-------------------------------------------------------------------------------
    If PDR and PPSDRV are resident, select the SSGPCM tone.

    In addition to the SSG rhythm in 6-1-3, the specified tone numbers are
    In addition to the SSG rhythm voices described in 6-1-3, three additional voices will be added: @2048, @4096, and @8192.

    The relationship between the tone number and the rhythm tone varies depending on the contents of the .PPS file.

    When playing back a PDR in #Double mode, up to two notes can be added at the same time.
    If the PDR is playing in #Double mode, up to two notes can be added simultaneously to create a sound.

[Example] @4c
[The third SSGPCM sound defined in PPS will be played.

-------------------------------------------------------------------------------
6-1-5 Specifying tone number/PCM sound part
-------------------------------------------------------------------------------
    In addition to the tone number, PMDB2/PMDVA/PMD86/PMDPPZ add the tone repeat address setting after it.
    In addition to the tone number, PMDB2/PMDVA/PMD86/PMDPPZ allows you to add a repeat address setting after the tone number. (->6-1 [Format 2])

    Each value can be set to
Value 1 Repeat start position
Numeral 2 End position of repeat (default 0)
Value 3: Release start position (default $8000) *Not valid for PMDPPZ and PMDPPZE.
    A value between -32768 and +32767 can be specified.

    When a positive value (+) is specified for each value, the value is added from the tone start address.
              When a negative value (-) is specified, the value is subtracted from the tone end address.
    When a negative value (-) is specified, the value is subtracted from the tone end address.

    If numeric value 1 is not specified, no repeat setting is made. (One-shot PCM)

    When numerical value 2 is 0 or not specified, the loop is performed from the repeat start position to the tone end address.
    (One-shot PCM)

    When the value 3 is $8000 or not specified, even if the key is turned off, the repeat setting is not made.
    When the value 3 is $8000 or not specified, the loop from the repeat start position to the repeat end position is retained even if the key is turned off.

    Each value can be set to
    PMD86/PMDPPZ: 1 byte unit, PMDB2/PMDVA: 1 byte unit
    In the case of PMDB2/PMDVA, the value is calculated in units of 16 bytes.

    However, if the /S option (->PMD.DOC) is specified for PMD86
    DOC is specified for PMD86, the calculation is made in units of 32 bytes. (This is because 16 bytes of ADPCM corresponds to 32 bytes of PCM.)

    In this case, each value must be within the range of -1024 to +1023, since the value is only multiplied by 32 internally.
    In this case, each value must be within the range of -1024 to +1023.

[Example: PMDB2
    If the size of the tone in @0 is 4000 bytes, then in units of 16 bytes
    If the tone size of @0 is 4000 bytes, the value in 16-byte units would be: tone start address = 0 / tone end address = 250.
J @0,100,-50,-50 g1
    will be played in the following order.
1) Playback from the first position to the +200 (250 -|number 2|) position.
2) Repeat playback from +100 (number 1) to +200 (250 -|number 2|).
3) At the moment the key is turned off, the range from +200 (250 -|number 3|) to +250 is played back.
    The voice ends.

[When repeat playback is performed using ADPCM of YM2608 (PMDB2/PMDVA)
    When repeat playback is performed in ADPCM on the YM2608 (PMDB2/PMDVA), it seems that the predicted voltage difference for the next data is cleared to 0 at the moment of repeat.
    This seems to be a hardware specification and there is nothing I can do about it.

    This is a hardware specification and there is nothing we can do about it.
    In this case, you can change the repeat address.

    In this case, try changing the repeat address in various ways.

    The trick is to use data that was recorded while the desired sound was being played.
    If you use data that was recorded suddenly while the desired sound was being played, and then return to the beginning of the tone when repeating, you can avoid the phenomenon of the sound becoming muffled when repeating.
    In this case, you can adjust the volume of the tone.
    In this case, use a software envelope to express the temporal change in the volume of the tone.
    In this case, use software envelopes to express the temporal changes in tone volume.

    In addition, if you have a tool that allows you to edit the PCM waveform while viewing it, you can use the
    If you have a tool that allows you to view and edit the PCM waveform, you may want to set the start and end of the repeat at a position close to the 0 voltage level and choose a location where the voltage change is quiet.
    If you have a tool that allows you to edit while looking at the PCM waveform, you can set the repeat start and end positions to be close to the 0 voltage range, and select a place where the voltage change is quiet.
    Please try it.

===============================================================================
6-2 Specifying the slot position for FM sound source
    s
-------------------------------------------------------------------------------
[format] s number
-------------------------------------------------------------------------------
[Range] 0 to 15
-------------------------------------------------------------------------------
[Source] FM
-------------------------------------------------------------------------------
    This is mainly used for FM 3ch parts, and specifies the slot position to be used for performance and definition.
    The value indicates the slot used for the part.

    The value specifies the slot to be used for the part.
    slot1 is 1, slot2 is 2, slot3 is 4, and slot4 is 8.
    The value is the sum of the slots used in the part, 1 for slot1, 2 for slot2, 4 for slot3, and 8 for slot4.

    In the FM 3ch part, each slot (there are four) can be played independently.
    Therefore, it is possible to prepare multiple parts.

    Therefore, you can prepare multiple parts and specify the slots to be used with this command.
    If you have more than one part, and use this command to specify which slot to use, you can play a different phrase for each slot.

[Example 1] To divide the ALG4 voices into slot1,2 / slot3,4, use the command
#FM3Extend X
C s3...
X s12...
    X s12....

    After specifying this command, the tone specification command @ (->6-1) will not be used.
    After specifying this command, the tone specification command @ (->6-1) will define only the tone parameters for the slot being used.

    As an exception, FB will only be defined if slot1 is used, and
                ALG is always defined unconditionally.

    Therefore, it is possible to specify different tone numbers for different parts of the same 3-channel FM source part, as long as the ALG value is the same.
    Therefore, as long as the ALG value is the same, it is possible to specify a different tone number for each part of the same FM 3ch part.

    If you specify this command for a part other than the FM3 channel, only that slot will sound.
    If this command is specified for a part other than the FM3 channel, only that slot will be played. (Slot mask operation)
[Note 1] s3 @200cde s15 fga
    but only slot1 and 2 are defined for the @200 tone, so the
    Therefore, the tone of the fga part will be wrong.

[Note 2] The FM sound source 3ch part (C to F when #FM3Extend is not specified in PMD.COM, C part when #FM3Extend is specified and the specified part)
    C part when #FM3Extend is specified, and the specified part when #FM3Extend is specified) should not overlap.
    The operation is not guaranteed if they overlap.

[Note 3] ALG is defined unconditionally.
    For example, if a part using slots 1 and 2 changes to an ALG4 tone while playing in ALG6, the tones in slots 3 and 4 will be incorrect.
    If the part using slots 1 and 2 changes to the ALG4 tone, the tones of slots 3 and 4 will be distorted. Please be very careful.
    However, as for FB, if FB=7 is used in slot1 and 2, and FB=0 is used in slot3 and 4
    If you use a note with FB=7 in slots 1 and 2 and define a note with FB=0 in slots 3 and 4, FB will not be defined, so it will not affect the performance of slots 1 and 2.

[Example 2] In the case of PMD.COM
; nm alg fbl
@202 004 007
; ar dr sr rr sl tl ks ml dt ams Trumpet *2
 013 014 000 003 001 023 002 004 000 000 ;slot1
 019 003 000 010 000 000 001 008 000 000 ;slot2
 013 014 000 003 001 020 002 004 000 000 ;slot3
 019 003 000 010 000 000 001 004 000 000 ;slot4

C s$3 ;slot1,2 only
D s$c ;slot3,4 only
CD @202v12M12,1,8,2*1
C o3l8W12,-2[[a4ga4>c4d4:c4<ba4g4]4:>c4<ab4g4]2>f4fg4 d4
D o3l8W12,-2[[e4ee4 a4b4:a4 ge4e4]4: a4 fg4d4]2>c4cd4<b4

[Result] Algorithm 4 divides one channel into two slots of 2 slots each.
    It makes the chords play.

===============================================================================
6-3 FM sound source TL value setting
    O
-------------------------------------------------------------------------------
[Format 1] O Value 1, Value 2
[Format 2] O Value 1,Value 2
-------------------------------------------------------------------------------
[Range] [Number 1] 1 to 15
    [Number 2] [Format 1] 0 to 127
        [Format 2] -128 to +127
-------------------------------------------------------------------------------
[Source] FM
-------------------------------------------------------------------------------
    Directly sets the TL value of an FM tone.

    This is useful for expressing changes in tone velocity, or for
    It is effective when you want to express human-like wah pedal control, not cyclic like LFO.
    This is useful for expressing human-like wah pedal control.

    The value 1 means that
    slot1 is 1, slot2 is 2, slot3 is 4, and slot4 is 8.
    The total value is specified.

    Value 2 is the TL value to be set.
    If + or - is specified (format 2), the value will change relative to the current value.

[Example 1] O3,10
[If you specify + or - (format 2), the value changes relative to the current value.

[Example 2] O5,-2
[Result] The TL values for slots 1 and 4 are set to -2.

===============================================================================
6-4 FM source FB value setting
    FB
-------------------------------------------------------------------------------
[Format 1] FB Value 1
[Format 2] FB value 2
-------------------------------------------------------------------------------
[Range] [Number 1] 0 to 7
    [Number 2] -7 to +7
-------------------------------------------------------------------------------
[Source] FM
-------------------------------------------------------------------------------
    Directly sets the FB value of the FM tone.

    While the O command controls the TL value, this command controls the FB value.
    Other than that, the usage is also the same as the O command.

    The value to be specified is the FB value to be set.
    When + or - is specified (format 2), the value changes relative to the current value.

[Example 1] FB3
[Sets the FB value of the current FM tone to 3.

[Example 2] FB-2
[Changes the FB value of the current FM tone to -2 from the current value.

===============================================================================
6-5 SSG / OPM tone noise output selection
    P
-------------------------------------------------------------------------------
[Format] P Value
-------------------------------------------------------------------------------
[Range] 1 to 3
-------------------------------------------------------------------------------
[Source] FM(OPM) / SSG
-------------------------------------------------------------------------------
    The H-part of FM(OPM) slot4 and the SSG sound source's tonal and noise output are selected.

The SSG tone pads are specified as follows
    1 tone (diflter)
    2 noise
    3 tone + noise

 FM tone (OPM) H-pattern
    1 tone (dif)
    2 noise

[Example 1] P3 (SSG sound source)
[Result] It is a mix of tone and noise.

===============================================================================
6-6 Nos. of perimeter wave setting
    w
-------------------------------------------------------------------------------
[Book 1] w value
[Book 2] w  value
-------------------------------------------------------------------------------
[Range] [Book 1] 0 to 31
    [Book 2] -31 to +31
-------------------------------------------------------------------------------
[Audio Source] FM(OPM) / SSG
-------------------------------------------------------------------------------
    The percussion number of the H-pattern slot4 of FM (OPM) and SSG sound source is set.

    The higher the value, the lower the frequency.

    If + or - is indicated, the value will change relative to the current value.

    Even if you set the frequency with this, the noise will not sound unless the noise is turned on with the P command.
    The noise will not sound.

[Note: If SSG sound effects such as SSG drums are being played when this command is executed in the SSG sound part, the sound will not be heard.
    If SSG sound effects such as SSG drums are being played when this command is executed in the SSG sound source part, it will not be set on the spot, but will be set at the first key on after the sound is finished.
    If SSG sound effects such as SSG drums are being played, they will not be set on the spot, but will be set at the first keyon after the sound is finished.

    Until then, it is affected by the change in noise frequency of the SSG sound effect.
    If at all possible, it is better to use SSG noise only in the I part, where it is eliminated by the SSG sound effect.
    It is safer to use SSG noise only in the I-part, where it is eliminated by the SSG sound effect.

[Example 1] w31
[Sets the noise frequency to 31, the lowest possible value.

[Related] P command (->6-5)

===============================================================================
6-7 Rhythm pattern selection and performance
    R
-------------------------------------------------------------------------------
[Format] R Numeric
-------------------------------------------------------------------------------
[Range] 0 to 255
-------------------------------------------------------------------------------
[Source] R Select
-------------------------------------------------------------------------------
    By using the rhythm definition part (R), the rhythm pattern defined for the specified numeric number will be played.
    The rhythm pattern defined by the rhythm definition part (R) will be played.

[Example] R0R0R0R1
[This will play the pattern of R0 three times and the pattern of R1 once.

[Related topics] Using the rhythm part (K/R) (->1-2)

===============================================================================
*******************************************************************************
7 [[[[ MML command detuning part ]]]]
*******************************************************************************
===============================================================================

    This section contains descriptions of the detuning command, which allows you to make subtle changes to the pitch of a note.
    The explanation is summarized here.

===============================================================================
7-1 Detuning settings
    D DD
-------------------------------------------------------------------------------
[Format 1] D value
[Format 2] DD value
-------------------------------------------------------------------------------
[range] -32768 to +32767
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,86,PPZ)
-------------------------------------------------------------------------------
    Set the detuning value (the value to shift the frequency).

    The D command specifies the absolute detuning value, and the DD command specifies the current detuning value.
    The DD command changes the detuning value relative to the current detuning value.

    The default detuning value is 0.

    In the case of the SSG sound source, the #Detune or DX command will change the effect of the same value.
    In the case of SSG instruments, the #Detune or DX command will change the effect of the same value.

    In the #Detune Normal or DX0 state, the value output to the FM source LSI is left unchanged.
    In the #Detune Normal or DX0 state, the value output to the FM sound source LSI is shifted by, for example, +1 for +1.

    #In the "Detune Extend" or "DX1" state, the same value is shifted by the same amount in any octave.
    In the #Detune Extend or DX1 state, if the value is the same in any octave, it will be shifted by the same amount. However, if the value is not zero (e.g., D1), it will always be off by at least 1.
    However, if the value is not zero (e.g. D1), the value will always be off by at least one.

    In the case of a PCM or FM sound source, the pitch value is added to or subtracted from the pitch value given to the FM sound source LSI.
    In the case of a PCM or FM sound source, it is added to or subtracted from the pitch value given to the FM source LSI.

    If the DM command (7-6) is specified, the master detuning value and the detuning value specified here will be added or subtracted.
    If the DM command (7-6) is specified, the master detuning value and the detuning value specified here are added together and set.

[Example].
G D0 v13 o5g1
H D1 v13 o5g1
[The G part and the H part will be pronounced with slightly different frequencies overlapping each other.

[Note: By executing the DD command, the detuning value may exceed +32767 or fall below -32768.
    This command does not check if the detuning value exceeds +32767 or falls below -32768.

[Related] DX command (->7-3)
    #Detune command (->2-16)
    DM command (->7-6)

===============================================================================
7-2 Specifying the detune for each slot of the FM sound source 3ch part
    sd sdd
-------------------------------------------------------------------------------
[Format 1] sd slot number , number
[Format 2] sdd slot number , number
-------------------------------------------------------------------------------
[Range] slot number 1 to 15
    Numeric -32768 to +32767
-------------------------------------------------------------------------------
[Source] FM(3ch)
-------------------------------------------------------------------------------
    This command can be used to specify only the 3-channel FM sound source part, and sets the detuning value for each slot.

    The sd command specifies the absolute detuning value, and the sdd command specifies the current detuning value.
    The sd command specifies the detuning value absolutely, while the sdd command changes the value relative to the current detuning value.

    The slot number is used to specify the slot, and the numeric value is used to specify the detuning value.

    The slot number is 1 for slot1, 2 for slot2, 4 for slot3, 8 for slot4, and so on.
    The total value is specified.

    It is also possible to use this command together with the D command.
    In this case, the detuning value of the D command is added to or subtracted from all slots used in the specified part.
    In that case, the detuning value of the D command will be added to or subtracted from all slots used by the specified part.

    By default, all slots are set to 0.

[Note: The same value is used for all 3-channel FM parts.
    For example, in PMD.COM, while playing Slot1,2 in C part and Slot3,4 in D part
    If you set sd8,+10 in the C part, Slot4 of the tone being played in the D part will be detuned by
    +In order to avoid this problem, it is recommended to use the following method.

    To avoid this problem, do not specify sd for any other slot than the one being played.
    To avoid such a phenomenon, do not specify any sd other than the performance slot. To avoid this, do not specify sd for slots other than the performance slot.
    If you want to change the playing slot in the middle of a song, you need to set the detuning value of the slot that will no longer be played back to 0.
[For example: sd6,-4
[Result] Slots 2 and 3 will be detuned by -4.

[Related] s command (->6-2)
    D DD command (->7-1)

===============================================================================
[Related] s command (->6-2) D DD command (->7-1)
    DX
-------------------------------------------------------------------------------
[Format] DX Value
-------------------------------------------------------------------------------
[Range] 0 to 1
-------------------------------------------------------------------------------
[Source] SSG
-------------------------------------------------------------------------------
    Selects whether or not to correct the pitch of the SSG sound source.

    If the value is 0, the pitch value sent to the sound source will always be shifted by 1 when using DETUNE/LFO.
    If the value is 0, the pitch value sent to the sound source will always be shifted by 1 when the DETUNE/LFO is used. (Even with the same DETUNE value, the higher the range, the larger the shift.)

    If the value is set to 1, the shift will become smaller as you go to higher registers, and the same DETUNE/LFO value will be sent to the sound source.
    If the value is set to 1, the shift will become smaller as you go up in the higher register, and the same DETUNE/LFO value will cause the shift to be about the same for all notes.

    This is the same function as #Detune, but it can be changed for each part.
    The default value is 0.

[Example: DX1
[Result] Corrects the subsequent detune value for each note.

[Related] #Detune command (->2-16)
    D DD command (->7-1)
    M MA MB command (->9-1)

===============================================================================
7-4 Bend width setting
    B
-------------------------------------------------------------------------------
[Format] B Value
-------------------------------------------------------------------------------
[Range] 0 to 255
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,86,PPZ)
-------------------------------------------------------------------------------
    Sets a MIDI-like bend width. Similar to #Bendrange.
    Can be set from 0 to 255 in semitone units.

    Writing a non-zero value will activate the I command.

    This value is carried over from part to part.
    For example, if you set only B12 in part C, the bend width will not be set in part AB.
    For example, if you set only B12 in part C, the bend width will not be set in part AB, but it will be set in all parts after part C (CDEFGHIJ + #FM3Extend parts).
    (CDEFGHIJ + #FM3Extend).
    However, if you set it to #Bendrange, it is valid for all parts.

[Note: Once the bend width is set, the cautions described in the I command (->7-5) become effective.
    In addition, MML becomes very difficult to read, so it is best not to use it except when converting from MIDI data.

[Example] B12
[Bend range is set to be exactly one octave off at I 8192.

[Related] #Bendrange command (->2-15)
    I command (->7-5)

===============================================================================
7-5 Pitch setting
    I
-------------------------------------------------------------------------------
[Format] I Numeric
I -------------------------------------------------------------------------------
[Range] -32768 to +32767
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,86,PPZ)
-------------------------------------------------------------------------------
    Sets a MIDI-like PITCH value.

    The frequency is shifted by a bend width of 8192.

    It is disabled unless you set the bend width with the #Bendrange or B command.
    Disabled.

[Note 1] The pitch setting is accurate only for FM sound sources.
    The SSG/ADPCM parts will be pitched up or down to a certain degree, but it is safer not to use them.

[Note 2] When the bend width is set and this command is enabled, the PITCH/DETUNE value will be set to "0".
    The PITCH/DETUNE value will be set only after the next pitch command.

[Example 1]
A B2I0[cdeI8192fga]2
[Result]
A B2[I0cdeI8192fga]2
    The result is the same as

    Also, the "D" command is affected in the same way.
[Example 2]
If you use A B0D10[cdeD0]2, it will be the same as
[Result]
A D10 cdeD0 cdeD0 cdeD0 will be played, but

[Example 3]
A B2D10[cdeD0]2 would be.
[Result] A D10cdeD0
A D10cdeD0 D10cdeD0 will be played, so please be careful.

[Example 4]
A B12o4l8 I0cI1000cI2000cI3000cI4000cI5000cI6000cI7000cI8192c
[Result] Gradually increase the pitch from c in octave 4 to c in octave 5.

[Related] #Bendrange command (->2-15)
    B command (->7-4)
    D DD command (->7-1)

===============================================================================
7-6 Master detuning settings
    DM
-------------------------------------------------------------------------------
[format] DM value
-------------------------------------------------------------------------------
[range] -32768 to +32767
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,86,PPZ)
-------------------------------------------------------------------------------
    This command sets the master detuning value for each part.

    When this command is recognized, the detuning setting is made immediately, and then the detuning value is set for each part.
    When this command is recognized, the detuning setting is made immediately, and the specified value is increased or decreased to the detuning value by the D command after this.
    When this command is recognized, the detuning setting is made immediately, and the detuning value by subsequent D commands will be set to increase or decrease the specified value.

[Related] D DD command (->7-1)

===============================================================================
*******************************************************************************
8 [[[[ MML command envelope section ]]]]
*******************************************************************************
===============================================================================

    This section describes the software envelope commands that change the sound of SSG/PCM.
    related commands that change the SSG/PCM sound.

===============================================================================
8-1 SSG/PCM software envelope specification
    E
-------------------------------------------------------------------------------
[Format 1] E Number 1 , Number 2 , Number 3 , Number 4
[Format 2] E Number 1 , Number 2 , Number 3 , Number 4 , Number 5 [, Number 6]
-------------------------------------------------------------------------------
[Source] SSG / PCM(AD,86,PPZ)
-------------------------------------------------------------------------------
[Range] [Format 1] Number 1 0 to 255
        Value 2 -15 to +15
        Value 3 0 to 255
        Number 4 0 to 255

    [Format 2] Number 1 0 to 31
        Number 2 0 to 31
        Number 3 0 to 31
        Number 4 0 to 15
        Number 5 0 to 15
        Number 6 0 to 15
-------------------------------------------------------------------------------
    Sets the software envelope. (Only for SSG/ADPCM part of OPN/OPNA)
    Two types of envelopes can be selected. However, they cannot be used simultaneously.

    If 4 numbers are specified, it is treated as format 1, and if 5 or 6 numbers are specified, it is treated as format 2.
    If the number is 4, it is treated as format 1.

    When using #Envelopespeed Normal or EX0, the speed depends on the tempo.
    When #Envelopespeed Extend or EX1 is used, the speed is constant.

-------------------------------------------------------------------------------
8-1-1 Software envelope specification/format 1
-------------------------------------------------------------------------------
    This is PMD's original simple envelope specification method.

    Value 1 = Attack Length (AL)
    Value 2 = Decay Depth (DD)
    Value 3 = Sustain Rate (SR)
    Number 4 = Release Rate (RR)

    #For Envelopespeed Normal or EX0, 1 clock = 1 internal clock.
    #For Envelopespeed Extend or EX1, 1 clock = approximately 56 Hz.
    The settings will change as follows: 1.

1. after Keyon, wait for AL clock minutes at the set volume, then
    Then add or subtract DD to the volume. 2.

After that, DD is added or subtracted to the volume. 2. every SR clock, the volume is reduced by -1. 3.

After the key is turned off, the volume is adjusted by -1 for each RR clock.

    When SR = 0, no volume decay is applied in step 2.
    When RR = 0, the volume goes to 0 at once when 3.

[Example] C96 EX0 E1,-2,2,1 v13 l16 gr
[The volume will change as follows.
    13 11 11 9 9 7 7 6 5 4 3 2
    keyon keyoff

-------------------------------------------------------------------------------
8-1-2 Software envelope specification/format 2
-------------------------------------------------------------------------------
    The specification method is almost the same as for FM sound sources.

    Value 1 = Attack Rate (AR)
    Value 2 = Decay Rate (DR)
    Value 3 = Sustain Rate (SR)
    Value 4 = Release Rate (RR)
    Number 5 = Sustain Level (SL)
    Number 6 = Attack Level (0 when omitted)

    Attack Level specifies the level at which the attack begins.

    Note that similar does not mean identical in terms of speed.
    Especially in the case of #Envelopespeed Normal or EX0, the speed depends on the tempo.

    For more information about the meaning of the parameters, please refer to the manual of the FM sound source.

[Example: E31,18,4,15,2
[This sets the envelope for the piano type.

-------------------------------------------------------------------------------

[Related] #Envelopespeed command (->2-18)
    EX command (->8-2)

===============================================================================
8-2 Software envelope speed setting
    EX
-------------------------------------------------------------------------------
[format] EX value
-------------------------------------------------------------------------------
[Range] 0 to 1
-------------------------------------------------------------------------------
[Source] SSG / PCM(AD,86,PPZ)
-------------------------------------------------------------------------------
    When the value is 1, the envelope by the E command is changed to an extended specification that makes the speed constant and independent of the tempo.
    If the value is 1, the envelope of the E command is changed to a constant speed independent of the tempo.

    If the value is 0, it depends on the tempo. (The slower the tempo, the slower the envelope.)

    This is the same function as #EnvelopeSpeed, but if you specify it here, you can change it for each part.
    The default is 0.

    The default value is 0.

[Example: EX1
[The envelope of the specified part is made independent of the tempo from there.

[Related] #Envelopespeed command (->2-18)
    E command (->8-1)

===============================================================================
*******************************************************************************
9 [[[[ MML command and LFO section ]]]]
*******************************************************************************
===============================================================================

    This section summarizes LFO (Low Frequency Oscillator) related commands.
    LFO (Low Frequency Oscillator) related commands.

    LFOs are used to change the pitch/volume of FM/SSG/PCM and the TL value of FM sources over time.
    LFO is mainly used for vibrato (pitch), tremolo (volume), and wah-wah (TL).
    By changing the pitch/volume of the FM source and the TL value of the FM source over time, it is possible to create vibrato effects for pitch, tremolo effects for volume, and wah-wah effects for TL value.

    In addition, various waveforms are available, especially random waves, which are useful for processing sound effects.
    In particular, random waves are useful for processing sound effects.
===============================================================================
9-1 Software LFO specification
    M MA MB
-------------------------------------------------------------------------------
[Format 1] M Number 1
[Format 2] M Sound length [.].
[Format 3] M Number 1 , Number 2 , Number 3 , Number 4
[Format 4] M l tone length[.] , Numeral 2 , Numeral 3 , Numeral 4
[Format 5] MA Number 1
[Format 6] MA l tone length [.]
[Format 7] MA Number 1 , Number 2 , Number 3 , Number 4
[Format 8] MA l tone length [.] , Numeral 2 , Numeral 3 , Numeral 4
[Format 9] MB Number 1
[Format 10] MB l tone length [.].
[Format 11] MB Number 1 , Number 2 , Number 3 , Number 4
[Format 12] MB l tone length [.] , Number 2 , Number 3 , Number 4
-------------------------------------------------------------------------------
[Range] [Number 1] 0 to 255
    [Number 2] 0 to 255
    [Number 3] -128 to +127
    [Number 4] 0 to 255
    [Note length] The value between 1 and 255 that is approximately the length of all notes.
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,PPZ)
-------------------------------------------------------------------------------
    Specifies a software LFO.

    PMD has two software LFOs, which can be used independently of each other.
    PMD has two software LFOs, each of which can be used independently.
    Use M or MA to select the first LFO (LFO1), and use MB to select the second LFO (LFO2).
         MB specifies the second LFO (LFO2).

    The values to be specified are as follows

    Number 1 = delay
    Number 2 = speed
    Number 3 = depthA
    Value 4 = depthB

    If only delay is specified by itself, only the current delay value will be changed.

    The delay is set by the sound length when l is added, or by the internal clock value when l is not added.
    If not, it is set by the internal clock value.

    LFO speed can be set by
    #The LFO speed depends on the tempo when using LFOSpeed Normal or MX0.
    The LFO speed depends on the tempo in the case of #LFOSpeed Normal or MX0, and is constant in the case of #LFOSpeed Extend or MX1.

    The LFO waveform depends on the one specified by the MW command.
    Depending on the waveform, each number will have a slightly different meaning.

    #LFOSpeed Normal or MX0: 1 clock = 1 internal clock
    In the case of #LFOSpeed Extend or MX1, 1 clock = about 56 Hz.
    In the case of #LFOSpeed Normal or MX0, 1 clock = 1 internal clock.

    In the following explanation, each MX MW * command changes the specified LFO.
    In the following explanation, each MX MW * command should be taken as a command to change the specified LFO (MXB MWB *B for MB).

-------------------------------------------------------------------------------
9-1-1 Software LFO specification/MW0 (Triangle wave 1)
-------------------------------------------------------------------------------
1) After key on, wait for delay clock.
2) For each speed clock, add depthA to the amount of change in pitch/volume.
3) Repeat 2) for depthB times, or infinite times if 255 is set.
4) Invert depthA positively or negatively, doubling depthB the first time it is inverted.
5) Return to 2).

[D / backslash
        D / backslash
        D /  /  / 
0 ------------ backslash------------/--  
 A B C backslash
                A B C
                B

A to B (length) : delay (parameter 1)
B to C (length) : speed  depthB (Parameter 2  Parameter 4)
B to D (depth) : depthA  depthB (Parameter 3  Parameter 4)

-------------------------------------------------------------------------------
9-1-2 Software LFO specification/MW1 (sawtooth wave)
-------------------------------------------------------------------------------
1) After key on, wait for delay clock.
2) For each speed clock, add depthA to the amount of change in pitch/volume.
3) Repeat 2) for depthB times, or infinite times if 255 is set.
4) Invert the pitch/volume change positively or negatively, and multiply depthB by 2 the first time it is inverted.
5) Return to 2).

[Image] D / / /
        / / / /
        / / / /
0 ------------/------------/--  
 A B C    
              A B C
              A to B (length)

A to B (length) : delay (parameter 1)
B to C (length) : speed  depthB (parameter 2  parameter 4)
B to D (depth) : depthA  depthB (Parameter 3  Parameter 4)

-------------------------------------------------------------------------------
9-1-3 Software LFO specification/MW2 case (square wave)
-------------------------------------------------------------------------------
1) After the key is turned on, wait for the delay clock.
2) Set the amount of change in pitch/volume as depthA x depthB. 3) Wait for 255 clocks.
3) Wait for the speed clock. 255 means no change.
4) Invert the amount of change in pitch/volume.
5) Return to 3).

[Image] D 

0   ------------------------------ 
 A B C

             .

A to B (length) : delay (parameter 1)
B to C (length) : speed (parameter 2)
B to D (depth) : depthA  depthB (Parameter 3  Parameter 4)

-------------------------------------------------------------------------------
9-1-4 Software LFO specification/MW3 (random wave)
-------------------------------------------------------------------------------
1) After the key is turned on, wait for the delay clock.
2) Set the amount of change in pitch/volume to a random value between 0 and (depthA x depthB).
If the value is 255, it will remain unchanged.
4) Return to 2).

[Image] D...
                    ... ...
        D... ...
0 --------------------------  0
 A B C
                A B C
        ... ... ... ...

A to B (length) : delay (parameter 1)
B to C (length) : speed (parameter 2)
B to D (depth) : 0 to ( depthA  depthB )
        ( 0 to (parameter 3  parameter 4) )

-------------------------------------------------------------------------------
9-1-5 Software LFO specification/MW4 case (Triangle wave 2)
-------------------------------------------------------------------------------
1) After key on, wait for delay clock.
2) For each speed clock, add depthA to the amount of change in pitch/volume.
3) Repeat 2) for depthB times, or infinite times if 255 is set.
4) Invert depthA positively or negatively; unlike MW0, depthB is not changed here.
5) Return to 2).

[D /  /  /  / 
        /  /  /  /  /  /  / 
        D / backslash / backslash / backslash / backslash / backslash / backslash
0 ------------------------------ 
 A B C

A to B (length) : delay (parameter 1)
B to C (length) : speed  depthB (Parameter 2  Parameter 4)
B to D (depth) : depthA  depthB (Parameter 3  Parameter 4)

[In MW0 triangle wave 1, the range is -(depthA  depthB) to +(depthA  depthB).
    In MW4, the range is 0 to +(depthAdepthB).

    This triangle wave 2 is mainly useful for volume LFO (tremolo/wah-wah).
    This triangle wave 2 is useful mainly for volume LFOs (tremolo/wah-wah).
    For pitch LFOs, it can be used to simulate the movement of a guitar arm.

-------------------------------------------------------------------------------
9-1-6 Software LFO specification/MW5 (Triangle wave 3)
-------------------------------------------------------------------------------
1) After the key is turned on, wait for the delay clock.
2) For each speed clock, add depthAdepthA to the amount of change in pitch/volume.
3) Repeat 2) for depthB times, or infinite times if 255 is set.
4) Invert depthA positively or negatively, and when it is inverted for the first time, multiply depthB by 2.
5) Return to 2).

[D / backslash
        D / backslash
        D /  /  / 
0 ------------ backslash------------/--  
 A B C backslash
                A B C
                B C
A to B (length) : delay (parameter 1)
B to C (length) : speed  depthB (Parameter 2  Parameter 4)
B to D (depth) : depthA  depthA  depthB
        (Parameter 3  Parameter 3  Parameter 4)

[Supplement] Deeper triangle wave.

[Note: The possible range of the LFO variation is -32768 to +32767.
    In order to reduce the processing time, there is no check when the range is exceeded.
    Please note that there is no check when this range is exceeded.

[Example] M0,1,32,64 MW5 *1
    In the above example, the number of clocks changes by 32 x 32 = 1024 per 1 clock.
    However, since 32768/1024 = 32 clocks equals +32768, playing a note longer than that will cause the note to be played backwards.
    If you play a note longer than that, the sound will be turned inside out.

-------------------------------------------------------------------------------
9-1-7 Software LFO specification/MW6 (one-shot)
-------------------------------------------------------------------------------
1) After the key is turned on, wait for the delay clock.
2) For each speed clock, add depthA to the amount of change in pitch/volume.
3) Repeat 2) for depthB times, or infinite times if 255 is set.
3) Repeat 2) for depthB times, or infinitely if 255 is set. 4) Continue to maintain the state after the repetition is complete.

[image] D / 
        D /
        [Image] D
0 ------------------------------  A B C
 A B C

A to B (length) : delay (parameter 1)
B to C (length) : speed  depthB (Parameter 2  Parameter 4)
B to D (depth) : depthA  depthB (Parameter 3  Parameter 4)

[This is useful when you want to use a volume LFO to temporarily change the sustained tone to a decaying tone.
    Also, depending on how you use it, it may be useful for trumpets.
    Also, depending on how you use it, it can be used to create a fade-in effect after a trumpet sound.
    It can also be used to create a fade-in effect after trumpet sounds.

-------------------------------------------------------------------------------

[Note 1] This command only specifies a value, not the actual LFO.
    * This command only specifies a value, not the actual LFO.
    However, this does not apply if LFO has already been turned on.

[Note 2: If you process this command, you will not be able to use the keyon asynchronous LFO switch.
    LFO switch is set, the previous LFO will be initialized and the next note will have a delay value of
    The next note will be affected by the delay value.

[Example] MW0 M24,1,8,2 *1
[The result is a triangle wave LFO with delay 24, speed 1, and depth 8 x 2 as the first LFO.
    [Result

[Related] #LFOSpeed command (->2-17)
    MX MXA MXB command (->9-5)
    MW MWA MWB command (->9-2)
    * *A *B command (->9-3)

===============================================================================
9-2 Software LFO waveform specification
    MW MWA MWB
-------------------------------------------------------------------------------
[Format 1] MW value
[Format 2] MWA value
[Format 3] MWB Numeric
-------------------------------------------------------------------------------
[Range: 0 to 5
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,PPZ)
-------------------------------------------------------------------------------
    Sets the LFO waveform.

    MWA/MWB are the settings for LFO1 and LFO2 respectively.
    MW is equivalent to MWA.

    The values to be specified are as follows. For the actual value, see the explanation of the M MA MB command.
    Refer to the explanation of the M MA MB command.

    0 Triangle wave 1 (default)
    1 Sawtooth wave
    2 Square wave
    3 Random wave
    4 Triangular wave 2
    5 Triangular wave 3
    6 One-shot

[Example] MW2
[The software LFO1 from there is assumed to be a square wave.

[Related] M MA MB command (->9-1)

===============================================================================
9-3 Software LFO switch
    * *A *B
-------------------------------------------------------------------------------
[Format 1] * Numeric 1[,Numeric 2].
[Format 2] *A Numeric 1[,[B] Numeric 2]
[Format 3] *B Number 1[,A Number 2].
-------------------------------------------------------------------------------
[range] 0 to 7
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,PPZ)
-------------------------------------------------------------------------------
    Controls software LFO on/off and keyon synchronization.

    By default, the number 1 controls LFO1, and the number 2 (optional) controls LFO2.
    However, you can change the target by adding an A or B symbol after the * or ,.
    The meanings of the values are as follows

    The meanings of the specified values are as follows.

    Value = 0 Turn off LFO (default)
    Value=1 Pitch LFO on, keyon sync
    Value=2 Volume LFO on, keyon sync
    Value=3 Pitch & volume LFO on, keyon sync
    Value=4 Turn off LFO
    Value=5 Turn on pitch LFO, do not sync to keyon
    Value=6 Volume LFO on, no keyon sync
    Value=7 Turn on pitch and volume LFOs, do not sync to keyon

[Example 1] *1
[Result] The target of LFO1 is set to ON for pitch and keyon sync.
    There is no effect on LFO2.

[Example 2] *0,2
[Result] LFO1 is turned off and LFO2 is turned on by volume and keyon sync.

[Example 3] *B5
[Result] Turns on LFO2 with pitch and keyon asynchronous.
    There is no effect on LFO1.

[Note 1] When applying a volume LFO to an FM source, the actual LFO variation value applied to the TL is inverted.
    When the volume LFO is applied to an FM source, the actual LFO variation value applied to the TL is inverted. Therefore, if the LFO is +, the volume will be increased (TL value will be decreased).
    When the LFO is +, the volume goes up (TL value goes down). Please note that the same applies to the wah-wah effect by changing the target SLOT.
    Please be careful.

[Note 2] The PCM(86) part does not apply the pitch LFO.

[Note 3] The rhythm (K/R) part is a PDR operation mode control command.

[Note 4] The same LFO parameters (set by the M MA MB command) are used for both pitch LFO and volume LFO.
    (set by the M MA MB command). If you want to use different parameters at the same time, use the
    If you want to use different parameters at the same time, use them separately in LFO1/LFO2.

[Note 5] If you specify duplicate parameters such as *B1 and B2, the previous B1 part is ignored and the meaning becomes the same as *B2.
    [Note 5] If you specify duplicate values such as *B1 and B2, the preceding B1 part is ignored and becomes the same as *B2.

[Related] M MA MB command (->9-1)
    * command (PDR operation mode control, ->15-2)

===============================================================================
[Related] M MA MB command (->9-1) * command (PDR operation mode control, ->15-2)
    MM MMA MMB
[Format 1] MM slot number
[Format 2] MMA slot number
[Format 3] MMB slot number
-------------------------------------------------------------------------------
[Range] 0 to 15
-------------------------------------------------------------------------------
[Source] FM
-------------------------------------------------------------------------------
    Sets the slot number that reflects the effect of the software LFO, effective only for FM sound parts.
    Set the slot number to reflect the effect of the software LFO.

    For FM3ch parts, both pitch and volume LFOs are specified.
    For all other FM channels, only the volume LFO is specified.

    MMA sets LFO1, MMB sets LFO2.
    MM is the same as MMA.

    The value to be specified is the total value, where slot1 is 1, slot2 is 2, slot3 is 4, and slot4 is 8.
    The total value is set.

    For example, if you want LFO to be applied to slots 2 and 4, specify MM10.

    If you specify 0, the effect of
    The effect of the volume LFO is reflected in the slot at the carrier position of the tone.
    The effect of the pitch LFO is reflected in all slots.
    (default). (default)

[Example: MM3
[The effect of LFO1 will be reflected in slot1 and slot2.

The effect of LFO1 will be reflected in slot1 and slot2. [Note] If non-zero is specified, this value will remain unchanged even if the tone is changed.

===============================================================================
9-5 Software LFO speed setting
    MX MXA MXB
-------------------------------------------------------------------------------
[Format 1] MX Numeric
[Format 2] MXA numeric
[Format 3] MXB numeric
-------------------------------------------------------------------------------
[Range] 0 to 1
-------------------------------------------------------------------------------
[Sound source] FM / SSG / PCM(AD,PPZ)
-------------------------------------------------------------------------------
    When n is 1, LFO is changed to a constant speed independent of tempo by M MA MB command.
    If n is 1, the LFO is changed to a constant speed independent of tempo by the M MA MB command.

    MXA is set to LFO1, and MXB is set to LFO2.
    MX is the same as MXA.

    MXA is equivalent to MXA. 0 is tempo-dependent; slower tempo means slower LFO.

    #This is the same function as LFOSpeed, but if you specify it here, you can change it for each part and each LFO.
    The default is 0.

    The default value is 0.

[Example: MXB1
The default value is 0. [Result] LFO2 will be set to a tempo-independent speed.

[Related] #LFOSpeed command (->2-17)
    M MA MB command (->9-1)

===============================================================================
[Related] #LFOSpeed command (->2-17) M MA MB command (->9-1)
    MP MPA MPB
-------------------------------------------------------------------------------
[Format 1] MP Number 1[,Number 2[,Number 3]]
[Format 2] MP Number 1[,l-note length[.] [,numeric3]]
[Format 3] MPA Number 1[,Number 2[,Number 3]]
[Format 4] MPA Number 1[,l-note length[.] [,numeric3]]
[Format 5] MPB Number 1[,Number 2[,Number 3]]
[Format 6] MPB Number 1[,l-note length[.] [,numeric3]]
-------------------------------------------------------------------------------
[Range] [Number 1] -128 to +127
    [Number 2] 0 to 255
    [Number 3] 0 to 255
    [Note length] 1-255, which is approximately the length of all notes.
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,PPZ)
-------------------------------------------------------------------------------
    Select an ascending/descending type software LFO and turn the LFO on.

    MPA is set to LFO1, MPB is set to LFO2.
    MP is equivalent to MPA.

    Value 1 = depth
      Numeric 2 = delay (default: 0)
      Value 3 = speed (default: 1)

    The delay value is set by the sound length when l is added, or by the internal clock value when it is not added.
    If not, it is set by the internal clock value.

    In practice, it is the same as MA (or MB) number 2, number 3, number 1, 255 *1.

[Example: MP-80
[Result] Set up a descending LFO for the drum part, etc.

[Note: Since you are simply issuing the M and * commands, you can use the MW MWA MWB command to create a rectangle.
    Note] Since this command simply issues M and * commands, it will not work properly when square wave or random wave is selected by the MW MWA MWB command.
    If square wave or random wave is selected by MW MWA MWB command, it will not work properly.

[Related] M MA MB command (->9-1)
    *A *B command (->9-3)
    MW MWA MWB command (->9-2)

===============================================================================
9-7 Setting the temporal variation of the LFO depth
    MD MDA MDB
-------------------------------------------------------------------------------
[Format 1] MD Number 1[,Number 2[,Number 3]]
[Format 2] MDA Numeric 1[,Numeric 2[,Numeric 3]]
[Format 3] MDB Numeric 1[,Numeric 2[,Numeric 3]]
-------------------------------------------------------------------------------
[Range] [Number 1] 0 to 255
    [Number 2] -128 to +127
    [Number 3] 0 to 127
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,PPZ)
-------------------------------------------------------------------------------
    Sets the temporal variation of the LFO depth (depthA).

    This allows you to create LFOs that get deeper and deeper, or conversely, LFOs that get shallower and shallower.
    The MDA sets LFO1, MFO2, and MFO3.

    MDA sets LFO1, and MDB sets LFO2.
    MD is the same as MDA.

      Value 1 = speed
    Value 2 = depth (+ is optional)
    Numeric 3 = time ( 0 for infinite cycles)

    For each speed cycle of the LFO, depthA is changed (depth), and the change is repeated for time.
    The change is stopped.

    Regardless of the sign of the LFO's depthA, the depth value changes to a deeper direction with + and to a shallower direction with -.
    When the value 1 is 0, the time is stopped.

    When the value 1 is 0, no temporal change is assumed.

    The value 2 can be omitted only when the value 1 is 0. (It will be 0).

    If number 3 is omitted, the value will be 0 (infinite times).

    The LFO cycle is defined as +1 cycle at the following timing.
    In the case of one-shot LFO, there is no cycle, so it does not change. 1.

In case of triangle wave
    When the LFO change amount becomes 0. 2.

Sawtooth wave and square wave
    When the LFO change amount becomes positive or negative. 3.

Random wave
    When the LFO change amount changes.

[Example 1] MD2,1
[Result] In LFO2 cycle, increase depthA by 1 and keep it until KEYOFF.

[Example 2] MD3,2,4
[Result] In LFO3 cycle, increase depthA by 2 and repeat 4 times.

[Related] M MA MB command (->9-1)

===============================================================================
9-10 Hardware LFO speed and delay settings
    H
-------------------------------------------------------------------------------
[Format 1] H Number 1[,Number 2][,Number]]
[Format 2] H Number 1[,Number 2][,l-note length [.]]
-------------------------------------------------------------------------------
[Range] [Number 1] 0 to 7
    [Number 2] 0 to 3
    [Number 3] 0 to 255
    [Note length] 1-255, which is the number of notes in the range.
-------------------------------------------------------------------------------
[Source] FM(OPNA,OPM)
-------------------------------------------------------------------------------
    Set the PMS and AMS of the hardware LFO. (Only for OPNA/OPM FM sound source)

    Value 1 = PMS (speed to pitch)
    Value 2 = AMS (speed to volume)
    Value 3 = Delay (time from keyon to hang, equivalent to the #D command)

    If AMS is omitted, it is set to 0.
    Delay is not set if omitted. (The previous value will be retained.)

    In order to actually start LFO, it is necessary to set the depth using the #/## command.

[Note: In OPNA, even if the hard LFO of the ## command is off, if you increase the AMS, the volume of that part will decrease.
    In OPNA, when the hard LFO of the # command is off, but the AMS is turned up, the volume of that part seems to get lower.
    Therefore, if you want to turn off the LFO completely when using AMS, specify #0H0.
    If you want to turn off the LFO completely when using AMS, specify #0H0.

[Example: H6,2,l4
If you want to turn off the LFO completely when using AMS, specify #0H0. [Example] H6,2,l4 [Result] Set hardware LFO PMS to 6, AMS to 2, and delay to quarter note length.

[Related] # command (->9-11)
    ## command (->9-12)
    #D command (->9-13)

===============================================================================
9-11 Hardware LFO switch, depth setting (OPNA).
    #
-------------------------------------------------------------------------------
[format] # Number 1[,Number 2].
-------------------------------------------------------------------------------
[Range] [Number 1] 0 to 1
    [Number 2] 0 to 7
-------------------------------------------------------------------------------
[Source] FM(OPNA)
-------------------------------------------------------------------------------
    Sets the hardware LFO on/off. (Only for OPNA's FM sound source)

    n1 = switch ( 0 for off / 1 for on, default is 0 )
    n2 = depth ( can be omitted only when switch= 0 )

    This value is common to all FM sound parts ( A to F ).

[Example] #1,6
[Result] Turn on the hardware LFO and set the depth to 6.

[Related] H command (->9-10)

===============================================================================
9-12 Hardware LFO frequency, waveform and depth settings (OPM)
    ## #f #w #p #a
-------------------------------------------------------------------------------
[format] ## number1,number2,number3,number4
    #f Number 1
    #w Number 2
    #p number 3
    #a Numeric 4
-------------------------------------------------------------------------------
[Range] [Number 1] 0 to 255
    [Number 2] 0 to 3
    [Number 3] -64 to +63
    [Number 4] 0 to 127
-------------------------------------------------------------------------------
[Source] FM(OPM)
-------------------------------------------------------------------------------
    Sets the hardware LFO FRQ, WaveForm, PMD, and AMD. (Only for OPM's FM sound source)

      Value 1 LFO_FRQ ( Frequency )
      Value 2 Waveform ( Waveform )
    Value 3 PMD (Depth to pitch)
      Value 4 AMD (Depth to Volume)

    You can specify FRQ for #f, Waveform for #w, PMD for #p, and AMD for #a independently.
    Each FM part ( A to I )

    This value is common to all FM sound source parts (A to I).

[Example] ##100,0,20,10
[Set LFO_FRQ to 100, Waveform to 0, PMD to +20, and AMD to 10 for the hardware LFO.
    Set hardware LFO with LFO_FRQ as 100, Waveform as 0, PMD as +20 and AMD as 10.

[Related] H command (->9-10)

===============================================================================
9-13 Hardware LFO delay setting
    #D
-------------------------------------------------------------------------------
[Format 1] #D Numeric
[Format 2] #D l tone length [.].
-------------------------------------------------------------------------------
[Range] [Number] 0 to 255
    [Note length] A value between 1 and 255 that is approximately the length of all notes.
-------------------------------------------------------------------------------
[Source] FM(OPNA,OPM)
-------------------------------------------------------------------------------
    Sets the delay of the hardware LFO.
    This is the third parameter of the H command that can be specified independently.

    Temporarily sets PMS/AMS to 0 until the specified time has elapsed after keyon.
    0 until the specified time has passed after keyon.

    The specified value is the sound length when l is added, or the internal clock value when it is not added.
    The specified value is the sound length if l is added, or the internal clock value if not.

    The value is set by the sound length when "l" is added, or by the internal clock value when "l" is not added. It has no meaning unless PMS and AMS are set by the H command.

[Example] #D24
[The hardware LFO will be triggered after a quarter note (at C96) has elapsed since the sound was played.
    [Example] #D24 [Result] Set the hardware LFO to engage after a quarter note (at C96) has passed since the sound was pronounced.

[Related] H command (->9-10)

===============================================================================
*******************************************************************************
10 [[[[ MML command loop control section ]]]]
*******************************************************************************
===============================================================================

    This section describes commands to control global and local loops.

    Local loops are useful for reducing the MML size and the size of the compiled data.

    Local looping is useful for reducing the MML size and the size of the compiled data. Global looping is used for infinite looping of a song.

===============================================================================
10-1 Local loop settings
    [ :]
-------------------------------------------------------------------------------
[format] [ mml1 [:] mml2 ] [number]
-------------------------------------------------------------------------------
[range] 0 to 255
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R selection / R definition
-------------------------------------------------------------------------------
    Sets the loop (repeat).

    The value is the number of times to repeat. 0 means repeat infinitely.

    If omitted, the value specified by #LoopDefault will be set.
    If #LoopDefault is not specified, it will be set to 0.

    If #LoopDefault is not specified, the value is set to 0. If #LoopDefault is specified, the loop is exited at the last loop.

[Example 1] [ cde : fga ]2 b
[Result] Play cde fga cde b.

[Note 1] Nesting is limited to 32 times.
    Nesting is the act of repeatedly creating a loop within a loop.
    [[[[[[[cde]2]2]2]2]2]2]2 is 7 times, but
    In [[cde]2[fga]2[b>cd<]2]2]2, the number of times becomes 2.

[Note 2] The values of the following commands are returned to the values at the start of the loop when the loop is completed.
    [Note 2] The values of the following commands are returned to the values at the start of the loop.
    When the loop is exited, the value will be the one at the end of the loop.

    o > < X  Octave related
    l  Default note length setting
    S  Decorative note setting
    W  Pseudo echo setting
    C  Whole note length setting
    _{ }  Transposition setting

    However, the values of other commands, such as volume settings, are carried over as they are.

[When a single note is specified in MML, the compiler automatically sets the
    "When a note is specified in MML, the compiler automatically sets the following five parameters: pitch, note length, octave, ornamental note, and pseudo-echo.
    It is easy to understand that the compiler automatically sets the following five parameters.

[Example 2] o4l8 cccc
    the compiler will write
[Result] o4c8 o4c8 o4c8 o4c8 o4c8
    The compiler will expand and convert it to data.

[Example 3] o4l8 [ c o5l4c ]2
[Result] o4c8 o5c4 o4c8 o5c4
    The o and l commands are o5l4 at the end of the loop, but
    The o and l commands are o5l4 at the end of the loop, but return to o4l8, the value at the start of the loop, when they return to the beginning of the loop.

[Example 4] o4 [ c : >c ]2 d
[Result] o4c o5c o4c o5d
    When the loop escapes, the value is o4, but after the escape, the value becomes o5 just before the [ ] command.

    If you think the above explanation is not clear enough, be sure to use o and l immediately after the [ and ] commands.
    If you think you don't understand the above explanation well, be sure to set the o and l commands immediately after the [ and ] commands, and the S and W commands if you are using them.
    This will avoid confusion.

[Example 5] [ o4l8 cdl4ef : gab>c ] o5l8 def
[Result] o4l8 cdl4ef gab>c o4l8 cdl4ef o5l8 def

[Related] #LoopDefault command (->2-13)

===============================================================================
10-2 Whole loop configuration
    L
-------------------------------------------------------------------------------
[format] L
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R select / R define
-------------------------------------------------------------------------------
    Set to return to the specified position when the MML for that part is finished.

    If it is not specified, the performance will be terminated.

[Note: As with local looping, octave, default note length, etc. will return to the value at the position where L is specified.
    As with local looping, octave, default note length, etc. will return to the value of the position where L is specified.

    The octave, default note length, etc. will return to the value at the position where L is specified, but the values of other commands, such as volume, will be carried over from the end of MML.
    Please note that the values of other commands, such as volume, are carried over from the end of MML.

    It is recommended to initialize each part immediately after L is specified.
    If you do this, you will not get the expected performance immediately after the loop.

[Example of failure]
A @0 v12 cccc
A L cccc
    :
A @1v10 cccc

[The second line will be played @0v12 the first time, but
    The second line is played @0v12 the first time, but @1v10 the second and subsequent times.

[Example]
A @0 v12 cccc
A L @0 v12 cccc
    :
A @1v10 cccc

[The second line is played @0 v12 both the first and second time.

    In fact, commands such as LFO, envelope, modulation, and transposition are also played with
    If there are any changes after L is specified, they will be put in immediately after L is specified.

===============================================================================
*******************************************************************************
11 [[[[ MML command and tempo setting section ]]]]
*******************************************************************************
===============================================================================

    This section describes the commands for setting the tempo.

===============================================================================
11-1 Tempo setting 1
    t
-------------------------------------------------------------------------------
[Format] t Numeric
[format 2] t numeric
-------------------------------------------------------------------------------
[range] 18-255
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R select / R define
-------------------------------------------------------------------------------
    Specifies the tempo.
    #This is the same as the Tempo command, but it can be changed in the middle of the song.

    A common value is used for all parts.

    If + or - is indicated, the value will be changed relative to the current value.

    The internal clock, 48 clocks, is used to set the number of times per minute that the speed of the clock will be increased.
    C96 is the default.

    At C96 (default), the speed is half note = ,.
    When set to C192, the speed will be quarter note=,.

    Values less than 18 cannot be specified.

[Example 1] C96 t100
[Sets the tempo to the rate at which a half note is played 100 times per minute.

[Example 2] t+10
[Result] Increases the tempo value by +10.

[Related] #Tempo command (->2-10)

===============================================================================
11-2 Tempo setting 2
    T
-------------------------------------------------------------------------------
[Format] T Numeric
[Format 2] T Numeric
-------------------------------------------------------------------------------
[Range] 0 to 255
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R select / R define
-------------------------------------------------------------------------------
    This command is used to specify the tempo, but unlike the t command, the value given directly to TIMER-B is set.
    It is the same as the t command.
    #This is the same as the Timer command, but it can be changed in the middle of the song.

    A common value is used for all parts.

    If you use + or -, the value will be changed relative to the current value.

    This allows for more detailed settings than the t command, especially at slower tempos.

    In X68000, in order to be compatible with the OPN version, this value is used as the OPN setting value, and the OPM setting value
    This value is used as the OPN setting value to calculate and output the OPM setting value.

    The default value is 200.

[Example 1] T180
[Result] Set the tempo to 180 in Timer-B value.

[Example 2] T+10
[Result] Increases the Timer-B value by +10.

[Related] #Timer command (->2-10)

===============================================================================
*******************************************************************************
12 [[[[ MML command, note processing command ]]]]
*******************************************************************************
===============================================================================

    This section describes commands for processing notes, such as ornamental notes and pseudo-echoes.
    commands for processing notes, such as decorative notes and pseudo echoes.

    These commands are unique to PMD and are not found in other music drivers.
    It is possible to use other MML representations without actually using it, but if you can master it, you can get a more realistic sound with fewer sound sources.
    However, if you can master it, you can easily get a more realistic performance with fewer sound sources and better processing.
    However, if you can master it, you can easily get more realistic performance with fewer sound sources.

===============================================================================
12-1 Decorative note settings
    S
-------------------------------------------------------------------------------
[Format 1] S Number 1[,Number 2[,Number 3]]
[Format 2] S l-note length [.] [,numeric2[,numeric3]]
-------------------------------------------------------------------------------
[Range] [Number 1] 0 to 255
    [Number 2] -128 to +127
    [Number 3] 0 to 1
    [Note length] 1-255, which is approximately the length of all notes.
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,86,PPZ)
-------------------------------------------------------------------------------
    A command that is valid for solo parts, from which you can specify the notes to be played.
    This command is useful for solo parts.

      Number 1 = speed (off by 0)
    Numeric 2 = depth (default is -1)
      Number 3 = tie flag (defaults to 1)

    The output pitch will be shifted by a semitone (depth) and then returned to the original pitch at the speed of speed.
    The speed value can be set by adding l.

    The speed value is set by the note length when l is added, or by the internal clock value when l is not added.
    The speed value is set by the note length if l is added, or by the internal clock value if not.

    If the tie flag is set to 0, the notes will not be connected and will look like a gliss.

    If a note length less than speeddepth is specified, no processing is performed.

    If S0 is specified, it will return to normal.

[Example 1] S2,-2e8
[Result] d%2 & d+%2 & e%10

[Example 2] S1,-3,0e8
[Result] c+%1 d%1 d+%1 e%9

[Note 1] Since the data is expanded on the compiler, the data size will increase if too much data is used.
    [Caution 2

[Note 2] You cannot use the l^ l= command while using this command.

[Related] l^ l= command (->4-9)

===============================================================================
12-2 Pseudo echo setting
    W
-------------------------------------------------------------------------------
[Format 1] W Number 1[,[%]Number 2[,Number 3]]
[Format 2] W l tone length [.] [,[%]numeric2[,numeric3]]
-------------------------------------------------------------------------------
[Range] [Number 1] 0 to 255
    [Numeric 2] -128 to +127
    [Number 3] 0 to 3
    [Note length] The value between 1 and 255 that is approximately the length of all notes.
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM(AD,86,PPZ)
-------------------------------------------------------------------------------
    The compiler will automatically apply a pseudo-echo to the notes you specify from there.
    This is useful when you want to apply an echo but don't have enough parts.

      Number 1 = delay (off at 0)
    Number 2 = depth (-1 by default)
      Number 3 = continue/tie flag (0 by default)

    In practice, after the key is turned on, if the internal clock advances by the delay, the key is turned off (if the tie flag is set, the key is turned off).
    If the tie flag is set, the key is not turned off), the volume is increased or decreased by the depth, and the key is turned on again.
    Key on again. If the "continue" flag is set, this will be repeated as long as the sound length allows.
    If the continue flag is set, it repeats the process as long as the sound length allows.

    The delay value is set by the sound length when l is added, or by the internal clock value when l is not added.
    If not, it is set by the internal clock value.

    After keyoff, the volume returns to the original level.

    The continue/tie flag is set to
        When set to 0: No continuity/tie
        When set to 1: Continuation / Tie
        When set to 2: One time only/No tie
        When set to 3: One time only/with tie

    If % is not specified, depth is set to the v command level.
         If % is specified, it is treated at the v command level.

    If a note length less than delay is specified, no processing is performed.

    If "W0" is specified, it will return to normal.

[Example 1] W8,-2a4
[result] a%8 (^2 a%8 (^4 a%8

[Example 2] W12,-2,3a2
[Result] a%12& (^2 a%36

[Example 3] W12,%-3,1a2
[Result] a%12 (^%3 a%12 (^%6 a%12 (^%9 a%12

[Note 1] As with the S command, the data is expanded on the compiler.
    If you use too much, the data size will become large.

[Note 2] When specifying the volume with %, the range of volume change is -128 to +127.
    In the case of PCM, the volume is 0-255, so the volume will not change more than the current value of +127 or -128.
    The volume will not change more than the current volume value of +127 or -128.

[Note 3] The l^ l= command cannot be used while this command is in use.

[Related] l^ l= command (->4-9)

===============================================================================
12-3 Setting key-on delay for each slots and bts
    sk
-------------------------------------------------------------------------------
[Format 1] sk Number 1[,Number 2]
[Format 2] sk Number 1[,l-note length [.]]
-------------------------------------------------------------------------------
[Range] [Number 1] 0 to 15
    [Number 2] 0 to 255
    [Note length] 1-255, which is the number of notes in the range.
-------------------------------------------------------------------------------
[sound source] FM
-------------------------------------------------------------------------------
    Delays the keyon of the specified slot, which can only be specified in the FM sound section.

    Value 1 = slot number
    Value 2 = delay

    The slot number specifies the slot to delay the keyon for.
    slot1 is 1, slot2 is 2, slot3 is 4, slot4 is 8, and so on.
    Specify the total value.

    The delay value is set by the sound length when "l" is added, or by the internal clock value when it is not added.
    The delay value is set by the sound length if l is added, or by the internal clock value if not.

    The value 2 (note length) can be omitted only when the value 1 is 0.

[Example: sk12,l8
[Result] From there, slots 3 and 4 will be used to delay keyon by an eighth note.

[Note] If a note with a length less than the specified delay value arrives, the keyon of the slot for which the keyon is delayed will not be performed.
    If a note arrives with a length less than the specified delay value, the keyon of the slot with the delayed keyon will not be performed.

===============================================================================
*******************************************************************************
13 [[[[ MML command, pan setting command ]]]]
*******************************************************************************
===============================================================================

    This section describes the commands for setting the output position (pan) of the sound.

    However, it is not valid when the sound source itself is monaural, such as OPN or SSG.

===============================================================================
13-1 Panning1
    p
-------------------------------------------------------------------------------
[format] p number
-------------------------------------------------------------------------------
[Range] 0 to 3
-------------------------------------------------------------------------------
[Source] FM(OPNA,OPM) / PCM
-------------------------------------------------------------------------------
    Sets the output position (pan) of the sound.

    The values to be set are as follows.

FM(OPNA),PCM(AD,PPZ) 1 Right
            2 Left
            3 Center (default)

FM(OPM),PCM(68) 1 Left
            2 Right
            3 Center (default)

PCM (86) 1 Right
                2 Left
            3 Center (default)
            0 Reverse phase

[Reverse phase means that the left and right phases are reversed. The effect is that the sound seems to be played backwards.
    The effect is that the sound seems to be coming from behind you. Especially when you wear headphones, you can really get the effect.
    You can get the effect especially when wearing headphones.

===============================================================================
13-2 Pan setting 2
    px
-------------------------------------------------------------------------------
[format] px  number 1[,number 2].
-------------------------------------------------------------------------------
[Range] [Number 1] -128 to +127
    [Number 2] 0 to 1
-------------------------------------------------------------------------------
[Source] FM(OPNA,OPM) / PCM
-------------------------------------------------------------------------------
    Specifies the output position (pan) and forward/reverse phase of the sound.

    Detailed specification is possible only when using the PCM(86,PPZ) part.

FM(OPNA),PCM(AD) Value 1 -128 to -1 Right (constant regardless of value)
                +1 to +127 Left (constant regardless of value)
                0 Center (default)
FM(OPM), PCM(68) Value 1 -128 to -1 Left (constant regardless of value)
                +1 to +127 Right (constant regardless of value)
                0 Center (default)
PCM (86) Numeric value 1 -128 to -1 Left to right
                    +1 to +127 Left (constant regardless of value)
                0 Center (default)
            Value 2 0 Normal phase
                1 Reverse phase
PCM (PPZ) Value 1 -128 to -4 left (constant regardless of value)
                -3 to -1 Lean left
                +1 to +3 Left to right
                +4 to +127 Right (constant regardless of value)
                0 Center (default)

===============================================================================
*******************************************************************************
14 [[[[ MML command and rhythm sound source command ]]]]
*******************************************************************************
===============================================================================

    This section describes the commands that control the rhythm instruments available in the YM2608.

    This section describes the commands that control the rhythm sound source available in the YM2608. Although they can be specified for all parts, they have no direct effect on the performance of the specified parts.
    This command can be specified for all parts, but it has no direct effect on the performance of the specified part.

    In general, it is easier to understand if the rhythm part is specified at the same time as the
    This is usually easier to understand if it is written at the same time as the rhythm part.
    If you play rhythms only with a rhythm sound source, it is better to use SSG rhythm parts.
    (1-2-2). (->1-2-2)

===============================================================================
14-1 Rhythm source shot dump control
    \b \s \c \h \t \i \bp \sp \cp \hp \tp \ip
-------------------------------------------------------------------------------
[Form 1] \b[p].
[Form 2] \s[p].
[Form 3] \c[p].
[Form 4] \h[p].
[Form 5] \t[p].
[Form 6] \i[p].
-------------------------------------------------------------------------------
[Source] FM(OPNA) / SSG / PCM(AD,86,PPZ) / R selection / R definition
-------------------------------------------------------------------------------
    This command outputs/stops each sound of the rhythm sound source.
    The correspondence between each command and the rhythm sound is as follows.

    b Bass Drum
    s Snare Drum
    c Cymbal
    h Hi-Hat
    t Tom
    i Rim Shot (note that it's not r)

    A "p" will stop (dump) the sound.

    If you want to output both at the same time, use \s\t\i.

[Example 1] \b\s
[Result] The Bass Drum and Snare Drum rhythm instruments will be played simultaneously.

[Example 2] \cp
[Result] Stops the Cymbal sound of the rhythm instrument.

[Note 1] If used before the p and px (pan) commands, for example
    \bp3
    will be judged as \bp 3 and an error will occur.
    \b p3
    to separate the two commands.

[Note 2: Due to OPNA specifications, when outputting SHOT/DUMP rhythms in succession
    [Note 2] Due to the OPNA specification, when outputting a series of SHOT/DUMP rhythm sounds, a rather large weight is required between outputs.

    PMD can handle this by inserting an appropriate weight between the two commands only when they are consecutive.
    However, if a command with no sound length (q, v, etc.) is inserted between the two commands, and the output is effectively continuous, the weighting will be reduced.
    However, if a command with no note length (q, v, etc.) is inserted in between and the output is virtually continuous, the necessary weighting is not inserted and the sound may not be played properly.
    In particular, if a SHOT is followed by another SHOT, it may not be played properly.

    The symptom is especially noticeable when the DUMP command for other rhythm sounds is entered after SHOT.
    Please be careful.

[Example 3]
I [\h \cp r32 ]0
[Result] PMD automatically inserts the weight and the hi-hat is output correctly in 32-minute increments.

[Example 4]
I [\h q0 \cp r32 ]0
[The PMD automatically inserts the weights and the hi-hat output may be abnormal.

===============================================================================
14-2 Setting the rhythm sound source master volume
    \fnDroid Sans Fallback
-------------------------------------------------------------------------------
[Format] \V [] Numeric
-------------------------------------------------------------------------------
[Range] 0 to 63
-------------------------------------------------------------------------------
[Source] FM(OPNA) / SSG / PCM(AD,86,PPZ) / R selection / R definition
-------------------------------------------------------------------------------
    Sets the master volume of the rhythm sound source.

    A + or - will change the volume relative to the previous volume.

    The volume range is 0-63, with a default of 48.

[Example: \V63
[Result] Maximizes the master volume of the rhythm instrument.

===============================================================================
14-3 Setting individual rhythm sound volume
    \vb \vs \vc \vh \vt \vi
-------------------------------------------------------------------------------
[Format] \vb []Numeric
    \vs [] numerical value
    \vc []numeric
    \vh [] number
    \vt [] number
    \vi []numeric
-------------------------------------------------------------------------------
[range] 0 to 31
-------------------------------------------------------------------------------
[Source] FM(OPNA) / SSG / PCM(AD,86,PPZ) / R select / R define
-------------------------------------------------------------------------------
    This sets the volume of each rhythm sound source.
    Notating + or - will make relative changes.

    The next letter after \v indicates the corresponding rhythm sound, similar to the shot dump control.
    The next letter of \v represents the corresponding rhythm note, similar to the shot dump control.

[Example 1] \vb25
[Result] Set the Bass Drum volume of the rhythm source to 25

[Example 2] \vs+2
[Result] Increase the volume of the Snare Drum in the rhythm source by 2

===============================================================================
14-4 Setting the rhythm sound source output position
    \lb \ls \lc \lh \lt \li \mb \ms \mc \mh \mt \mi \rb \rs \rc \rh \rt \ri
-------------------------------------------------------------------------------
[Format] \lb \mb \rb
    \ls \ms \rs
    \lc \mc \rc
    \lh \mh \rh
    \lt \mt \rt
    \li \mi \ri
-------------------------------------------------------------------------------
[Sound source] FM(OPNA) / SSG / PCM(AD,86,PPZ) / R selection / R definition
-------------------------------------------------------------------------------
    Sets the output position for each rhythm sound source.

    The next letter of \ represents the position to be output, as shown below.

    l Left (left)
    r Right (Right)
    m Center (center)

    The next letter represents the corresponding rhythmic note, similar to the shot dump control.
    The next letter represents the corresponding rhythm note, similar to the shot dump control.

[Example: \lh
[Set the Hi-Hat output position of the rhythm source to the left.

===============================================================================
*******************************************************************************
15 [[[[ MML command, FM sound source LSI/driver control ]]]]
*******************************************************************************
===============================================================================

    This section describes commands to directly control FM sound source LSIs and drivers such as PMD and PDR.

    It is rarely used, but if you do use it, you may need to know enough about the control target.
    This section describes commands to directly control FM sound source LSIs and drivers such as PMD and PDR.

===============================================================================
15-1 Direct output to FM sound source LSI
    y
-------------------------------------------------------------------------------
[format] y number 1, number 2
-------------------------------------------------------------------------------
[Range] [Number 1] 0 to 255
    [Number 2] 0 to 255
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R selection / R definition
-------------------------------------------------------------------------------
    Specifies the value to be output to the FM sound source LSI as it is.

    The numerical value 2 is output as data to the register specified by numerical value 1.

    In the OPNA, the D, E, and F parts output to the back port, but the other parts output to the front port.
    In OPNA, parts D, E, and F are output to the back port, while the other parts are output to the front port.

[Example] y$58,7
[Result] Set the AR of FM channel 1, slot 2 to 7.

[Note 1] Do not use this function unless you have sufficient knowledge of FM sound source LSI.

[Note 2] Although you can fine-tune the FM tone parameters, you may not be able to use them when returning from PAUSE, sound effect, or part mask states.
    Keep in mind that when you return from a PAUSE, sound effect, or part mask state, the voices will be redefined and reverted to their original state.
    Keep this in mind.

    If you want to change the FB and TL values, there are dedicated FB and O commands.
    If you use them, you can avoid such a phenomenon.

[Related] FB command (->6-4)
    O command (->6-3)

===============================================================================
15-2 PDR operation mode control
    *
-------------------------------------------------------------------------------
[Format] * Numeric
-------------------------------------------------------------------------------
[range] 0 to 5
-------------------------------------------------------------------------------
[Source] R-select / R-define
-------------------------------------------------------------------------------
    Used in the K/R part to control the operation mode of the PDR.

    n=0 Set to Double Mode
    n=1 Set to Single Mode
    n=2 Set to 16KHz Mode
    n=3 Set to 8KHz Mode
    n=4 Set to EI Mode
    n=5 Set to DI Mode

[Example] *0
[Result] Set the PDR to Double Mode.

[Note 1] Normally, do not use any value other than 0 and 1 for PDR control. Especially in slow models.
    If *2 is executed with PDR resident, there is a risk of hanging up on the spot.
    Note 2] Software LFO

[Note 2] If the command name is the same as the switch name of the software LFO, it may not be recognized by the specified part.
    [Note 2] The command name is the same as the software LFO switch, and is identified by the specified part. Be careful not to confuse them.

[Related] * Command (software LFO switch) (->9-3)

===============================================================================
15-3 Fade-out specification
    F
-------------------------------------------------------------------------------
[Format] F Number
-------------------------------------------------------------------------------
[Range] 0 to 127
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R select / R define
-------------------------------------------------------------------------------
    Fade out from the specified position.

    The speed is specified by a numerical value: 1 is the lowest speed, 127 is the highest speed.

[Example: F16
[Result] Fade out at speed 16.

===============================================================================
15-4 Volume down setting by sound source
    DF DS DP DR
-------------------------------------------------------------------------------
[Format 1] DF [] Numeric
[Format 2] DS [] Numeric
[Format 3] DP [] Numeric
[Format 4] DR []Numeric
-------------------------------------------------------------------------------
[range] [without ] 0-255
    [With ] -128 to +127
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R selection / R definition
-------------------------------------------------------------------------------
    Changes the volume down setting by sound source.

    DF is FM sound source, DS is SSG sound source, and
    DS is SSG, DP is PCM, and
    DP is the PCM sound source, and
    DR represents the rhythm source, respectively.

    If you add + or - to a value, it changes it relative to the current value.
    Note that + decreases the volume.

    However, if +0 or -0 is specified, it will be reinitialized to the value specified in the PMD options.

[Example]
G [cdefgab>c< DS+16]8
[Result] The volume of the entire SSG sound source will gradually decrease with each loop.

[Note: The volume down value set here is a local value that is effective only for that song.
    When you start playing the song again, the values specified in the /DF, /DS, /DP, and /DR options of PMD will be
    When you start playing again, the values specified in the /DF, /DS, /DP, and /DR options of PMD will be reset and then restored.

[Related] #VolumeDown command (->2-22)
    PMD /DF /DS /DP /DR options (->PMD.DOC)

===============================================================================
15-5 FM sound effect pronunciation
    N
-------------------------------------------------------------------------------
[format] N Numeric
-------------------------------------------------------------------------------
[Range] 0 to 255
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R select / R define
-------------------------------------------------------------------------------
    Sounds an FM sound effect.
    When 0 is specified, it stops.

[Note] FM sound effect can be defined from 0, but 0 cannot be played in MML.
    Example: N4

[Example] N4
[Result: The fourth FM sound effect is played.

===============================================================================
15-6 Sounding SSG sound effects
    n
-------------------------------------------------------------------------------
[format] n number
-------------------------------------------------------------------------------
[Range] 0 to 255
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R select / R define
-------------------------------------------------------------------------------
    Sounds the SSG sound effect.
    When 0 is specified, it stops.

    If PDR or PPSDRV is resident, the
    1 to 127 SSG sound effect
    128 to 255 SSGPCM sound effect (The value is the number added up to 128.)
    If the PDR and PPSDRV are resident, the SSGPCM sound effect (the value is the number added to 128) is pronounced.

[Example: n15
[The 15th SSG sound effect will be played.

===============================================================================
15-7 Part mask control
    m
-------------------------------------------------------------------------------
[Format] m Numeric
-------------------------------------------------------------------------------
[range] 0 to 1
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R select / R define
-------------------------------------------------------------------------------
    Controls the mask on/off for the specified part.

    0 turns the mask off (play).
    1 turns the mask on (does not play).

    This is not usually used. It is not usually used.

[Example] m1
[Masks the specified part from being played.

===============================================================================
15-8 Measure length settings
    Z
-------------------------------------------------------------------------------
[Format] Z Numeric
-------------------------------------------------------------------------------
[Range] 0 to 255
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R select / R define
-------------------------------------------------------------------------------
    Specifies the length of the measure. It has no effect on the performance.

    When incorporating PMD into games, etc., the programmer can specify the length of the measure so that the visuals can be processed according to the measure of the song.
    When PMD is embedded in a game or other application, the programmer can obtain the current measure no. from the programmer so that it can be processed according to the measure of the song in the visuals.
    However, since MML does not have the concept of measures, the current measure number can be obtained from the programmer.
    However, since MML does not have the concept of measures, the driver cannot get an accurate value if it does not know the length of the measure when using 3-beat or variable time.
    measure length.

    So, if you are using triplets or modulation, the driver cannot get an accurate value without knowing the measure length.
    The default is 96.

    The default is 96.

[Example: Z72
The default value is 96. [Example] Z72 [Result] From there, the driver will know that the time signature is in 3/4 time.

[Note: If the time signature changes in the middle of a song, be sure to specify the measure length at the beginning of the measure.
    Note] If the time signature changes in the middle of a song, be sure to specify the measure length at the beginning of the measure.

[If you use this function in reverse, for example, you can make the driver think that a quarter note is a measure.
    If you use this feature in reverse, for example, by having the driver consider a quarter note to be a measure, you can synchronize in quarter note units.

===============================================================================
15-9 Writing numbers to Status1
    ~ ~
-------------------------------------------------------------------------------
[Format 1] ~ Numeric
[Format 2] ~  numeric
-------------------------------------------------------------------------------
[Range] [Format 1] 0 to 255
    [Format 2] -128 to +127
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R select / R define
-------------------------------------------------------------------------------
    Write a value to Status1 (which can be obtained by the programmer through the driver).

    When + or - is indicated (format 2), it adds/subtracts to the current Status1.

[Note: The possible range of Status1 is 0-255. If it exceeds this range, CHECK is not performed.
    For example, if you set ~0 ~-1, Status1 will be 255.

[example] ~2
[Result] Write 2 to Status1.

===============================================================================
15-10 PCM specification selection
    A
-------------------------------------------------------------------------------
[Format] A Numeric
-------------------------------------------------------------------------------
[Range] 0 to 1
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R select / R define
-------------------------------------------------------------------------------
    This is valid when the song is played on PMD86.

    The specification of the PCM part is set to
0 PMD86 normal specification
1 Change the specification to PMDB2 (volume and loop specification will be changed)

    The /s option of PMD86 is also available.

    It is almost the same as the /s option of PMD86, but here it is a local change.
    If you play a different song, the settings will be restored.

[Example: A1
[Result] Match PCM specification to ADPCM.

[Related] #ADPCM command (->2-23)

===============================================================================
*******************************************************************************
16 [[[[ MML command and compilation control ]]]]
*******************************************************************************
===============================================================================

    This section describes the various compile-time control commands.

===============================================================================
16-1 Using definition variables
    !
-------------------------------------------------------------------------------
[Format 1] ! string
[Format 2] ! Numeric
-------------------------------------------------------------------------------
[string] Any character type and number of characters. The number of characters is arbitrary.
[Range] 0 to 255
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R selection / R definition
-------------------------------------------------------------------------------
    The MML string of the variable defined by the specified string or number is attached to the specified location.
    The MML string of the variable defined by the specified string or number is pasted to the specified location.

[Note 1] It is recommended that you avoid variables where one variable name is another variable name plus alpha, such as "!b" and "!bc".
    b" and "!

    For example, if two MML variables are defined as "!b" and "!bc", and an MML variable named "!bcc" arrives, the variable named !
    For example, if two MML variables are defined as "!b" and "!bc", and an MML variable called "!bcc" arrives, it will be very difficult to tell whether it is !

    In such cases, the longer variable name (! bc in this case) is used.
    bc" in this case) is adopted.
    In this case, the longer variable name (! bc) will be used. (! bcc, ! bc, ! b)

    If you want to use !b in this situation, just use !b cc with a space or tab in between.
    If you want to use ! (See Example 1)

[Note 2] ! (See Example 1.) [Note 2] If you want to use a number (abbreviated form of l= in the l= command) after a number, you can also use !
    (See Example 1.) [Note 2] !

[Note 3] When referring to a variable with more than 30 single-byte characters, a space or tab is always
    (No more than 30 characters will be defined.
    (Because it is impossible to determine where the variable ends, since it is not defined any further.)

[Example 1]
! b @0
! bc @1
s @2
A !bcc !sg !bc
[Result] @1 c @2g @1

[Example 1'] !
!b @0
bc @1
s @2
A !b cc !s g !b c
[Result] @0 cc @2 g @0 c

    See MML Variable Definitions (->3-2) for details.

[Related] ! command (MML variable definitions) (->3-2)

===============================================================================
16-2 MML skip control1
    "
-------------------------------------------------------------------------------
[format] "
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R selection / R definition or beginning of line
-------------------------------------------------------------------------------
    Commands with sound length will be skipped until the next " or ' command is found.
    command is skipped until the next " or ' command is found.

    If a " command has already been specified, skipping will be terminated.

    If the " command has already been specified, skipping will be terminated. m command is issued at the same time to mask the part when skipping.
    In MML, the first line of a line is also skipped.

    It can be written in MML or at the beginning of a line.

[Example 1]
A "@0v13o3 cdefgab >@1 cdefgab " >c
[Result]
A m1 @0v13 o3 > @1 m0 >c
    A "@0v13o3 cdefgab >@1 cdefgab " >c [Result] A m1 @0v13 o3 > @1 m0 >c

[Example 2]
" ;start skip
A @0 v13 o5 cde
B @1 v13 o4 ccc
" ;unskip
A gfd
B <ggg>.
[result]
A @0 v13 o5 gfd
B @1 v13 o4 <ggg>

===============================================================================
16-2 MML skip control 2
    '
-------------------------------------------------------------------------------
[format] '
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R selection / R definition or beginning of line
-------------------------------------------------------------------------------
    This command forcibly terminates the MML skip state.

    At the same time, the m0 command is issued.

    It can be written in MML or at the beginning of a line.

[Example 1]
A " t80 v12 @10 cder ' def
[Result] A t80 v12 @10 def
A t80 v12 @10 def

[Example 2] A
"
A cde
B efg
'
A fga
B ab>c

[result]
A fga
B ab>c

===============================================================================
16-3 Part-limited specification
    | |!
-------------------------------------------------------------------------------
[format 1] | [symbol[symbol...]] mml
[format 1] |! [symbol[symbol...]] mml
-------------------------------------------------------------------------------
[Sound source] FM / SSG / PCM / R selection / R definition
-------------------------------------------------------------------------------
    This is useful when multiple parts are specified at the beginning of a line, to limit the parts that are compiled from it.
    It limits the parts to be compiled from.

    When ! is appended to the line to limit the parts to be compiled from.

    There must be at least one space or tab between the part symbol and mml as a separator.
    tab is required as a separator.

    The compiler's behavior is to use the alphabet of the part currently being compiled.
    If the alphabet of the currently compiled part is not specified (! ), it will use the
    If there is no character after the |, the compiler will skip the MML to the end of the line.

    If there is no character after |, the entire limiting state is removed.

[Example]
ABC @12v11o4l2 |A D0ccd |B D3efg |C D-3gab |!C >c& |C g4e4 | c
[Result] A @12v11o4l2
A @12v11o4l2 D0 ccd >c& c
B @12v11o4l2 D3 efg >c& c
C @12v11o4l2 D-3gab g4e4 c

===============================================================================
16-4 Censoring compilation
    /
-------------------------------------------------------------------------------
[format] /
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R-select / R-define
-------------------------------------------------------------------------------
    Cuts off the Compile for that part there.

[Example]
A cde /
A fga
[Result]
A cde

===============================================================================
16-5 Specifying comments
    ;
-------------------------------------------------------------------------------
[format] ;
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R selection / R definition
-------------------------------------------------------------------------------
    Censors the Compile for that line, and ignores the rest as comments.

[Example]
A cde ; comment
A fga
[Result]
A cde
A fga

===============================================================================
16-6 Comment specification 2
    `
-------------------------------------------------------------------------------
[format] `
-------------------------------------------------------------------------------
[Source] FM / SSG / PCM / R selection / R definition or beginning of line
-------------------------------------------------------------------------------
    Once a line is specified, all MML in between is ignored as a comment until the line is specified again.
    Once specified, all MML in between will be ignored as comments until specified again.

    If it is specified at the beginning of a line, the comment flag is reversed for all parts.
    The flag is inverted.
    If you put it at the beginning of a line, all parts are flagged as comments. definition commands are also ignored.

    It must be in MML or at the beginning of a line.

    If you want to write a document in MML or
    If you want to write a document in MML, or if you want to put a comment in an MML line, this is useful.

[Example 1]
A l4cde ` here is a comment
A comment here ` cde
A l4cde ` here is a comment ` cde [Result] The double-byte characters become comments.

[Example 2]
A cdefg
`
#Detune Extend
A
[A variable is defined, but the line #Detune Extend is ignored.

A is defined, but the #Detune Extend line is ignored. [Note 1] Specifying this in MML in a particular part does not affect other parts.

[Example 3]
`
G cde fga ` b
H cde ` fga b
[As a result, up to a for part G and up to e for part H are ignored as comments.

[Note 2] Only the middle of the part MML can be commented.
    If you want the whole MML to be a comment, you must put it at the beginning of the line.

[Example 4]
` Comment `
    In the above example, the second ` symbol is ignored and all subsequent MMLs are SKIPed.
    In the above example, the second ` symbol is ignored and all subsequent MML is SKIPed.

    In this case, the
` Comment
` Comment
    in this case, it should be written as

===============================================================================
*******************************************************************************
17 Producer's contact/contact information
*******************************************************************************
===============================================================================
[!!! Attention!!!] The address/tel has been changed as of 1996/03/01.

    Room 102, Printemps Iguchi, 2-34-22 Kamiigusa, Suginami-ku, Tokyo 167, Japan
                            Masahiro Kajiwara
                        TEL&FAX (03)3395-9766
                            (You can call us anytime, 24 hours a day)
                Support BBS [PMD-BBS] (03)3395-9600 (3 lines)
                Please refer to the PMDBBS.CM file for details.

    (Please note that we may not be able to answer questions sent by mail.)

===============================================================================
            --- End of PMDMML.MAN --- (3 lines)
===============================================================================

MCONV.EXE Ver.0.01
FMvoice data includer for P.M.D.music data
Copyright 1992 PasoRin/T.Hayashi All Rights Reserved

1.1 Introduction
This program is to store FM voice data for PMD98/VA(C)Kajihara's performance OBJ file which "does not contain FM voice data".
The author is working on bringing 88 music discs to 98 (^_^;). The author is working on bringing the music disc of 88 to 98. The select and player "PPLAY" made by a junior colleague of mine is also called ".........", which did not think of storing tone data (laughs).

2. How to use
When you are ready, enter the following command.

MCONV music-object FM-voice

It is not allowed to omit the file name. Also, the object file must be in PMD Ver. 2.92 or later format, and the voice data must be in a format that can be used with 98. The object file must be in PMD Ver. 2.92 or later format, and the voice data must be in a format that can be used with 98. The object file is checked for export, but it is not perfect. Please note!
If there are no error messages, the rewriting is complete. You can now enjoy the song without loading the FM tone data.
If there is an error, the rewriting process will be interrupted with a message. The interruption code is as follows.

0: No error, normal completion
1: File not found, size too large, no need to convert
2: File open failure
3: File read failure, write failure
4: OBJ data error

As for the OBJ data in 4, the current version only supports OBJ codes up to PMD Ver. 3.9. In the future, when the number of codes increases along with PMD's functional expansion, an error will occur. At that time, if you want to fix ............, you can do so (oy).

3. Bugs
I don't think there are any bugs in ............, but I made it in a rush, so there may be bugs. If you find a bug, please send me a bug report (^_^;)(^_^;)(^_^;)(^_^;)(^_^;)(^_^;)(^_^;)(^_^;)(^_^;)(^_^;)
(^_^;) And I don't need to bother to say it, but it's "no guarantee" (^_^;) I do check the performance data of PMD, but it's not perfect. Even if I wanted to make it perfect, there is no check code in PMD. .........

4. About reprinting
In order to get a wide range of bug reports, reprinting is allowed with some limitations. The conditions for permission are as follows

You need to be able to contact the author. No grandchildren are allowed. You can only publish your children. Of course
We do not allow to publish in places where publishing infringes the author's copyright.
Please report reprints (even after the fact).
Please contact me with information on where to reprint. I'm hungry for bug reports! (laughs).
(laughs) In that case, be sure to include the operating machine, data on other resident objects, and any abnormal conditions. 5.

History (big laugh)
Ver.0.00 92/05/11 Suddenly I wanted to make it (laugh)

6. Future plan
Selection of the theme for my thesis: .........

7. Contact
If you send e-mail to the following BBS, you should be able to contact me.
MSI BBS 045-801-7571 MSI00001 Pasorin
 0466-44-1480(5/23)
SETA-NET 03-3788-5411(substitute) SCL70351 Pasorin
MSA-NET 03-3486-1456(proxy) MSA01768 Pasolin
Doujin Network 03-3857-9575 (proxy) PASORIN PASORIN
PASONET 03-3843-1211 (proxy) PS-00932 PASORIN



 ===================================

===============================================================================
  P.M.D. Parameter Viewer Ver. 0.92g document 1996. 4. 6
===============================================================================

Thank you very much for the download. (Thank you very much.

Please read to the end.

===============================================================================
Introduction
===============================================================================

I created a "P.M.D. Parameter Viewer" in the hope that I could see the PMD performance visually (it was really just a thought).

"I made a thing called P.M.D. Parameter Viewer.

For each channel of FM6, SSG3, PCM, and Rhythm

It shows volume, timbre, LFO, detune, and pitch in A to G like MML.

There is also a file select function, so you can select a different song to play after starting.

We hope you will use it as a reference for debugging when composing with PMD.

This is for PMD Ver. 4.8g or later.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

===============================================================================
Operating environment of this software
===============================================================================

NEC PC-9801/9821 series or EPSON PC-286/386/486 series

(+ analog display) that can display 16 out of 4096 colors and can run PMD.

It does not work in high-resolution mode.

===============================================================================
How to use
===============================================================================

You can use this "P.M.D. Parameter Viewer" (hereinafter referred to as PMDPV) and

 (PMD music file) in a directory with a path.

M (PMD music file) in the directory where the path goes.

(Refer to the PMD documentation for details on how to reside PMD, options when residing PMD, etc.)

M ([FILENAME] can be omitted if the song extension is .M)

M ([FILENAME] can be omitted if the song extension is .M) Load the song data with

If a PCM (PPC, P86) or PPS file is defined in the song file

The file is automatically loaded and defined.

If the song data or PCM file cannot be found, search for the environment variable "PMD" and

If the song data or PCM file is not found, it will search the environment variable "PMD" to find it. (For more information about the environment variable "PMD", please refer to the PMD document.

(For details about the environment variable "PMD", please refer to the PMD document.

Key operations in Viewer mode

[SPACE] Start & stop playing
[ESC] Stop & End
[RETURN] Start playing
[Q][f10] End the performance as it is.
[XFER] Filer mode on
[0 to 9 , * + = ] Part mask (numeric keypad)
[0~9 - ^ \ BS] Part mask (full key)
[HOME CLR] Release all part masks
[HELP] Reverse all part masks
[TAB] Measure jump (enter with numeric keypad, set to 0 with HOME CLR)
[f1] Switch between d- and c+ in key display
[f-2] key toggles between e- and d+.
[f-3] Use key to switch between g- and f+.
[f-4] Toggle between a- and g+ in key display
[f-5] key toggles between b- and a+.
[ROLL UP] tempo up (upper limit depends on PMD's resident /G option. Default is 250)
[ROLL DOWN] Tempo down (will only go down to 0)
[COPY][/] Pause, unpause ([/] is a numeric keypad)
[INS] Skip 1 measure
[DEL] 1 bar back
[f-6] Increase the volume down value of the FM part
[f-6]+[SHIFT] Decrease the volume down value of the FM part.
[f-7] Increase the volume down value of the SSG part.
[f-7]+[SHIFT] Decrease the volume down value of the SSG part
[f8] Increase the volume down value of the PCM part
[f8]+[SHIFT] Decrease the volume down value of the PCM part.
[f9] Increase the volume down value of the Rhythm part.
[f9]+[SHIFT] Decrease the volume down value of the Rhythm part.
[f-9]+[SHIFT] Decrease the volume down value of the Rhythm part [f-9]+[SHIFT] Decrease the volume down value of the Rhythm part [f-9]+[SHIFT] Pause, Release Pause
[vf-2] Stop playing
[vf-3] Start playing
[vf-4] Rewind
[vf-5] Fast forward

Key operation in filer mode

[XFER][ESC] Filer mode off
[][][][] Move the cursor (move at high speed by pressing the SHIFT key at the same time)
[BS] Go to the next directory up.
[L] Change drive
[L] Change drive [RETURN] Move directory or load and play song data

Other keys are the same as in Viewer mode, except for Channel Mask.

If you are in Filer mode and the Kana key is locked.

If the Kana key is locked in Filer mode, you will go to Viewer mode when you select a file and start playing.

This key cannot be changed at the moment, but we will do something about it soon.

This may seem like a lot, but it's not much (^^;

If you use it for a while, you'll see what I mean.

===============================================================================
Options at startup
===============================================================================

By specifying options at startup, you can make some differences in the way the program starts and displays.

The options can be before or after the file name.
             They can be lowercase or uppercase.
             The demi-liter can be either / or -. ( e.g. PMDPV /P -L /K )

 /K  Start playing immediately without waiting for the Spacebar to be pressed.
 /P  The song data is not loaded, and the playback status remains the same, and the viewer screen appears.
 /+  The key display will be changed to a sharp (+) display. (The default is to display the odd-note)
 /A  Do not set ADPCM, PCM, SSGPCM data.

Note on the P option at startup!

PMD allocates the performance data buffer when it is resident, so once the song data is loaded, the next song can be played.

   PMD reserves the performance data buffer when it is resident, so once the song data is loaded, you can play it as many times as you like unless you load the next song.

   In other words, the /P option should be used under the assumption that there is performance data in the buffer.

   The /P option should be used on the assumption that there is performance data in the buffer. (Same as /P option of PMP.COM (PMD player))

   (Same as the /P option of PMP.COM (PMD Player).) If no data is loaded immediately after PMD is resident, the performance will be strange.

The /P option has higher priority than the song file option.

   A>PMDPV ???? .M /P  ???? M is not loaded and PMDPV is started.

   M is not loaded and PMDPV is started. (Normally, it is impossible to specify both options.

If you do not specify the song data, the /P option is automatically added.
   (Early on, the /P option can be omitted (^^; A>PMDPV alone is OK))

For example, if you are using MCH.EXE (PMD MML compiler evaluation version) and you want to use

A>MCH /V ???? .MML

MML will start playing suddenly.

A>PMDPV /P ( A>PMDPV alone is also acceptable)

This will take you to the viewer screen without loading the song data.

As an advanced version (laughs)

A>MCH ???? .MML | PMDPV /P

You may want to use pipe processing (^^).

(This is to reduce the time lag, but it is not the original way of using pipes (^^;))

===============================================================================
Explanation of each parameter displayed
===============================================================================

The screen is arranged from the top in the order of FM1-6, PSG1-3, PCM, and Rhythm.

The parameters are listed in order from left to right.

Description : Display : Explanation
-----------------------------------------------------------------------------
Address currently being played: Addr: 0000 to FFFFF
Address to be looped: Loop: 0000 to FFFF
Volume : 0 to 127 for FM, 0 to 15 for PSG, and 0 to 255 for PCM
Tone number (noise frequency) : Voice : @0 to @255 (Tone Noise Mix for PSG) *1
Pitch, Octave : Key O : A to G (pitch) and 1 to 8 (octave) *2
Panning  Pan  R:Right L:Left C:Center 3
Gate time  GT  Gate time, the value specified by q command.
Detune  Detune  From -32768 to +32767.
LFO  value  LFO  From -32768 to +32767.
LFO switch : LS : Set to 1 when LFO is turned on.
Portamento Switch : PS : Set to 1 when portamento is present.
 Note 1: Instead of the tone number in the PSG section, Tn (Tone), Ns (Noise), and Mx (Mix) are displayed.
    The average frequency of the noise will be displayed next to Noise and Mix.

The scale displayed is the scale after modulation by the _ command.

The panning of the rhythm part is not displayed. (There's no place for it... ^^;)

In the rhythm part, there is no indication below the volume, and the name of the drum being played is displayed.

The correspondence between the @ command and the  command in the R part and the drum name displayed is as follows

The correspondence between the @ command and the  command and the drum name displayed in the R part is as follows. (The  command does not need to be in the K or R part.

Display @ number Rhythm Instrument MML
------------------------
BaD @ 1 \b
SD1 @ 2 \s
LTm @ 4
MTm @ 8 \t
HTm @ 16
RiS @ 32 \i
SD2 @ 64
HiC @ 128 \h
HiO @ 256
CrC @ 512
RiC @ 1024 \c
ER1 @2048
ER2 @4084
ER3 @8192

Various data will be displayed below it.

Content : Display : Description
-----------------------------------------------------------------------------
Status 1 : STATUS1 : The value written by the ~ command.
Status 2 : STATUS2 : Loop count, set to 255 at the end.

Performance time PLAY TIME  Elapsed time from the start of performance. Total time
Total time TOTAL TIME  Displayed by loop or end of performance.

Current playing measure number BAR Does not return to 0 even if looping. 5 Jump bar number
5 Jump measure number : JUMP BAR : Normally not displayed.
See "Measure Jump".

Tempo TEMPO  Value to be specified to Timer-B.  Tempo: TEMPO: Value specified to Timer-B. 6
Tempo 48 TEMPO 48  Value specified by t command.

PCM (PPC, P86) file name: PCM : PCM file name used by the loaded song.
PPS (PPS) file name : PPS : PPS file name used by the loaded song.

Note 4: The playing time is limited to 18 hours, 12 minutes and 15 seconds (65535 seconds). If it exceeds that time
    (Don't listen to it for 18 hours. (Don't listen to it for 18 hours, lol.)
    Looping does not return to 00:00:00.
    (Don't listen to it for 18 hours, lol.) Looping does not return to 00:00:00.
    (^^;

Note 5: If you use a certain notation in MML (e.g. triplets), the measure number may be different from what the MML author intended.
    If you use a certain notation (e.g. triplets), you may get a different measure number than the MML author intended. In such cases, use the
    Z command (PMDMML.MAN 15-8) and do something about it.

Note 6: In MML, the value is specified by the T command.
    The value specified by the t command is converted to the value of the T command inside PMD and handled.

===============================================================================
Part mask function
===============================================================================

Pressing the numeric keypad or the full key allows you to mask (inaudible) a part.

Once a part is masked, pressing the same key again will unmask it.

The correspondence between keys and parts is as follows

Part Numeric Keypad Full Key
FM 1 1 1
FM 2 2 2
FM 3 3 3
FM 3b * ^
FM 3c + \
FM 3d = BS
FM 4 4 4
FM 5 5 5
FM 6 6 6
SSG 1 7 7
SSG 2 8 8
SSG 3 9 9
PCM 0 0
Rhythm , -

[HOME CLR]  Release all masks.
[HELP]  Invert mask

When each key is pressed, the leftmost LED of the part that is turned off goes out and the part line is displayed in black.

When you press each key, the leftmost LED of the part you turned off will turn off, the part line will be displayed in black, and the part will be masked (inaudible).

===============================================================================
Measure Jump
===============================================================================

If you press the [TAB] key while playing, the area to the right of the "JUMP BAR" will be highlighted and you will be prompted to enter a value.

You will be prompted to enter a number.

At this point, you can use the numeric keypad to enter the measure number you want to jump to.

At this point, you can use the numeric keypad to enter the measure number you want to jump to, and you can jump to any measure regardless of the current measure number.

Press the [HOME CLR] key to set the number to 0.

When this number is 0, pressing the [RETURN] key will abort the measure jump.

This means that you cannot jump to measure 0. Because measure 0 means you start from the beginning.

So, if you want to jump to measure 0, just play it again :-)

Naturally, you cannot use the numeric keypad to mask parts or [HOME CLR] to unmask all parts while entering numerical values.

Naturally (^^), you cannot use the numeric keypad to mask parts or [HOME CLR] to release all masks while entering numerical values. All other operations are OK.

===============================================================================
File selector function
===============================================================================

The channel mask function is not available in the file selector mode.

(Because the BS key and other keys overlap.)

The rest of the operations are all possible.

Press the L key to display the list of drives.

Use the cursor keys to select a drive, and press the Return key or the

Press the L key to display the list of drives.

===============================================================================
Display of error and PCM definition information
===============================================================================

If you use PMDB2.COM, PDR.COM, or PPSDRV.COM and hear the corresponding data

If you are using PMDB2.COM, PDR.COM, or PPSDRV.COM and hear the corresponding data, the error message about PPC, P86, or PPS data (ADPCM, PCM, or SSGPCM data) will be displayed.

A single letter of the alphabet appears in the lower left corner of the screen, just left of the function display.

The letters in ( ) mean that the color is reversed.

P(Yellow)  PCM (P86) being defined (^^.)
P(Green)  PCM file is matched, so it is not read.
P(red)  PCM memory is being accessed by another application.
F (red)  PCM (PPS, P86) file is not found.
R (red)  PCM (PPS, P86) file cannot be read.
E (red)  PCM (PPS, P86) file is not PMD's.
O (red)  The data of PPS exceeded the reserved area.
8 (red)  P86 data exceeded the reserved area.
A (red)  ADPCM is not installed or PMDB2 is not resident.
S (red)  PDR and PPSDRV are not resident.
M (red)  The song data buffer has been overloaded.

In other words, if something appears in red in the lower left corner, it means "no good" (^^;

If you have any good display method, please let me know.

If you have a better way to display it, I would be very grateful.

I don't like to say "I don't play because there was no PCM file. (^^;

(^^;) I don't like to say "I don't play because there was no PCM file", so I just show the error message and force to play.

===============================================================================
About external characters
===============================================================================

I'm using external characters from 7621h to 7639h.

I've saved them properly and put them back, but I'm not sure if I'm getting HSBs while PMDPV is running, or if I'm turning the printer off and on and then restarting it.

However, if the printer is turned off and rebooted while the PMDPV is running, the external characters cannot be restored.

However, if the printer is turned off and rebooted while PMDPV is running, the external characters cannot be restored (^^), so be careful.

Well, I don't think there is any important data in Gaiji.

===============================================================================
Copyright and so on
===============================================================================

This software is freeware. There is no copyright waiver.

The author is not responsible for any disaster or disorder caused by the use of this software.

The author is not responsible for any damage caused by using this software;

It is not allowed to use this software for commercial purposes.

The author is not responsible for any damage caused by the use of this software.

However, there are no restrictions on the use of PMD as a bonus for listening to music on music discs, games, etc. Please feel free to do so (^^)

===============================================================================
About reprinting
===============================================================================

It's not a big deal, but if I write something like this, people will think, "Damn! I'm not a big fan of this.

I don't really want to write about it (^^;))

I don't want to write too much about it because people will think, "Damn! (I've never written anything like this before.) If you are interested in reprinting this article

If you want to reprint it, please feel free to do so (^^).

Of course, the implicit condition is that the PMD on which this PMDPV can work has already been reprinted (^^)
(Also, please don't change the contents of the archive.

If you are in a situation where you can contact me, please send me an e-mail, even if it's just an after-the-fact report.

If you can contact me, please send me an e-mail. I think. I hope you can send me an email.

DOC to see if it's reprintable or not (lol)

DOC to see if it can be reprinted. ===============================================================================
DOC.
===============================================================================

I've been using PMDPV since the beginning of the project.

I wanted PMDPV to be "natural", or "airy", or something that people could use very naturally.

It is unthinkable (unbearable) that I don't have FD (File & Directory) or LHA in my computer environment now.

I can't imagine (or bear) not having FD (File & Directory) or LHA in my computer environment. However, I'm still far from being able to do that (;_;))

I'll keep reviewing the screen structure, display parameters, and functions.

And I'd like to keep in mind the importance of parameter readability and content.

I'll keep in mind the importance of parameter visibility and content.

I'm sure you have some complaints and bugs (^^;)

If there are any functions or display parameters that you would like to see increased, please let me know.

I'd be very happy to hear from you.

I'd like to have more programming power~(;_;)

In making this, I referred to KAJA's various source lists related to PMD.

I used KAJA's various PMD-related source lists as a reference.

I used PCMLOAD.INC as is for the PCM definition part (^^;

I also used the disk reading routine DISKPMD.INC to search for the environment variable "PMD".

INC to search for the environment variable "PMD" (^^;)

I would like to thank KAJA for all his help.

I would like to take this opportunity to thank you. Thank you very much.

I would like to thank the following people for their comments and advice on this program.

Thank you very much. (__)Peck

     Special Thanks to GRRIFIN-san
                 K.Saruyama-san
                 Pasorin-san
                 Ms. Odo
                 Shiori Ueno
                 CHEMOOL-san
                 NEO-san
                 KONO-san
                 NNI_STAR!
                 KATSUKI-san
                 NOGICHAN
                             Mr. Moe
                             K-3 (in no particular order)

                Other people who sent me e-mails with their impressions
                It encourages me to develop this program.

I'm very happy to have the support of so many people.

"When I receive an email saying "I'm using it. I'm very happy when I get an email saying "I'm using it" (;_;)

At first, I was hoping that this program would be useful to KAJA, even if only a little.

But while I was making it, I found that it was helping me in the opposite direction...(;_;)

What a pity.

One day, I met KAJA and I was so impressed by his music that I came to this point.

I'm happy to be able to listen to cool songs on PMD...

Wishing for the further development of PMD.

                      1996. 4. planet Anthea (;_;)( ANT00318 )
                            PMD-BBS ( LEIROS )
                        Tokyo BBS ( LEIROS )
                        SILENCE-CHIKKI NET ( SIL0013 )
                        Other (^^;

                                LEIROS

 =========================================
    History of P.M.D. Parameter Viewer
                                   As of April, 1996

Ver.0.0 It would be nice to be able to see the PMD performance. I thought it would be nice to be able to see the PMD performance, so I worked on the screen structure.

Ver.0.1 At first, I made a screen and displayed all parameters in hexadecimal.

~~~~~~~~~~~~~~~~~~~~~ Not disclosed so far (^^;) ~~~~~~~~~~~~~~~~~~~~~~~~~

Ver. 0.2 The basic display was completed, but the loading of the song data was not completed.
         It relied on PMP (PMD player) to read song data.

Ver.0.21 LFO Switch and Portament Switch 0 and 1 were reversed.
         Ver.0.21 LFO Switch and Portament Switch 0 and 1 were reversed, and the spelling of "Driver" was wrong;

Ver.0.3 It can read songs and check PMD resident.

Ver.0.31 Fixed a bug that the display of "E" and "F" in FM part was wrong.

Ver.0.4 Display the envelope of PSG part.

Ver.0.41 Add channel off function.

Ver. 0.42 Turned off by the channel off function, and can be turned back on again.

Ver. 0.43 Display the panning of the FM sound source.
         Fixed a bug that the file name could not be read if it had more than 15 characters.

Ver.0.5 Add some decoration to the screen. (^^;

Ver.0.51 Add a level meter.
         Fixed a bug that the level meter was not displayed correctly in 20-line mode.

Ver. 0.52 Added "red zone" to the level meter.
         Changed PCM part display to musical scale.
        (I used to use normal sound source until then.
         Renamed "EFFECT" to "Rhythm".
         Change the PSG envelope parameters from -128 to +127 except for AL, DR, and RR.
         Ver.0.53 PSG Envelope

Ver.0.53 PSG envelope parameters DL and DV are changed to display from -128 to +127.
         Level meter adjustment, color coding
         Display the name of the file currently being played.
         Add channel ALL ON function.

Ver.0.6 Add /L option to hide the level meter.
         Abolished PSG envelope display.
         Displays the currently played measure, status, and various addresses.

Ver.0.61 Use VSYNC interrupt (I didn't do it until now. (^^;)
         Improvement of PMD resident check.
        (Thanks to KAJA for the routine.)

Ver. 0.62 Review of graphics default settings.
         Ver.0.62 Reviewed graphics default settings.

Ver. 0.63 ESC can be used to quit while the game is stopped.

Ver. 0.63b Display of playing time and loop time.
         Abolish the data storage address display.

Ver.0.63c Bug fix of playing time display, stop playing by space key.

Ver. 0.63d Fixed a bug in the playing time display.
         When you start playing, wait until the correct time is reached, and make the playing time display accurate.
         However, it didn't feel right to use, so it was put in storage (^_^;)

Ver.0.7 for PMD Ver.3.9c
         Enables to display PCM pan and adjust tempo.
         Enhanced rhythm sound source related display.

Ver.0.71 Bug fix of PCM scale display
         When SHIFT+ESC is pressed, the performance is terminated as it is.

Ver. 0.72 "Q" will also end the performance.
         Bug Fix: Kanji file names could not be displayed.

                   A
Ver. 0.8 The key (black key) can be displayed as either sharp or odd.
         (In addition, the key display is changed to lowercase.
         The HELP key can be used to invert the part mask.
         (The above two points are ideas of Mr. Kono's MXPV (^^))
         Make the drawing speed of the initial screen faster (^^.)

Ver.0.8k Add keyboard display function.
         Initialized graphics and improved settings.

Ver.0.81 for PMD Ver.4.0b
         Added pause function by adding PMD's pause function.
         SSG tone display is changed to Tone Noise Mix.
         Improved the keyboard display routine a little.

Ver.0.82 Added /K option not to wait for space key
         Keep the inversion of the tone and the sharp tone /+ option added
         Playback can be finished with f and 10.
         Pause can also be done with the / key (numeric keypad).
         Change "CraC" to "RidC" and "LTom" to "MTom" in the drum display when using the \ command.

Ver. 0.82b Changed the option to be either before or after the file name.
         Add "/P" option to display the viewer screen without loading the performance data.

Ver.0.83 for PMD Ver.4.0i
         Add comment function of PMD to display comments.
         PLAY, STOP, and PAUSE are displayed according to the flag whether it is playing or not.
         Improved the operation at the time of starting by /P option.

Ver. 0.83b Support ESC sequence character in comment field.

Ver. 0.83c Make it possible to read PCM data.
         (Thanks to KAJA for the routine.)

Ver.0.83d For PMD Ver.4.1
         Changed PCM reading routine because PCM reading relation has been enhanced.

Ver. 0.83e PMD now has a part mask function.
         The PCM reading routine has been further enhanced.
         The PCM reading routine has been enhanced and incorporated (^^.)

Ver. 0.83f PCM reading routine now reads PPS files.
         Also incorporated (^^;;
         When a data file is not found, the environment variable is checked and
         (This routine was also provided by KAJA.
         (This routine was also given by KAJA (^^;;;))

Ver.0.83g Do not read PCM/PPS data /A option added
         The work of LFO switch and portamento switch has been changed.
         The PCM reading routine has been changed again in PMD Ver.4.3.
         Added a new routine that was given to me.
         Fixed a bug that the performance time is set to 00:00:00 when part masking.
         FM3b, c and d can be masked in PMDB2.COM.

Ver.0.83h PCM reading routine is a little faster. Also embedded (^^;

Ver.0.83i for PMD Ver.4.4
         PCM data reading is now super fast, so it is embedded again (^^.)
         Display the volume down values of FM, SSG, PCM and Rhythm.

Ver.0.83j Fixed a bug in displaying the volume down value.

Ver.0.83k Add /B? option to fast-forward to the specified measure at the start of playing.

Ver.0.83l Extend the rhythm display for SSG PCM.

Ver. 0.83m Added measure display and fast-forward option for PMD, since the measure function relation of PMD was extended to 2 bytes.
         The measure display and fast-forward options are adapted to it.

Ver.0.83n Automatically detects PMDB2 and PMD86 and displays PCM scale.

Ver. 0.90 Rewrote source code from scratch. (But I used the previous version.
         Save interrupt vector of stop key (^^.)
         modified the chain processing of PMD's Timer-A interrupt (^^.)
         Change the volume down value.
         Add 1-bar skip function.
         Read mask status when starting with /P option(^^;

Ver.0.90b Add measure jump function.
         Fixed a bug that RimShot was not displayed in Ver.0.90;

Ver.0.90c PSG noise average frequency is displayed.
         Bug fix for /K option(;_;)

Ver.0.90d Fix a bug that the measure jump before the start of the performance was not correct(^^;

Ver.0.90e Adjust the start-up when no option is set.

Ver.0.90f Added the gate time display.
         The display of the volume was made to correspond also to the W command and so on.
         added the processing when the song data exceeds the performance buffer.
         (I used the file "pmp.asm" as a reference.)

Ver.0.91 for PMD Ver.4.7a
         Changed according to various changes in the performance work.
         Made it more graphical ( and eliminated the /L option)
         Improved processing differences between PMD, PMDB2, and PMD86 (mask-related)
         Added support for changing songs by PMK after starting PMDPV (slow)
         Various other details (rewind, save file name, display PCM file name, etc.)

Ver.0.92 Add filer function.
         Fixed a bug that garbage appears on the screen when changing songs with PMK after starting PMDPV (^^.)
         Abolished /B option.

Ver.0.92b Fixed bugs related to mask and pause when reading song data in filer mode.
         pause-related bugs when loading song data in filer mode;
         Fix the bug of level meter in filer mode;
         Supported Kanji characters for path names and PCM file names in filer mode;

Ver.0.92c Fix a bug of PCM pan display when PMD86 is resident;
         Display of file name in filer mode.

Ver.0.92d Not for public release (^^;), some functions are added only in this version.

Ver.0.92e Added PCM load routine function for PMDPPZ for 94'Winter Comic PMD.

Ver.0.92f Added processing when the number of files is maximum in filer mode.
         In filer mode, files with read-only attribute and hidden attribute are also searchable.
         file search.
         Added a function to return after selecting a song in filer mode.
         Added support for "c 9".
Ver. 0.92g Added display of LFO2 (LFO B) and LFO switch 2.
         Changed pan display from text to arrow (?). to an arrow (?).
         Changed the time display to digital characters.
         Changed layout of time and status section.
         Fixed a bug that T  t conversion was not working well (^^.)

                    I often go to the net to play (^^)

                      1996.4. Planet Anthea (;_;) ( ANT00318 )
                            PMD-BBS ( LEIROS )
                        Tokyo BBS ( LEIROS )
                        SILENCE-CHIKKI NET ( SIL0013 )

                                 LEIROS
============================================
EXE in PMDPV92G.LZH in the same directory, and then execute TXTPV92G.COM.

TXTPV.EXE will be created.

After I made PMDPV graphical, some people asked me to keep the text version.

So, here is the text version.

It's text-only, no graphics.

The differences from the graphic version are

The level meter has been removed.

The keyboards have been removed.

The list of files in the filer screen has one more line.

I can't tell the version number or who made it without looking at the "usage" page.

It's like this.

The empty space after the measure number display is where you type in the measure jump number.

It's the kind of thing where you press TAB and enter a number.

I think it's hard to see the title, etc. (^^;

If I mask it, it turns blue, but I don't know. If it's all black, it's a bit awkward to see without a background like the graphic version.

It's a little scary when there is no background like in the graphic version. I think it's better to use x as before.

I'm not sure if it's better to use x as before.

"I'm not sure if it's the same as the previous version;

If you think something is wrong, don't hesitate to contact me. If you think something is wrong, please don't hesitate to let me know (^^ thank you very much).

I used WSP (c) Wakichi to create the self-extracting file.

LEIROS

================
==============================================================================
                     PMD for Windows "PMDWin" Ver.0.36
                        Copyright & Programmed by C60
==============================================================================

------------------------------------------------------------------------------
Introduction

    This program is a dll to listen to the song data of the FM sound source driver "PMD98" for the PC9801 series on Windows.
    This program is a dll to listen to the song data of PMD98 FM sound driver for PC9801 series on Windows,
    It supports all PMD98 song data (PMDB2, PPSDRV, P86DRV, PPZ8).
    It is not possible to make it play only by this dll.
    Please get a player separately.

------------------------------------------------------------------------------
Installation and uninstallation

    (a) Installation
        Place PMDWin.dll in c:\windows\system or c:\winnt\system32 or the same directory as the player.
        Place it in the same directory as the player.
        To play the YM-2608's rhythm sound source, place the following wave file
        (44100Hz, 16bit, monoral. Only PCM format can be used.
        Place the following wave file (44100Hz, 16bit, monoral, cannot use other than PCM format) in the directory specified by the player.

            2608_BD.WAV ;Bass drum
            2608_SD.WAV ;Snare Drum
            2608_HH.WAV ;Hi-Hat
            2608_TOP.WAV ;Cymbal
            2608_TOM.WAV ;Tom
            2608_RIM.WAV ;Rim Shot

    (b) Uninstallation
        Delete this dll with Explorer, etc.
        Delete the player, wave files, etc. if they are not needed.

------------------------------------------------------------------------------
Operation check environment

    Self-made AT compatible machine (Asustek P5B, Core2Duo 6600, GeForce 9500GT,
                    Built-in SoundMax Integrated Digital HD Audio, etc.)
             WindowsXP SP3, synthesized frequency = 55kHz

    Lenovo Thinkpad X200 (Core2Duo P8600, built-in Conexant 20561 SmartAudio HD)
            + Windows7 composite frequency = 55kHz

------------------------------------------------------------------------------
About embedded software

    PMDWin.dll contains an FM sound engine (fmgen 008) written by cisc.
    FM Sound Generator with OPN/OPN

        FM Sound Generator with OPN/OPM interface
        Copyright (C) by cisc 1998, 2003.

------------------------------------------------------------------------------
Terms of Use & Reprint

    This software is free software. The copyright of this software is owned by C60.
    However, the copyright of the original FMP is owned by Mr. Guu, the copyright of PMD98 is owned by Mr. KAJA, the copyright of PPZ8 is owned by
    PPZ8 copyright by Ukky, FM sound engine copyright by cisc, BrowseDialog component copyright by
    Copyright of the BrowseDialog component by Mr. Maeda, Copyright of the color changeable track bar by
    copyright by Fumika, TrayIcon component copyright by Yukio Tsujihara.
    (modification and support by Taro Kato).
    WinFMP, PMDWin and FMPMD2000 are not liable for any loss of data or damage to the machine caused by using them.
    WinFMP, PMDWin and FMPMD2000.
    The authors are not responsible for any bugs or defects in WinFMP, PMDWin or FMPMD2000.
    The author is not obligated to fix any bugs in WinFMP, PMDWin or FMPMD2000.
    The author is not obligated to fix any bugs in WinFMP, PMDWin or FMPMD2000, but will make every effort to fix them if you report them.
    Reproduction or distribution of WinFMP, PMDWin and FMPMD2000 is prohibited. However
    However, modifications to the source code of PMDWin and FMPMD2000 are
    PMDWin, FMPMD2000 source code.
    Software incorporating the source code of PMDWin and FMPMD2000 may be
    PMDWin, FMPMD2000 source code can be released as free software with prior notice.
    Software that uses WinFMP.dll and PMDWin.dll can be released as free software.
    Please contact the author before publishing. Please contact the author when you release the software.
    If you wish to incorporate part or all of the source code of PMDWin or FMPMD2000 into commercial software (including shareware)
    or all of the source code of PMDWin or FMPMD2000 into commercial software (including shareware), you need to obtain prior consent from the author of PMDWin or FMPMD2000.
    PMDWin, FMPMD2000.
    When distributing software with modifications to PMDWin or FMPMD2000, the copyright notice of PMDWin or FMPMD2000
    If you distribute modified versions of PMDWin or FMPMD2000, please clearly indicate the copyright of PMDWin or FMPMD2000 and the modifications.
    *.cpp or *.pas(WinFMP.pas, PMDWin.pas, PCMMusDriver.pas,
    FMPMDdefine.pas) that are related to music performance, or if you wish to modify them.
    If you wish to incorporate or modify any part of these files, please disclose the source code.

------------------------------------------------------------------------------
Acknowledgments

    I would like to express my gratitude to Guu for creating FMP, a wonderful sound source driver, and allowing me to publish this program.
    Mr. Guu, who created the wonderful sound driver FMP and allowed me to publish this program.
    Mr. Guu for creating the excellent FMP sound driver and allowing us to publish this program, and Mr. KAJA for creating the sophisticated PMD sound driver and allowing us to publish this program.
    Mr. KAJA, who created PPZ8 and allowed us to publish this program.
    Mr. Guu, who not only created PPZ8 and expanded the expressive power of the sound driver, but also
    Ukky, who not only created PPZ8 and expanded the expressiveness of the sound driver, but also provided the source and allowed us to publish the program.
    Ukky, who not only created and used a high-performance FM sound engine, but also allowed us to publish the program.
    Ukky, who not only created and used a high-performance FM sound engine and allowed us to publish this program, but also fixed bugs in PMDWin.
    cisc, for finding many bugs in PMDWin.
    TAN-Y for finding many bugs, and
    Mamiya who made the WinAMP plugin, and
    Kigami who made PMV, and
    Mr. Maeda and Ms. fumika for releasing useful components.
    Thank you very much for bug reports, valuable comments, and requests.
    Thank you very much.

------------------------------------------------------------------------------
 History

ver.0.01 1999/08/02
    Provisional version released.

ver.0.02 1999/08/04
    The sound engine is changed to M88 Ver2.10.
    Fixed a bug that the rhythm does not sound when synthesized at 55KHz.

ver.0.03 1999/08/08
    #LFOSpeed Extend bug fix (>TAN-Y)
    #Detune is doubled when using Detune Extend bug fix(>TAN-Y)
    Relative tempo setting may cause wrong tempo bug fix (>cisc)
    LFO2 delay setting bug fix (>cisc)
    Fix project settings
    Envelope fix x2 (by >TAN-Y)
    Replaced with ver.4.8o (random Q support etc.)
    Added support for reading pvi with ADPCM
    Provisional support for P86 -> PVI Rename
    ADPCM filename can be read from outside
    Tentatively dealt with bug of pitch shift when using _M and x together
    fixed ADPCM volume bug (by >cisc)
    Mix signed and unsigned in fmlfo_sub bug fix (>cisc)

ver.0.04 1999/08/16
    fix SJIS in PCM folder
    Some inequality signs are reversed in _vd_fm(), _vd_ssg() etc. bug fix
    Implementation of SSG drum
    Lighten the weight (limit the range of memset).
    Bug fix for OPNA Rhythm relative volume and pan change
    Bug fix for ADPCM Repeat
    LFO bug fix
    Change work to int
    #? When playing a song that uses _Voldown, it sometimes goes wrong.
    Implementation of fadeout
    You can set whether the rhythm sound source is played at the same time as SSG drum.
    Hardware LFO was not working bug fix

ver.0.05 1999/08/29
    added support for PPZ8
    Support 11kHz, 22kHz playback.
    added support for 2-byte half-width to half-width conversion and escape sequence removal
    Noise frequency may not be set bug fix
    Volume LFO bug fix
    W- bug fix
    Dynamic generation of ppc and p86 file buffers
    Replace with M88 2.11 unit
ver.0.06 1999/09/19
    PPZ8 part portamento bug fix
    Rhytym wave path can be specified.
    y command bug fix
    TimerB setting value was slightly off. bug fix
    Pan setting for C and FM3 ch could be off bug fix
    Force PCM reading.
    Bug fix ADPCM loop
    Internal changes in PCM search part
    Reduce weight of PPZ8 unit
    Replaced with M88 2.12(+) unit
    wrote the specification of DLL

ver.0.07 1999/10/03
    Support PPS
    The setting of the playback position was made possible.
    The weight reduction of the PPZ8 unit part 2
    Countermeasure against zero percent of PPZ8 unit?
    Bug fix of relative volume change(\v?-) of OPNA Rhythm
    Changed to force o1,o8 when o1~o8 is off in the modulation command.
    Bug fix: DepthA of LFO is negative.

ver.0.08 1999/10/24
    The frequency setting mistake of PPZ8 is corrected.
    Reduction of petit noise of PPSDRV
    Bug fix of detuning of PPSDRV
    The noise might have entered at the time of the tone change in the FM part.
    (Thanks > Mr. cisc)
    There was a thing that noise enters when it sets it after it stops playing by setpos() bug fix

ver.0.09 1999/11/20
    Support P86
    lighten the weight of PPZ8, save memory
    Support fadeout and fadeout2
    MML "" and "'" command does not work properly in SSG, ADPCM and PPZ part.
    Bug fixes
    Fixed bug in setpos() that it did not fix the problem of setting after the performance was stopped.
    bug fix: setpos() could sometimes cause tone distortion.
    Change DLL calling convention from cdecl to stdcall.

ver.0.10 1999/11/28
    The (AD)PCM part might not sound when P86 and PPC are forced to read. bug fix
    Reduce petit noise of PPSDRV
    implementation of getlength and getlength2

ver.0.11 1999/12/18
    The change width of a random LFO was not small.
    In PPZ8, there was a case that the sound came out at the time of v0 bug fix
    The key is sometimes turned on when it is connected with the tie.
    (> Mr. cisc)
    Hardware LFO did not cut at #0 bug fix (> Mr. cisc)

ver.0.12 2000/01/10
    replaced with M88 2.14 unit (extra chunks in rhythm wave)
    Fixed a bug that the program crashes when pmdwininit(NULL) is executed.
    Fix PPZ8's small noise?

ver.0.13 2000/02/06
    switched to VC++ 6.0 Pro
    Fix a bug that setppsuse(true) may cause an access violation.
    When PPS and SSG 3ch(Ich) are used at the same time, there was a case that noise enters.
    Bug fix
    Fixed a bug that extra information was displayed in the memo of sam1.m.

ver.0.14 2000/03/19
    PCM part of PMD86 did not work properly when portamento was used.
    Fixed bug
    Fixed a bug in getlength(), getlength2() that the length of the song was calculated wrongly.
    Added WINAPI to getlength() and getlength2() because I forgot to add it.
    Fixed a possible memory leak in setpcmdir().
    Fixed an embug in FM part due to noise when switching tones.
    Added fgetmemo system.
    added music_load2()
    Replaced with M88 2.16x unit

ver 0.15 2000/06/11
    Add getloopcount().

ver 0.16 2000/08/20
    Fix a bug that SSG3ch may key off even if it is connected with &.
    (Enbug in ver 0.13?).
    Fixed a bug that the pitch of SSG noise may change when replaying.
    Fixed a bug that SSG noise could change pitch when replaying.
    in release)
    Fixed a bug that there was an access violation in getmemo2, getmemo3, fgetmemo2, and fgetmemo3.
    Fixed a bug that caused access violation in
    Fixed a bug where the behavior of fgetmemo2 and fgetmemo3 was reversed.
    Fixed a bug that the spelling of WARNING was wrong.
    Fixed a bug that the result of getlength was slightly different every time.

ver 0.17 2001/01/21
    Implement COM-like interface.
    implemented setfmcalc55k(). setpcmrate() can be used to set not only 11kHz, 22kHz, 44kHz, 55kHz
    other than 11kHz, 22kHz, 44kHz and 55kHz with setpcmrate().
    Implemented setppzrate().
    Improved error checking when song data is invalid in getmemo series.
    Speeded up setpos() and setpos2() processing when the position is set before the current playback position.
    setpos() and setpos2().
    Fixed a bug in which ppz8 sound was not played when playing and getlength() were executed in separate threads at the same time.
    fixed.

ver 0.18 2001/02/17
    Fixed a bug that the sound may become strange when multiple instances of PMDWin are used.
    Replaced with OPNA new core (fmgen001.tar.bz 2000/09/09)

ver 0.19 2001/03/04
    Fixed a bug that a memo could not be read when it was retrieved from an external file by the fgetmemo() system.
    Fixed a bug.
    Replaced by OPNA new core (fmgen003.tar.bz 2001/02/24).
    Speedup option in opna.cpp (#define FM_USE_CALC2, FM_USE_CALC2E,
    NO_BITTYPE_EMULATION) in opna.cpp because I forgot to define them.
    In getlength() and getlength2(), forced to terminate the calculation if the clock is more than 65536.
    when the clock is more than 65536.
    The buffer is now filled with the exit code before reading song data.
    (To prevent illegal song data)
    In DLLinfop.txt, getversion() was mistakenly written as getdllversion().
    Fixed it.

ver 0.20 2001/08/05
    Replaced with OPNA new core (fmgen006.tar.bz 2001/03/30).
    Fixed a bug that the sound of SSG Drum may cut off when SSG 3ch(Ich) and SSG Drum are used at the same time.
    When SSG 3ch(Ich) and SSG Drum are used at the same time, the sound of SSG Drum is sometimes cut off.

ver 0.21 2001/09/16
    Fixed a bug that an access violation occurs when loading a song whose data does not end with 00.
    Fixed a bug.
    Clear the buffers of PPC, PZI, P86 and PPS by pmdwininit().

ver 0.22 2001/09/30
    Fixed a bug that could cause an access violation in PPC, PZI, P86 and PPS.
    Fixed a bug that consumed a lot of stack.

ver 0.23 2001/11/17
    Improve the speed of DLL operation when many threads are used.
    Fix a mistake in pmdwinimport.h

ver 0.24 2002/03/24
    added support for playing only FM part of TOWNS song data
    The file name of the song is stored in the internal buffer even when the PCM reading fails.
    file name to the internal buffer even when PCM reading failed.
    Memory leak occurred when loading PVI with invalid header into PPZ8.
    Fixed a bug.

ver 0.25 2002/08/03
    It was made to read PPS even when the extension of PPS was omitted in the song data.

ver 0.26 2002/08/04
    Fixed a bug that PPS could not be read when the extension of PPS is other than "PPS" in the song data.

ver 0.27 2002/09/22
    Fixed a bug that memory leak occurred when PPZ8 read PVI with invalid header.
    Fixed a memory leak when loading a PVI with invalid header into PPZ8.

ver 0.28 2002/10/27
    Fix the volume balance of P86.

ver 0.29 2003/03/09
    Fixed that the pan was not initialized when P86 was played again.

ver 0.30 2003/06/22
    incorporated fmgen 007a

ver 0.31 2003/08/03
    fixed a bug that setfmcalc55k was not working anymore
    Fixed a bug in getmemo3 / fgetmemo3 that could cause a memory leak when the acquisition string was 0 bytes.
    Fixed a bug in getmemo3 / fgetmemo3 that could cause a memory leak when the get string was 0 bytes.

ver 0.32 2003/08/13
    Fixed a bug that the return value of the getmemo API was wrong.

ver 0.33 2003/09/28
    incorporated fmgen 008

ver 0.34 2003/12/07
    Fixed a bug that may cause a small noise when replaying.

ver 0.35 2004/01/10
    Volume LFO when using slot mask for LFO2 in FM part
    (when MMB and one of *B2,*B3,*B6,*B7 are used together) did not work properly.
    (when MMB and *B2, *B3, *B6, or *B7 are used together) did not work properly.
    Fixed a problem in which a negative relative value was specified for TL value in the FM part TL value setting command (O command).
    TL value setting command (O command) did not work correctly when a negative relative value was specified for TL value.

ver 0.36 2010/01/11
    Changed the volume of SSG to 86 board equivalent.
    Changed the synthesized frequency from 55555Hz to 55466Hz at 55kHz.

ver 0.37 2020/01/12
    Reflected the modification of PMD 4.8r.
ver 0.38 2020/04/12
    Reflects fixes in PMD 4.8s
    Fixed a bug that prevented normal playback of some song data.
    Fixed a bug in which noise could be introduced in the primary interpolation process.
    Fixed an error in which some API return values were wrong when loading song data.
    Stabilized the operation.
    Many other fixes.

ver 0.39 2020/08/16
    Fixed a bug in the clipping process of MD command.
    Fixed the bug that wait was not applied when writing ADPCM register.
    Fixed the bug that the sound becomes abnormal when writing the ADPCM playback address.

------------------------------------------------------------------------------
Contact information

    E-mail HQD00151@nifty.com
    Homepage http://c60.la.coocan.jp/
    Twitter c60fmp

                                                                C60
=======================
==============================================================================
                     FMP for Windows "WinFMP" Ver.0.18
                        Copyright & Programmed by C60
==============================================================================

------------------------------------------------------------------------------
Introduction

    This program is a dll to listen to the song data of the FM sound source driver "FMP" for PC9801 series on Windows.
    This program is a dll to listen to the song data of the FM sound driver "FMP" of the PC9801 series on Windows.
    It is not possible to play the music only with this dll. Please get a player separately.

    From this version, PDZF/Z8X for Windows (created by TAN-Y) is officially supported.
    (PDZFZ8XWin requires Ver. 2.0.0 or later. Ver. 1.1.0 cannot be played.

------------------------------------------------------------------------------
Installation and Uninstallation

    (a) Installation
        Place WinFMP.dll in c:\windows\system or c:\winnt\system32 or
        Place it in the same directory as the player.
        To play the YM-2608's rhythm sound source, place the following wave file
        (44100Hz, 16bit, monoral. Only PCM format can be used.
        Place the following wave file (44100Hz, 16bit, monoral, cannot use other than PCM format) in the directory specified by the player.

            2608_BD.WAV ;Bass drum
            2608_SD.WAV ;Snare Drum
            2608_HH.WAV ;Hi-Hat
            2608_TOP.WAV ;Cymbal
            2608_TOM.WAV ;Tom
            2608_RIM.WAV ;Rim Shot

        If you want to use it with PDZF/Z8X for Windows, place it in the same directory as WinFMP.dll
        If you use it with PDZF/Z8X for Windows, please put PDZFZ8XWin.dll(Ver.2.0.0 or later) in the same directory as WinFMP.dll.
        From this version, please do not rename PDZFZ8XWin.dll and WinFMP.dll.
        Please leave them as they are.

    (b) Uninstallation
        Delete this dll using Explorer or similar.
        Delete the player, wave files, etc. if they are not needed.

------------------------------------------------------------------------------
Operation check environment

    Self-made AT compatible machine (Asustek P5B, Core2Duo 6600, GeForce 9500GT,
                    Built-in SoundMax Integrated Digital HD Audio, etc.)
             WindowsXP SP3, synthesized frequency = 55kHz

    Lenovo Thinkpad X200 (Core2Duo P8600, built-in Conexant 20561 SmartAudio HD)
            + Windows7 SP1 composite frequency = 55kHz

------------------------------------------------------------------------------
 About embedded software

    WinFMP.dll contains an FM sound engine (fmgen 008) written by cisc.
    FM Sound Generator with OPN/OPN

        FM Sound Generator with OPN/OPM interface
        Copyright (C) by cisc 1998, 2003.

------------------------------------------------------------------------------
Terms of Use & Reprint

    This software is free software. The copyright of this software is owned by C60.
    However, the copyright of the original FMP is owned by Mr. Guu, the copyright of PMD98 is owned by Mr. KAJA, the copyright of PPZ8 is owned by
    PPZ8 copyright by Ukky, FM sound engine copyright by cisc, BrowseDialog component copyright by
    Copyright of BrowseDialog component by Mr. Maeda, Copyright of Color Changeable Trackbar by
    The copyright of PPZ8 is owned by Ukky, the copyright of FM sound engine is owned by cisc, the copyright of BrowseDialog component is owned by Maeda, and the copyright of color changeable trackbar is owned by Fumika.
    WinFMP, PMDWin, and FMPMD2000 are copyrighted by the author.
    WinFMP, PMDWin and FMPMD2000.
    The authors are not responsible for any bugs or defects in WinFMP, PMDWin or FMPMD2000.
    The author is not obligated to fix any bugs in WinFMP, PMDWin or FMPMD2000.
    The author is not obligated to fix any bugs in WinFMP, PMDWin or FMPMD2000, but will try to fix them if you report them.
    Reproduction or distribution of WinFMP, PMDWin and FMPMD2000 is prohibited. However
    However, modifications to the source code of PMDWin and FMPMD2000 are
    PMDWin, FMPMD2000 source code.
    Software incorporating the source code of PMDWin and FMPMD2000 may be
    PMDWin, FMPMD2000 source code can be released as free software with prior notice.
    Software that uses WinFMP.dll and PMDWin.dll can be released as free software.
    Please contact the author before publishing. Please contact the author when you release the software.
    If you wish to incorporate part or all of the source code of PMDWin or FMPMD2000 into commercial software (including shareware)
    or all of the source code of PMDWin or FMPMD2000 into commercial software (including shareware), you need to obtain prior consent from the author of PMDWin or FMPMD2000.
    PMDWin, FMPMD2000.
    When distributing software with modifications to PMDWin or FMPMD2000, the copyright notice of PMDWin or FMPMD2000
    If you distribute modified versions of PMDWin or FMPMD2000, please clearly indicate the copyright of PMDWin or FMPMD2000 and the modifications.
    *.cpp or *.pas(WinFMP.pas, PMDWin.pas, PCMMusDriver.pas,
    FMPMDdefine.pas) that are related to music performance, or if you wish to modify them.
    If you wish to incorporate or modify any part of these files, please disclose the source code.

------------------------------------------------------------------------------
Acknowledgments

    I would like to express my gratitude to Guu for creating FMP, a wonderful sound source driver, and allowing me to publish this program.
    Mr. Guu, who created the wonderful sound driver FMP and allowed me to publish this program.
    Mr. Guu for creating the excellent FMP sound driver and allowing us to publish this program, and Mr. KAJA for creating the sophisticated PMD sound driver and allowing us to publish this program.
    Mr. KAJA, who created PPZ8 and allowed us to publish this program.
    Mr. Guu, who not only created PPZ8 and expanded the expressive power of the sound driver, but also
    Ukky, who not only created PPZ8 and expanded the expressiveness of the sound driver, but also provided the source and allowed us to publish the program.
    Ukky, who not only created and used a high-performance FM sound engine, but also allowed us to publish the program.
    Ukky, who not only created and used a high-performance FM sound engine and allowed us to publish this program, but also fixed bugs in PMDWin.
    cisc, for creating and using the
    PDZF/Z8X for Window, and also for finding many bugs.
    Mr. TAN-Y, who not only supported PDZF/Z8X for Window but also found many bugs.
    Mr. Mamiya for making WinAMP plug-ins, Mr.
    Mr. Kigami who made PMV, and
    Mr. Maeda and Ms. fumika for releasing useful components.
    Thank you very much for bug reports, valuable comments, and requests.
    Thank you very much.

------------------------------------------------------------------------------
 History

ver.0.01 2000/06/11
    First version released

ver 0.02 2000/08/20
    Q When the length of a note becomes an integer multiple of 256 clocks, the sound is cut off.
    Fixed a bug.
    Fixed a bug in which random LFO was not working properly.
    Fixed a bug in which the display was sometimes corrupted due to insufficient removal of escape sequences.
    Fixed a bug in which the wah-wah would return to 0 when the TL exceeded 127.
    Fixed a bug in which noise would sometimes appear when switching tones.
    Fixed a bug that the wait time when outputting to opna can be reproduced.
    in release)
    Fixed an access violation in fmp_getcomment2, fmp_getcomment3, fmp_fgetcomment2, and fmp_fgetcomment3.
    Fixed a bug that sometimes caused access violations in fmp_getcomment2, fmp_getcomment3
    WARNING was spelled wrongly, so it has been fixed.
    Fixed a bug where the result of fmp_getlength was slightly different each time.

ver 0.03 2001/01/21
    Implemented COM-like interface.
    Implemented fmp_setfmcalc55k(). fmp_setpcmrate() now supports 11kHz, 22kHz, 44kHz,
    other than 11kHz, 22kHz, 44kHz, and 55kHz with fmp_setpcmrate().
    Implemented fmp_setppzrate()
    Fixed possible access violation in fmp_getcomment3() and fmp_fgetcomment3()
    Fixed a bug.
    When a song ends while waiting for synchronization with the W command, fmp_getlength() could not determine the end of the song.
    Fixed a bug that caused fmp_getlength() to go into an infinite loop.
    Improved error check for fmp_getcomment when song data is invalid.
    Speed up fmp_setpos() and fmp_setpos2() when setting the position before the current playback position
    fmp_setpos() and fmp_setpos2().
    Implementation of fmp_getsyncscnt(), fmp_getlastsyncexttime()
    Improved processing speed of fmp_load()
    Fixed a bug that ppz8 sound was not played when playing and getlength() were executed in different threads at the same time
    Fixed a bug that the ppz8 sound could be lost if the performance and getlength() are executed in different threads at the same time.
    Faster processing at the start of a song that uses PPZ8
ver 0.04 2001/02/17
    Fixed a bug that the sound may become strange when multiple instances of WinFMP are used.
    Replaced by OPNA new core (fmgen001.tar.bz 2000/09/09)

ver 0.05 2001/03/04
    Fixed a bug in the fgetcomment() system that could not be read when trying to get a comment from an external file.
    Fixed a bug in the fgetcomment() system that could not be read.
    Replaced with OPNA new core (fmgen003.tar.bz 2001/02/24).
    Speedup option in opna.cpp (#define FM_USE_CALC2, FM_USE_CALC2E,
    NO_BITTYPE_EMULATION) in opna.cpp were off, so I defined them.
    In fmp_getlength() and fmp_getlength2(), if the clock is more than 65536
    fmp_getlength(), fmp_getlength2() now forcibly terminate the calculation when the clock is over 65536.
    The buffer is now filled with the exit code before reading the song data.
    (To prevent illegal song data)
    In DLLinfof.txt, fmp_getversion() was mistakenly written as fmp_getdllversion().
    In DLLinfof.txt, there was a place where fmp_getversion() was miswritten as fmp_getdllversion().

ver 0.06 2001/03/11
    Fixed a bug that the sound of random LFO was sometimes strange.

ver 0.07 2001/09/16
    Fixed a bug in the PPZ section that could cause an access violation if an invalid PVI was read.
    Clear PVI / PZI in fmp_init().
    Replaced with OPNA new core (fmgen006.tar.bz 2001/03/30).

ver 0.08 2001/09/30
    Fixed a bug that could cause an access violation in PPZ8.

ver 0.10 2002/01/14
    Add option to emulate ADPCM Part with PPZ8
    Speed up the reading speed of ADPCM PVI

ver 0.11 2002/01/19
    Bug fix: When emulating ADPCM part in PPZ8
    When emulating ADPCM part with PPZ8, fixed the bug that the sound was out of tune.
    Increased wait time to avoid noise when switching tones.

ver 0.12 2002/03/24
    Fixed a memory leak when loading a PVI with an invalid header into PPZ8.
    Fixed a bug.

ver 0.13 2002/09/22
    A memory leak occurred when PPZ8 loaded a PVI with an invalid header.
    Fixed a bug that had not been removed.

ver 0.14 2003/06/22
    Added fmgen 007a.

ver 0.15 2003/08/03
    Fixed a bug that fmp_setfmcalc55k was not working anymore
    Fixed a bug that fgetcomment / fgetcomment2 did not work properly.
    In fgetcomment2, when filename = NULL, the conversion from 2-byte to 1-byte
    filename = NULL in fgetcomment2.

ver 0.16 2003/09/28
    Added fmgen 008.

ver 0.17 2010/01/11
    Changed SSG volume to 86 board equivalent.
    Changed the frequency at 55kHz synthesis frequency from 55555Hz to 55466Hz

ver 0.18 2012/03/18
    Added official support for PDZFZ8X for Windows
    Fixed a bug of 3-line splitting.
    Fixed a bug in setpos2 that caused an infinite loop.
    Fixed a bug that the count of the whole song and the count of the song loop was wrong.

------------------------------------------------------------------------------
Contact information

    E-mail HQD00151@nifty.com
    Homepage http://c60.fmp.jp/

                                                                C60

==================================

m98 Command Reference (Japanese)
How to write in MML
{ conversion expression,conversion expression,... ,
A to K, or macro line
}
Points to note to prevent compilation errors
The conversion expression must be terminated with a comma.
Always leave a space between '{' and the conversion expression.
Only one channel or one macro should be converted.
Some MML such as T and ^ cannot be used. [Some MML such as T and ^ cannot be used.
Conversion Target Switches
Each conversion command has the following switches
-n note
-l note length
-@ tone number
-v volume
-q quantize
-m macro number
-{ portamento
-p pan
-k key (note) shift
-e sequence
Multiple switches can be written together in a single conversion expression.
Example
rand -nv@,
Convert n, v, and @ at random
Conversion command
rv -switch
Reverse
cdefgab -> bagfedc
mr -switch
Mirror
cdefgab -> cdefedc
rmr -switch
Reverse Mirror
cdefgab -> bagfgab
rr( n ) - switch
Rotate n times to the right
cdefgab -> bcdefga
rl( n ) -switch
Rotate n times to the left
cdefga -> defgabc
rand(n) -switch
Change the value of switch randomly, where n is its probability (%)
crand( n ) -switch
randomly change the position of the switch, where n is the probability (%)
Filter command
@grp( n1,n2... )
Set the tone used by the rand command
@grpl( n1,n2 )
Specify a range of tones to be used by the rand command
lgrp( n1,n2... )
Set the value of "l" to be used by the rand command
mgrp( n1,n2... )
Set the macro number used in the rand command
mgrpl( n1,n2 )
Specify a range of macro numbers to be used in the rand command
ngrp<octave+note, or all+octave
Example
ngrp<4c,4e,4g>,rand -n,
in this case chosen from c,e,g in octave 4 = randomly generated c major chord
ngrp<all5>.
In this case, chosen from all notes in octave 5
qgrp( n1,n2... )
Sets the value of q used by the rand command
kgrp( n1,n2... )
Sets the value of k to be used in the rand command
rfil( min,max )
Set the minimum and maximum values used in the rand command.
rep( min,max )
Sets the minimum and maximum number of repeats of a note.
Example
If you execute rep(1,3),rand -n, the following mml will be generated (note is random)
ccceeffffaabbbgg
mask( n1,n2... ) - switch
Mask the nth element specified by switch so that it is not converted
Subroutine
call(n)
Call subroutine n
mcopy(n)
Copy the macro number n
Initialization command
preserve -switch
Preserve the length, volume, etc. of the last sound of MML in the macro, and append them to the end of the converted MML.
Command to prevent the following cases
o5cdefgab>c  crand -n,  o5cedf>c<gab
Before the conversion, the sound following this MML should start at o6, but after the conversion, it starts at o5.
In this case, by adding preserve -n
o5cedf>c<gabo6
and the last note (=octave) will be preserved.
v, @, l, etc. can be specified in the same way.

The source of IRQ 0 is /IRQ from the YM2203 in the single processor L System games. Pin 25 (/IRQ) of the YM2203 is connected to pin 37 of the TC0090LVC. Pin 25 is pulled low when either timer-A or timer-B expires, and that triggers IRQ 0. I've looked through the code of all the single processor games and none of them actually start either of the timers (although all of them do actually initialise both timers). MAME currently fires IRQ 0 at scanline 120 for all L System games. I currently own Plotting, Puzznic (effectively the same base board as Plotting) and Play Girls single processor boards and have verified my findings on those boards. I'd imagine that all single processor boards have pin 25 of the YM2203 connected to pin 37 of the TC0090LVC.

Steps to reproduce this, on hardware, are detailed below.

I've looked at the dual and triple cpu games and found the following :-

Kuri Kinton - IRQ 0 routine is just ei/ret and is not enabled. The timers on the sound chip are NOT started by the audio program. I don't know what pin 37 of the TC0090LVC is connected to as I don't own a Kuri Kinton board

Evil Stone - not looked at the code for this game, nor do I own this board

Fighting Hawk - pin 37 of the TC0090LVC is connected to pin 62 of the TC0170ABT custom. There's very little documentation available for this custom and I've no idea what it does or what pin 62 is. The IRQ 0 routine in the main program is simply a ret statement and IRQ 0 is never enabled. Pin 16 (/INT) of the audio CPU is connected to pin 25 (/IRQ) of the YM2203. The audio program starts the timers and interrupts are generated on the audio CPU by the YM2203, as expected. I own a Fighting Hawk board.

Raimais - pin 37 of the TC0090LVC is connected to pin 4 (/INT L) of the MB8421 dual port ram. The slave CPU /NMI (pin 17) is connected to pin 48 (INT /R) of the dual port ram. The IRQ 0 routine in the main program is simply a ret statement and IRQ 0 is never enabled. Pin 16 of the audio CPU is connected to pin 56 (/IRQ) of the YM2610. The audio program starts the timers and interrupts are generated on the audio CPU by the YM2610, as expected. The slave and audio CPU's run at 8MHz (measured by me, on my own board, pics attached). The L System driver incorrectly has them at 4MHz (12000000/3) and states that these are "not verified". I've also verified the TC0090LVC runs at 6.66528 MHz on this board, from pin 5 of the 74F74 (which is connected to pin 122 of CPU). This is shown as "needs verification from pin 122" in the driver.

Champion Wrestler - I've not looked at the code for this game yet, although I do own a Champion Wrestler board and it's on my list of things to do next

Control register
---------------------
This is shown as "function unknown" for all the single processor games (with the exception of the American Horseshoes). The control register is used for coin counters & coin lockouts. I've studied the code for Plotting and Play Girls 2 and have verified my findings on those boards. The control register for Plotting is at $b800 and is comprised of :-

bit 0 - coin lockout #1
bit 1 - coin lockout #2
bit 2 - coin counter #1
bit 3 - coin counter #2

These values are clocked through a 74LS174 to a TD62064 and then out to the JAMMA edge connector.

Play Girls 2 follows a slightly different pattern and utilises 6 bits instead of 4 for the control register :-

bit 0 - coin counter #1 (this output does NOT go to the JAMMA edge connector, instead it goes to pin 3 of an unpopulated 4-pin area to the left of the 74LS174) (can be seen at http://blog.system11.org/wp-content/uploads/2013/09/1809_playgirls2_conv.jpg)
bit 1 - coin counter #2 (this output does NOT go to the JAMMA edge connector, instead it goes to pin 4 of an unpopulated 4-pin area to the left of the 74 LS174)
bit 2 - coin counter #1
bit 3 - coin counter #2
bit 4 - coin lockout #1
bit 5 - coin lockout #2

I haven't looked at the control register code of any of the other single processor games but I'd be surprised if it wasn't used for coin counters/lockouts on all of them.
Steps To Reproduce  The simplest way to demonstrate this functionality, on real hardware (using Plotting as my target board), is to change 4 bytes in the program :-

1) change the byte at $0036 to any non-zero value (this is a debug flag which, when non-zero, means the rom check is skipped)
2) change the word at $099c from 3b 00 to 8f 05 (this is the address IRQ0 will jump to when it fires, it's the start of the service menu code)
3) change the byte at $0bfe from 30 to 35 (this changes ld a,$30 to ld a,$35 and will start timer-A on the sound chip)

With these changes made the game will boot to service mode approx 1 frame after timer-A has been started (the period of timer-A is 16.39 milliseconds). This is because the timer expires, triggers IRQ0 and the code jumps to the new address. This simple demo can be seen in this video (you can just about see the service mode test grid appear when the logic probe goes low when timer-A expires) :-

Changing the byte at $0bfe back to 30 will allow the game to boot as normal (when running on hardware) as timer-A will not be started. When running on MAME however the code will still jump to the service mode as IRQ0 always fires at scanline 120.

A slightly more complex example involves resetting timer-B in the IRQ 0 routine, when it expires. This is done by making the following changes :-

1) change debug flag at $0036 to any non-zero value
2) change word at $099c from 3b 00 to 00 5d (new IRQ 0 routine address)
3) change byte at $0bf7 from d0 to 00 (this sets timer-B period to 88.49ms (approx 5.3 frames))
4) change byte at $0bfe from 30 to 2a (this loads/enables/starts timer-B)
5) insert new IRQ 0 routine at $5d00
f5 push af
c5 push bc
e5 push hl
21 00 a0 ld hl,$a000 ; point HL at the sound chip
06 27 ld b,$27 ; register $27
3e 2a ld a,$2a ; load/enable/start timer-B
cd b6 1a call $1ab6 ; send data to sound chip
e1 pop hl
c1 pop bc
f1 pop af
c3 3b 00 jp $003b ; jump to ei/reti

The results of the above code changes can be seen in this video. You can see pin 25 of the YM2203 (and hence pin 37 of the CPU) pulsing low when timer-B expires and is reset by the IRQ 0 routine.

Additional Information  I realise that adding the correct IRQ 0 trigger mechanism will have very little effect on the single processor games (the only difference being that they'll no longer call IRQ 0 at scanline 120 but that routine is merely an ei/reti combo in all the single processor games so the timing difference, per frame, will be 18 T-states plus the overhead of servicing the interrupt). I'd still very much like to see the correct behaviour emulated, if purely for personal reasons, as I'm planning on writing an audio engine to run on the Plotting board which requires the sound chip timers to generate an interrupt and it would be beneficial to be able to test the audio engine in MAME before deploying to hardware.

Thank you for all the hard work and dedication that the MAME dev team consistently put in to constantly improve MAME.
Github Commit
Flags   Verified with Original, Noted in Source, Verified with Code
Regression Version
Affected Sets / Systems plotting, puzznic, cachat, tubeit, palamed, plgirls, plgirls2
Attached Files
jpg file icon Raimais main CPU.jpg (2,843,079 bytes) May 23, 2018, 00:25 Uploaded by cmonkey
Raimais main CPU speed
jpg file icon Raimais slave CPU.jpg (2,513,770 bytes) May 23, 2018, 00:26 Uploaded by cmonkey
Raimais slave CPU speed
jpg file icon Raimais audio CPU.jpg (2,543,931 bytes) May 23, 2018, 00:27 Uploaded by cmonkey
Raimais audio CPU speed
jpg file icon Raimais pin 11 PAL.jpg (3,039,581 bytes) May 29, 2018, 00:11 Uploaded by cmonkey
pdf file icon LQV-8M00-012.pdf (752,276 bytes) May 29, 2018, 00:11 Uploaded by cmonkey
Changing the byte at $0bfe back to 30 will allow the game to boot as normal (when running on hardware) as timer-A will not be started. When running on MAME however the code will still jump to the service mode as IRQ0 always fires at scanline 120.

A slightly more complex example involves resetting timer-B in the IRQ 0 routine, when it expires. This is done by making the following changes :-

1) change debug flag at $0036 to any non-zero value
2) change word at $099c from 3b 00 to 00 5d (new IRQ 0 routine address)
3) change byte at $0bf7 from d0 to 00 (this sets timer-B period to 88.49ms (approx 5.3 frames))
4) change byte at $0bfe from 30 to 2a (this loads/enables/starts timer-B)
5) insert new IRQ 0 routine at $5d00
f5 push af
c5 push bc
e5 push hl
21 00 a0 ld hl,$a000 ; point HL at the sound chip
06 27 ld b,$27 ; register $27
3e 2a ld a,$2a ; load/enable/start timer-B
cd b6 1a call $1ab6 ; send data to sound chip
e1 pop hl
c1 pop bc
f1 pop af
c3 3b 00 jp $003b ; jump to ei/reti

The results of the above code changes can be seen in this video. You can see pin 25 of the YM2203 (and hence pin 37 of the CPU) pulsing low when timer-B expires and is reset by the IRQ 0 routine.

I realise that adding the correct IRQ 0 trigger mechanism will have very little effect on the single processor games (the only difference being that they'll no longer call IRQ 0 at scanline 120 but that routine is merely an ei/reti combo in all the single processor games so the timing difference, per frame, will be 18 T-states plus the overhead of servicing the interrupt). I'd still very much like to see the correct behaviour emulated, if purely for personal reasons, as I'm planning on writing an audio engine to run on the Plotting board which requires the sound chip timers to generate an interrupt and it would be beneficial to be able to test the audio engine in MAME before deploying to hardware.

Thank you for all the hard work and dedication that the MAME dev team consistently put in to constantly improve MAME.

YM2203 SSG-EG inaccuracy: Seems to be emulation of YM2203 feature 'SSG-EG' has inaccuracy in MAME. We (I as programmer and some other people as hardware developers) construct some sort of sound card which uses YM2203, and I wrote software for it. For testing purposes I use some of source code from MAME, related to YM2203 emulation (to make fast tests on PC, instead of real thing).
Now listen to two attached samples - which contains short part of music and then all possible SSG-ENV types in one channel. One of these samples recorded from real thing, YM2203 @3.5 MHz, and another rendered by YM2203 emulation code from MAME. Comments in fm.c code said:

The difference (when compared to normal Envelope Generator mode) is that the resolution in Decay and Sustain phases is 4 times lower;
this results in only 256 steps instead of normal 1024.

But seems to resolution in SSG-EG mode 8 times lower, not 4. I checked that by changing adding value from 4 to 8 in strings 1147 and 1170 of fm.c, and it sounds more like true. But there still some differences with envelope stages, by now I can't figure it clearly (you can see this in samples with any audio editor).I also can provide test register array (in simply format, .GYM-like), which was used to record these samples.

+#pragma once
+
+#ifndef __VGMWRITE_H__
+#define __VGMWRITE_H__
+
+void vgm_start(running_machine &machine);
+void vgm_stop(void);
+UINT16 vgm_open(UINT8 chip_type, int clock);
+void vgm_header_set(UINT16 chip_id, UINT8 attr, UINT32 data);
+void vgm_write(UINT16 chip_id, UINT8 port, UINT16 r, UINT8 v);
+void vgm_write_large_data(UINT16 chip_id, UINT8 type, UINT32 datasize, UINT32 value1, UINT32 value2, const void* data);
+
+// VGM Chip Constants
+// v1.00
+#define VGMC_SN76496   0x00
+#define VGMC_YM2413    0x01
+#define VGMC_YM2612    0x02
+#define VGMC_YM2151    0x03
+// v1.51
+#define VGMC_SEGAPCM   0x04
+#define VGMC_RF5C68    0x05
+#define VGMC_YM2203    0x06
+#define VGMC_YM2608    0x07
+#define VGMC_YM2610    0x08
+#define VGMC_YM3812    0x09
+#define VGMC_YM3526    0x0A
+#define VGMC_Y8950 0x0B
+#define VGMC_YMF262    0x0C
+#define VGMC_YMF278B   0x0D
+#define VGMC_YMF271    0x0E
+#define VGMC_YMZ280B   0x0F
+#define VGMC_T6W28 0x7F    // note: emulated via 2xSN76496
+#define VGMC_RF5C164   0x10
+#define VGMC_PWM   0x11
+#define VGMC_AY8910    0x12
+// v1.61
+#define VGMC_GBSOUND   0x13
+#define VGMC_NESAPU    0x14
+#define VGMC_MULTIPCM  0x15
+#define VGMC_UPD7759   0x16
+#define VGMC_OKIM6258  0x17
+#define VGMC_OKIM6295  0x18
+#define VGMC_K051649   0x19
+#define VGMC_OKIM6376  0xFF
+
+#endif /* __VGMWRITE_H__ */

+/*
+    vgmwrite.c
+
+    VGM output module
+
+    Written by Valley Bell
+
+*/
+
+#include "emu.h"
+#include "emuopts.h"
+#include "vgmwrite.h"
+
+#define DYNAMIC_HEADER_SIZE
+
+static char LOG_VGM_FILE = 0x00;
+
+typedef struct _vgm_file_header VGM_HEADER;
+struct _vgm_file_header
+{
+   UINT32 fccVGM;
+   UINT32 lngEOFOffset;
+   UINT32 lngVersion;
+   UINT32 lngHzPSG;
+   UINT32 lngHz2413;
+   UINT32 lngGD3Offset;
+   UINT32 lngTotalSamples;
+   UINT32 lngLoopOffset;
+   UINT32 lngLoopSamples;
+   UINT32 lngRate;
+   UINT16 shtPSG_Feedback;
+   UINT8 bytPSG_STWidth;
+   UINT8 bytPSG_Flags;
+   UINT32 lngHz2612;
+   UINT32 lngHz2151;
+   UINT32 lngDataOffset;
+   UINT32 lngHzSPCM;
+   UINT32 lngSPCMIntf;
+   UINT32 lngHzRF5C68;
+   UINT32 lngHz2203;
+   UINT32 lngHz2608;
+   UINT32 lngHz2610;
+   UINT32 lngHz3812;
+   UINT32 lngHz3526;
+   UINT32 lngHz8950;
+   UINT32 lngHz262;
+   UINT32 lngHz278B;
+   UINT32 lngHz271;
+   UINT32 lngHz280B;
+   UINT32 lngHzRF5C164;
+   UINT32 lngHzPWM;
+   UINT32 lngHzAY8910;
+   UINT8 lngAYType;
+   UINT8 lngAYFlags;
+   UINT8 lngAYFlagsYM2203;
+   UINT8 lngAYFlagsYM2608;
+   UINT8 bytModifiers[0x04];
+   UINT32 lngHzGBDMG;  // part of the LR35902 (GB Main CPU)
+   UINT32 lngHzNESAPU; // part of the N2A03 (NES Main CPU)
+   UINT32 lngHzMultiPCM;
+   UINT32 lngHzUPD7759;
+   UINT32 lngHzOKIM6258;
+   UINT8 bytOKI6258Flags;
+   UINT8 bytReservedFlags[0x03];
+   UINT32 lngHzOKIM6295;
+   UINT32 lngHzK051649;
+   //UINT32 lngHzOKIM6376;
+   UINT8 bytReserved[0x30];
+}; // -> 0xC0 Bytes
+typedef struct _vgm_gd3_tag GD3_TAG;
+struct _vgm_gd3_tag
+{
+   UINT32 fccGD3;
+   UINT32 lngVersion;
+   UINT32 lngTagLength;
+   wchar_t strTrackNameE[0x70];
+   wchar_t strTrackNameJ[0x10];    // Japanese Names are not used
+   wchar_t strGameNameE[0x70];
+   wchar_t strGameNameJ[0x10];
+   wchar_t strSystemNameE[0x30];
+   wchar_t strSystemNameJ[0x10];
+   wchar_t strAuthorNameE[0x30];
+   wchar_t strAuthorNameJ[0x10];
+   wchar_t strReleaseDate[0x10];
+   wchar_t strCreator[0x20];
+   wchar_t strNotes[0x50];
+}; // -> 0x200 Bytes
+
+typedef struct _vgm_rom_data_block VGM_ROM_DATA;
+struct _vgm_rom_data_block
+{
+   UINT8 Type;
+   UINT32 DataSize;
+   const void* Data;
+};
+typedef struct _vgm_rom_init_command VGM_INIT_CMD;
+struct _vgm_rom_init_command
+{
+   UINT8 CmdLen;
+   UINT8 Data[0x04];
+};
+typedef struct _vgm_file_inf VGM_INF;
+struct _vgm_file_inf
+{
+   FILE* hFile;
+   VGM_HEADER Header;
+   UINT8 WroteHeader;
+   UINT32 HeaderBytes;
+   UINT32 BytesWrt;
+   UINT32 SmplsWrt;
+   UINT32 EvtDelay;
+
+   UINT32 DataCount;
+   VGM_ROM_DATA DataBlk[0x20];
+   //UINT32 CmdAlloc;
+   UINT32 CmdCount;
+   VGM_INIT_CMD Commands[0x100];
+
+   UINT8 NesMemEmpty;
+   UINT8 NesMem[0x4000];
+};
+typedef struct _vgm_chip VGM_CHIP;
+struct _vgm_chip
+{
+   UINT8 ChipType;
+   UINT16 VgmID;
+   UINT8 HadWrite;
+};
+
+#define MAX_VGM_FILES  0x10
+#define MAX_VGM_CHIPS  0x80
+static char vgm_namebase[0x80];
+static VGM_INF VgmFile[MAX_VGM_FILES];
+static VGM_CHIP VgmChip[MAX_VGM_CHIPS];
+static GD3_TAG VgmTag;
+
+// Function Prototypes
+INLINE int atwcpy(wchar_t* dststr, const char* srcstr);
+static TIMER_CALLBACK(vgmfile_callback);
+static void vgm_header_postwrite(UINT16 vgm_id);
+static void vgm_header_sizecheck(UINT16 vgm_id, UINT32 MinVer, UINT32 MinSize);
+static void vgm_header_clear(UINT16 vgm_id);
+void vgm_close(UINT16 vgm_id);
+static void vgm_write_delay(UINT16 vgm_id);
+static UINT8 vgm_nes_ram_check(VGM_INF* VI, UINT32 datasize, UINT32* value1, UINT32* value2, const UINT8* data);
+
+// ASCII to Wide-Char String Copy
+INLINE int atwcpy(wchar_t* dststr, const char* srcstr)
+{
+   return mbstowcs(dststr, srcstr, strlen(srcstr) + 0x01);
+}
+
+void vgm_start(running_machine &machine)
+{
+   UINT16 curvgm;
+   const game_driver* gamedrv;
+   // Sorry, but the image is loaded after vgm_start is called
+/*#ifdef MESS
+   device_image_interface* devimg;
+#endif*/
+
+   LOG_VGM_FILE = (UINT8)machine.options().vgm_write();
+#if defined(MESS) && defined(WINUI)
+   logerror("VGM Logging Mode: %u\n", LOG_VGM_FILE);
+   LOG_VGM_FILE = 1;
+#endif
+
+   // Reset all files
+   for (curvgm = 0x00; curvgm < MAX_VGM_FILES; curvgm ++)
+   {
+       VgmFile[curvgm].hFile = NULL;
+       VgmFile[curvgm].DataCount = 0x00;
+       VgmFile[curvgm].CmdCount = 0x00;
+       VgmFile[curvgm].NesMemEmpty = 0x01;
+   }
+   for (curvgm = 0x00; curvgm < MAX_VGM_CHIPS; curvgm ++)
+   {
+       VgmChip[curvgm].ChipType = 0xFF;
+   }
+
+   // start the timer
+   // (done here because it makes save states with vgmwrite off compatible with
+   //  saves that have it on)
+   machine.scheduler().timer_pulse(attotime::from_hz(44100), FUNC(vgmfile_callback));
+           //44.1 KHz VGM pulse timer
+
+   if (! LOG_VGM_FILE)
+       return;
+
+   // Get the Game Information and write the GD3 Tag
+   gamedrv = &machine.system();
+/*#ifdef MESS
+   devimg = NULL;
+   machine.m_devicelist.first(devimg);
+#endif*/
+
+   if (gamedrv)
+       strcpy(vgm_namebase, gamedrv->name);
+   else
+       strcpy(vgm_namebase, "vgmlog");
+   strcat(vgm_namebase, "_");
+
+   VgmTag.fccGD3 = 0x20336447; // 'Gd3 '
+   VgmTag.lngVersion = 0x00000100;
+   wcscpy(VgmTag.strTrackNameE, L"");
+   wcscpy(VgmTag.strTrackNameJ, L"");
+#ifndef MESS
+   if (gamedrv)
+       atwcpy(VgmTag.strGameNameE, gamedrv->description);
+   else
+       wcscpy(VgmTag.strGameNameE, L"");
+#else
+   /*if (devimg)
+       atwcpy(VgmTag.strGameNameE, devimg->longname());
+   else*/
+       wcscpy(VgmTag.strGameNameE, L"");
+#endif
+   wcscpy(VgmTag.strGameNameJ, L"");
+#ifndef MESS
+   wcscpy(VgmTag.strSystemNameE, L"Arcade Machine");
+#else
+   if (gamedrv)
+       atwcpy(VgmTag.strSystemNameE, gamedrv->description);
+   else
+       wcscpy(VgmTag.strSystemNameE, L"");
+#endif
+   wcscpy(VgmTag.strSystemNameJ, L"");
+   if (gamedrv)
+       atwcpy(VgmTag.strAuthorNameE, gamedrv->manufacturer);
+   else
+       wcscpy(VgmTag.strAuthorNameE, L"");
+   wcscpy(VgmTag.strAuthorNameJ, L"");
+//#ifndef MESS
+   if (gamedrv)
+       atwcpy(VgmTag.strReleaseDate, gamedrv->year);
+/*#else
+   if (devimg)
+       atwcpy(VgmTag.strReleaseDate, devimg->year());
+#endif*/
+   else
+       wcscpy(VgmTag.strReleaseDate, L"");
+   wcscpy(VgmTag.strCreator, L"");
+
+   swprintf(VgmTag.strNotes, L"Generated by %hs %hs\n", APPNAME, build_version);
+   VgmTag.lngTagLength = wcslen(VgmTag.strTrackNameE) + 0x01 +
+               wcslen(VgmTag.strTrackNameJ) + 0x01 +
+               wcslen(VgmTag.strGameNameE) + 0x01 +
+               wcslen(VgmTag.strGameNameJ) + 0x01 +
+               wcslen(VgmTag.strSystemNameE) + 0x01 +
+               wcslen(VgmTag.strSystemNameJ) + 0x01 +
+               wcslen(VgmTag.strAuthorNameE) + 0x01 +
+               wcslen(VgmTag.strAuthorNameJ) + 0x01 +
+               wcslen(VgmTag.strReleaseDate) + 0x01 +
+               wcslen(VgmTag.strCreator) + 0x01 +
+               wcslen(VgmTag.strNotes) + 0x01;
+   VgmTag.lngTagLength *= sizeof(wchar_t); // String Length -> Byte Length
+
+   logerror("VGM logging started ...\n");
+
+   return;
+}
+
+void vgm_stop(void)
+{
+   UINT16 curchip;
+   UINT16 chip_unused;
+   UINT16 curvgm;
+   UINT32 clock_mask;
+   VGM_HEADER* VH;
+
+   if (! LOG_VGM_FILE)
+       return;
+
+   chip_unused = 0x00;
+   for (curchip = 0x00; curchip < MAX_VGM_FILES; curchip ++)
+   {
+       if (VgmChip[curchip].ChipType == 0xFF)
+           break;
+
+       if (! VgmChip[curchip].HadWrite)
+       {
+           chip_unused ++;
+           curvgm = VgmChip[curchip].VgmID;
+           VH = &VgmFile[curvgm].Header;
+           // clock_mask - remove either the dual-chip bit or the entire clock
+           clock_mask = (VgmChip[curchip].ChipType & 0x80) ? ~0x40000000 : 0x00000000;
+
+           switch(VgmChip[curchip].ChipType & 0x7F)
+           {
+           case VGMC_SN76496:
+               VH->lngHzPSG &= clock_mask;
+               if (! clock_mask)
+               {
+                   VH->shtPSG_Feedback = 0x0000;
+                   VH->bytPSG_STWidth = 0x00;
+                   VH->bytPSG_Flags = 0x00;
+               }
+               break;
+           case VGMC_YM2413:
+               VH->lngHz2413 &= clock_mask;
+               break;
+           case VGMC_YM2612:
+               VH->lngHz2612 &= clock_mask;
+               break;
+           case VGMC_YM2151:
+               VH->lngHz2151 &= clock_mask;
+               break;
+           case VGMC_SEGAPCM:
+               VH->lngHzSPCM &= clock_mask;
+               break;
+           case VGMC_RF5C68:
+               VH->lngHzRF5C68 &= clock_mask;
+               break;
+           case VGMC_YM2203:
+               VH->lngHz2203 &= clock_mask;
+               if (! clock_mask)
+                   VH->lngAYFlagsYM2203 = 0x00;
+               break;
+           case VGMC_YM2608:
+               VH->lngHz2608 &= clock_mask;
+               if (! clock_mask)
+                   VH->lngAYFlagsYM2608 = 0x00;
+               break;
+           case VGMC_YM2610:
+               VH->lngHz2610 &= clock_mask;
+               break;
+           case VGMC_YM3812:
+               VH->lngHz3812 &= clock_mask;
+               break;
+           case VGMC_YM3526:
+               VH->lngHz3526 &= clock_mask;
+               break;
+           case VGMC_Y8950:
+               VH->lngHz8950 &= clock_mask;
+               break;
+           case VGMC_YMF262:
+               VH->lngHz262 &= clock_mask;
+               break;
+           case VGMC_YMF278B:
+               VH->lngHz278B &= clock_mask;
+               break;
+           case VGMC_YMF271:
+               VH->lngHz271 &= clock_mask;
+               break;
+           case VGMC_YMZ280B:
+               VH->lngHz280B &= clock_mask;
+               break;
+           case VGMC_T6W28:
+               clock_mask = 0x00000000;
+               VH->lngHzPSG &= clock_mask;
+               if (! clock_mask)
+               {
+                   VH->shtPSG_Feedback = 0x0000;
+                   VH->bytPSG_STWidth = 0x00;
+                   VH->bytPSG_Flags = 0x00;
+               }
+               break;
+           case VGMC_RF5C164:
+               VH->lngHzRF5C164 &= clock_mask;
+               break;
+           case VGMC_PWM:
+               VH->lngHzPWM &= clock_mask;
+               break;
+           case VGMC_AY8910:
+               VH->lngHzAY8910 &= clock_mask;
+               if (! clock_mask)
+               {
+                   VH->lngAYFlags = 0x00;
+                   VH->lngAYType = 0x00;
+               }
+               break;
+           case VGMC_GBSOUND:
+               VH->lngHzGBDMG &= clock_mask;
+               break;
+           case VGMC_NESAPU:
+               VH->lngHzNESAPU &= clock_mask;
+               break;
+           case VGMC_MULTIPCM:
+               VH->lngHzMultiPCM &= clock_mask;
+               break;
+           case VGMC_UPD7759:
+               VH->lngHzUPD7759 &= clock_mask;
+               break;
+           case VGMC_OKIM6258:
+               VH->lngHzOKIM6258 &= clock_mask;
+               if (! clock_mask)
+                   VH->bytOKI6258Flags = 0x00;
+               break;
+           case VGMC_OKIM6295:
+               VH->lngHzOKIM6295 &= clock_mask;
+               break;
+           case VGMC_K051649:
+               VH->lngHzK051649 &= clock_mask;
+               break;
+       //  case VGMC_OKIM6376:
+       //      VH->lngHzOKIM6376 &= clock_mask;
+       //      break;
+           }
+       }
+   }
+   if (chip_unused)
+       printf("Header Data of %hu unused Chips removed.\n", chip_unused);
+
+   for (curvgm = 0x00; curvgm < MAX_VGM_FILES; curvgm ++)
+   {
+       if (VgmFile[curvgm].hFile)
+           vgm_close(curvgm);
+   }
+   logerror("VGM stopped.\n");
+
+   return;
+}
+
+static TIMER_CALLBACK(vgmfile_callback)
+{
+   UINT16 curvgm;
+
+   if (! LOG_VGM_FILE)
+       return;
+
+   for (curvgm = 0x00; curvgm < MAX_VGM_FILES; curvgm ++)
+   {
+       if (VgmFile[curvgm].hFile)
+           VgmFile[curvgm].EvtDelay ++;
+   }
+
+   return;
+}
+
+static void vgm_header_postwrite(UINT16 vgm_id)
+{
+   VGM_INF* VI;
+   VGM_HEADER* Header;
+   VGM_ROM_DATA* VR;
+   VGM_INIT_CMD* VC;
+   UINT32 curcmd;
+   UINT32 blocksize;
+   UINT32 templng;
+
+   if (VgmFile[vgm_id].WroteHeader)
+       return;
+
+   VI = &VgmFile[vgm_id];
+   Header = &VI->Header;
+
+   fseek(VI->hFile, 0x00, SEEK_SET);
+   VI->BytesWrt = 0x00;
+
+   fwrite(Header, 0x01, VI->HeaderBytes, VI->hFile);
+   VI->BytesWrt += VI->HeaderBytes;
+
+   for (curcmd = 0x00; curcmd < VI->DataCount; curcmd ++)
+   {
+       VR = &VI->DataBlk[curcmd];
+       blocksize = 0x08;
+       if (VR->Data != NULL)
+           blocksize += VR->DataSize;
+       VR->DataSize &= 0x7FFFFFFF;
+
+       fputc(0x67, VI->hFile);
+       fputc(0x66, VI->hFile);
+       fputc(VR->Type, VI->hFile);
+       fwrite(&blocksize, 0x04, 0x01, VI->hFile);  // Data Block Size
+       fwrite(&VR->DataSize, 0x04, 0x01, VI->hFile);   // ROM Size
+       templng = 0x00;
+       fwrite(&templng, 0x04, 0x01, VI->hFile);    // Data Base Address
+       if (VR->Data != NULL)
+           fwrite(VR->Data, 0x01, VR->DataSize, VI->hFile);
+       VI->BytesWrt += 0x07 + (blocksize & 0x7FFFFFFF);
+   }
+   for (curcmd = 0x00; curcmd < VI->CmdCount; curcmd ++)
+   {
+       VC = &VI->Commands[curcmd];
+       fwrite(VC->Data, 0x01, VC->CmdLen, VI->hFile);
+       VI->BytesWrt += VC->CmdLen;
+   }
+   VI->WroteHeader = 0x01;
+
+   return;
+}
+
+static void vgm_header_sizecheck(UINT16 vgm_id, UINT32 MinVer, UINT32 MinSize)
+{
+   VGM_INF* VI;
+   VGM_HEADER* Header;
+
+   if (! VgmFile[vgm_id].hFile)
+       return;
+
+   VI = &VgmFile[vgm_id];
+   Header = &VI->Header;
+
+   if (Header->lngVersion < MinVer)
+       Header->lngVersion = MinVer;
+   if (VI->HeaderBytes < MinSize)
+       VI->HeaderBytes = MinSize;
+
+   return;
+}
+
+static void vgm_header_clear(UINT16 vgm_id)
+{
+   VGM_INF* VI;
+   VGM_HEADER* Header;
+
+   if (! VgmFile[vgm_id].hFile)
+       return;
+
+   VI = &VgmFile[vgm_id];
+   Header = &VI->Header;
+   memset(Header, 0x00, sizeof(VGM_HEADER));
+   Header->fccVGM = 0x206D6756;    // 'Vgm '
+   Header->lngEOFOffset = 0x00000000;
+   Header->lngVersion = 0x00000151;
+   //Header->lngGD3Offset = 0x00000000;
+   //Header->lngTotalSamples = 0;
+   //Header->lngLoopOffset = 0x00000000;
+   //Header->lngLoopSamples = 0;
+#ifdef DYNAMIC_HEADER_SIZE
+   VI->HeaderBytes = 0x38;
+   VI->WroteHeader = 0x00;
+#else
+   VI->HeaderBytes = sizeof(VGM_HEADER);
+   VI->WroteHeader = 0x01;
+#endif
+   Header->lngDataOffset = VI->HeaderBytes - 0x34;
+
+   //fseek(VI->hFile, 0x00, SEEK_SET);
+   //fwrite(Header, 0x01, sizeof(VGM_HEADER), VI->hFile);
+   //VI->BytesWrt += sizeof(VGM_HEADER);
+   VI->BytesWrt = 0x00;
+
+   return;
+}
+
+UINT16 vgm_open(UINT8 chip_type, int clock)
+{
+   UINT16 chip_id;
+   UINT16 chip_file;
+   UINT16 curvgm;
+   UINT32 chip_val;
+   char vgm_name[0x20];
+   UINT8 use_two;
+
+   if (! LOG_VGM_FILE || chip_type == 0xFF)
+       return 0xFFFF;
+
+   chip_id = 0xFFFF;
+   for (curvgm = 0x00; curvgm < MAX_VGM_CHIPS; curvgm ++)
+   {
+       if (VgmChip[curvgm].ChipType == 0xFF)
+       {
+           chip_id = curvgm;
+           break;
+       }
+   }
+   if (chip_id == 0xFFFF)
+       return 0xFFFF;
+
+   chip_file = 0xFFFF;
+   use_two = 0x00;
+   for (curvgm = 0x00; curvgm < MAX_VGM_FILES; curvgm ++)
+   {
+       if (VgmFile[curvgm].hFile)
+       {
+           use_two = 0x01;
+           switch(chip_type)
+           {
+           case VGMC_SN76496:
+               chip_val = VgmFile[curvgm].Header.lngHzPSG;
+               break;
+           case VGMC_YM2413:
+               chip_val = VgmFile[curvgm].Header.lngHz2413;
+               break;
+           case VGMC_YM2612:
+               chip_val = VgmFile[curvgm].Header.lngHz2612;
+               break;
+           case VGMC_YM2151:
+               chip_val = VgmFile[curvgm].Header.lngHz2151;
+               break;
+           case VGMC_SEGAPCM:
+               chip_val = VgmFile[curvgm].Header.lngHzSPCM;
+               use_two = 0x00;
+               break;
+           case VGMC_RF5C68:
+               chip_val = VgmFile[curvgm].Header.lngHzRF5C68;
+               use_two = 0x00;
+               break;
+           case VGMC_YM2203:
+               chip_val = VgmFile[curvgm].Header.lngHz2203;
+               break;
+           case VGMC_YM2608:
+               chip_val = VgmFile[curvgm].Header.lngHz2608;
+               break;
+           case VGMC_YM2610:
+               chip_val = VgmFile[curvgm].Header.lngHz2610;
+               break;
+           case VGMC_YM3812:
+               chip_val = VgmFile[curvgm].Header.lngHz3812;
+               break;
+           case VGMC_YM3526:
+               chip_val = VgmFile[curvgm].Header.lngHz3526;
+               break;
+           case VGMC_Y8950:
+               chip_val = VgmFile[curvgm].Header.lngHz8950;
+               break;
+           case VGMC_YMF262:
+               chip_val = VgmFile[curvgm].Header.lngHz262;
+               break;
+           case VGMC_YMF278B:
+               chip_val = VgmFile[curvgm].Header.lngHz278B;
+               break;
+           case VGMC_YMF271:
+               chip_val = VgmFile[curvgm].Header.lngHz271;
+               break;
+           case VGMC_YMZ280B:
+               chip_val = VgmFile[curvgm].Header.lngHz280B;
+               break;
+           case VGMC_T6W28:
+               chip_val = VgmFile[curvgm].Header.lngHzPSG;
+               use_two = 0x00;
+               break;
+           case VGMC_RF5C164:
+               chip_val = VgmFile[curvgm].Header.lngHzRF5C164;
+               use_two = 0x00;
+               break;
+           case VGMC_PWM:
+               chip_val = VgmFile[curvgm].Header.lngHzPWM;
+               use_two = 0x00;
+               break;
+           case VGMC_AY8910:
+               chip_val = VgmFile[curvgm].Header.lngHzAY8910;
+               break;
+           case VGMC_GBSOUND:
+               chip_val = VgmFile[curvgm].Header.lngHzGBDMG;
+               break;
+           case VGMC_NESAPU:
+               chip_val = VgmFile[curvgm].Header.lngHzNESAPU;
+               break;
+           case VGMC_MULTIPCM:
+               chip_val = VgmFile[curvgm].Header.lngHzMultiPCM;
+               use_two = 0x00;
+               break;
+           case VGMC_UPD7759:
+               chip_val = VgmFile[curvgm].Header.lngHzUPD7759;
+               break;
+           case VGMC_OKIM6258:
+               chip_val = VgmFile[curvgm].Header.lngHzOKIM6258;
+               break;
+           case VGMC_OKIM6295:
+               chip_val = VgmFile[curvgm].Header.lngHzOKIM6295;
+               break;
+           case VGMC_K051649:
+               chip_val = VgmFile[curvgm].Header.lngHzK051649;
+               break;
+       //  case VGMC_OKIM6376:
+       //      chip_val = VgmFile[curvgm].Header.lngHzOKIM6376;
+       //      use_two = 0x00;
+       //      break;
+           default:
+               chip_val = 0x00000001;
+               use_two = 0x00;
+               break;
+           }
+           if (! chip_val)
+           {
+               chip_file = curvgm;
+               break;
+           }
+           else if (use_two)
+           {
+               use_two = ! (chip_val & 0x40000000);
+               if (use_two && LOG_VGM_FILE == 0x01)
+               {
+                   if (clock != chip_val)
+                       logerror("VGM Log: Warning - 2-chip mode, but chip clocks different!\n");
+                   chip_file = curvgm;
+                   clock = 0x40000000 | chip_val;
+                   chip_type |= 0x80;
+                   break;
+               }
+           }
+       }
+   }
+   if (chip_file == 0xFFFF)
+   {
+       for (curvgm = 0x00; curvgm < MAX_VGM_FILES; curvgm ++)
+       {
+           if (! VgmFile[curvgm].hFile)
+           {
+               sprintf(vgm_name, "%s%hX.vgm", vgm_namebase, curvgm);
+               logerror("Opening %s ...\t", vgm_name);
+               VgmFile[curvgm].hFile = fopen(vgm_name, "wb");
+               if (VgmFile[curvgm].hFile)
+               {
+                   logerror("OK\n");
+                   chip_file = curvgm;
+                   VgmFile[curvgm].BytesWrt = 0;
+                   VgmFile[curvgm].SmplsWrt = 0;
+                   VgmFile[curvgm].EvtDelay = 0;
+                   vgm_header_clear(curvgm);
+               }
+               else
+               {
+                   logerror("Failed to create the file!\n");
+               }
+               break;
+           }
+       }
+   }
+   if (chip_file == 0xFFFF)
+       return 0xFFFF;
+
+   VgmChip[chip_id].VgmID = chip_file;
+   VgmChip[chip_id].ChipType = chip_type;
+   VgmChip[chip_id].HadWrite = 0x00;
+
+   switch(chip_type & 0x7F)
+   {
+   case VGMC_SN76496:
+       VgmFile[chip_file].Header.lngHzPSG = clock;
+       break;
+   case VGMC_YM2413:
+       VgmFile[chip_file].Header.lngHz2413 = clock;
+       break;
+   case VGMC_YM2612:
+       VgmFile[chip_file].Header.lngHz2612 = clock;
+       break;
+   case VGMC_YM2151:
+       VgmFile[chip_file].Header.lngHz2151 = clock;
+       break;
+   case VGMC_SEGAPCM:
+       VgmFile[chip_file].Header.lngHzSPCM = clock;
+       break;
+   case VGMC_RF5C68:
+       VgmFile[chip_file].Header.lngHzRF5C68 = clock;
+       break;
+   case VGMC_YM2203:
+       VgmFile[chip_file].Header.lngHz2203 = clock;
+       break;
+   case VGMC_YM2608:
+       VgmFile[chip_file].Header.lngHz2608 = clock;
+       break;
+   case VGMC_YM2610:
+       VgmFile[chip_file].Header.lngHz2610 = clock;
+       break;
+   case VGMC_YM3812:
+       VgmFile[chip_file].Header.lngHz3812 = clock;
+       break;
+   case VGMC_YM3526:
+       VgmFile[chip_file].Header.lngHz3526 = clock;
+       break;
+   case VGMC_Y8950:
+       VgmFile[chip_file].Header.lngHz8950 = clock;
+       break;
+   case VGMC_YMF262:
+       VgmFile[chip_file].Header.lngHz262 = clock;
+       break;
+   case VGMC_YMF278B:
+       VgmFile[chip_file].Header.lngHz278B = clock;
+       break;
+   case VGMC_YMF271:
+       VgmFile[chip_file].Header.lngHz271 = clock;
+       break;
+   case VGMC_YMZ280B:
+       VgmFile[chip_file].Header.lngHz280B = clock;
+       break;
+   case VGMC_T6W28:
+       VgmFile[chip_file].Header.lngHzPSG = clock | 0xC0000000;    // Cheat to use 2 SN76489 chips
+       break;
+   case VGMC_RF5C164:
+       VgmFile[chip_file].Header.lngHzRF5C164 = clock;
+       break;
+   case VGMC_PWM:
+       VgmFile[chip_file].Header.lngHzPWM = clock;
+       break;
+   case VGMC_AY8910:
+       VgmFile[chip_file].Header.lngHzAY8910 = clock;
+       break;
+   case VGMC_GBSOUND:
+       VgmFile[chip_file].Header.lngHzGBDMG = clock;
+       break;
+   case VGMC_NESAPU:
+       VgmFile[chip_file].Header.lngHzNESAPU = clock;
+       break;
+   case VGMC_MULTIPCM:
+       VgmFile[chip_file].Header.lngHzMultiPCM = clock;
+       break;
+   case VGMC_UPD7759:
+       VgmFile[chip_file].Header.lngHzUPD7759 = clock;
+       break;
+   case VGMC_OKIM6258:
+       VgmFile[chip_file].Header.lngHzOKIM6258 = clock;
+       break;
+   case VGMC_OKIM6295:
+       VgmFile[chip_file].Header.lngHzOKIM6295 = clock;
+       break;
+   case VGMC_K051649:
+       VgmFile[chip_file].Header.lngHzK051649 = clock;
+       break;
+// case VGMC_OKIM6376:
+//     VgmFile[chip_file].Header.lngHzOKIM6376 = clock;
+//     break;
+   }
+
+   switch(chip_type & 0x7F)
+   {
+   case VGMC_SN76496:
+   case VGMC_YM2413:
+   case VGMC_YM2612:
+   case VGMC_YM2151:
+   case VGMC_SEGAPCM:
+   case VGMC_T6W28:
+       vgm_header_sizecheck(chip_file, 0x00000151, 0x40);
+       break;
+   case VGMC_RF5C68:
+   case VGMC_YM2203:
+   case VGMC_YM2608:
+   case VGMC_YM2610:
+   case VGMC_YM3812:
+   case VGMC_YM3526:
+   case VGMC_Y8950:
+   case VGMC_YMF262:
+   case VGMC_YMF278B:
+   case VGMC_YMF271:
+   case VGMC_YMZ280B:
+   case VGMC_RF5C164:
+   case VGMC_PWM:
+   case VGMC_AY8910:
+       vgm_header_sizecheck(chip_file, 0x00000151, 0x80);
+       break;
+   case VGMC_GBSOUND:
+   case VGMC_NESAPU:
+   case VGMC_MULTIPCM:
+   case VGMC_UPD7759:
+   case VGMC_OKIM6258:
+   case VGMC_OKIM6295:
+   case VGMC_K051649:
+// case VGMC_OKIM6376:
+       vgm_header_sizecheck(chip_file, 0x00000161, 0xC0);
+       break;
+   }
+
+   return chip_id;
+}
+
+void vgm_header_set(UINT16 chip_id, UINT8 attr, UINT32 data)
+{
+   VGM_HEADER* VH;
+   UINT8 bitcnt;
+
+   if (! LOG_VGM_FILE || chip_id == 0xFFFF)
+       return;
+   if (VgmChip[chip_id].ChipType == 0xFF)
+       return;
+
+   VH = &VgmFile[VgmChip[chip_id].VgmID].Header;
+   switch(VgmChip[chip_id].ChipType & 0x7F)    // Write the Header data
+   {
+   case VGMC_SN76496:
+   case VGMC_T6W28:
+       switch(attr)
+       {
+       case 0x00:  // Reserved
+           break;
+       case 0x01:  // Shift Register Width (Feedback Mask)
+           bitcnt = 0x00;  // Convert the BitMask to BitCount
+           while(data)
+           {
+               data >>= 1;
+               bitcnt ++;
+           }
+           VH->bytPSG_STWidth = bitcnt;
+           break;
+       case 0x02:  // Feedback Pattern (White Noise Tap #1)
+           VH->shtPSG_Feedback = (UINT16)data;
+           break;
+       case 0x03:  // Feedback Pattern (White Noise Tap #2)
+           // must be called after #1
+           VH->shtPSG_Feedback |= (UINT16)data;
+           break;
+       case 0x04:  // Negate Channels Flag
+           VH->bytPSG_Flags &= ~(0x01 << 1);
+           VH->bytPSG_Flags |= (data & 0x01) << 1;
+           break;
+       case 0x05:  // Stereo Flag (On/Off)
+           VH->bytPSG_Flags &= ~(0x01 << 2);
+           VH->bytPSG_Flags |= (data & 0x01) << 2;
+           break;
+       case 0x06:  // Clock Divider (On/Off)
+           VH->bytPSG_Flags &= ~(0x01 << 3);
+           bitcnt = (data == 1) ? 0x01 : 0x00;
+           VH->bytPSG_Flags |= (bitcnt & 0x01) << 3;
+           break;
+       case 0x07:  // Freq 0 is Max
+           VH->bytPSG_Flags &= ~(0x01 << 0);
+           VH->bytPSG_Flags |= (data & 0x01) << 0;
+           break;
+       }
+       break;
+   case VGMC_YM2413:
+       break;
+   case VGMC_YM2612:
+       break;
+   case VGMC_YM2151:
+       break;
+   case VGMC_SEGAPCM:
+       switch(attr)
+       {
+       case 0x00:  // Reserved
+           break;
+       case 0x01:  // Sega PCM Interface
+           VH->lngSPCMIntf = data;
+           break;
+       }
+       break;
+   case VGMC_RF5C68:
+       break;
+   case VGMC_YM2203:
+       switch(attr)
+       {
+       case 0x00:  // Reserved
+           break;
+       case 0x01:  // Flags
+           VH->lngAYFlagsYM2203 = data & 0xFF;
+           break;
+       }
+       break;
+   case VGMC_YM2608:
+       switch(attr)
+       {
+       case 0x00:  // Reserved
+           break;
+       case 0x01:  // Flags
+           VH->lngAYFlagsYM2608 = data & 0xFF;
+           break;
+       }
+       break;
+   case VGMC_YM2610:
+       switch(attr)
+       {
+       case 0x00:  // Chip Type (set YM2610B mode)
+           VH->lngHz2610 = (VH->lngHz2610 & 0x7FFFFFFF) | (data << 31);
+           break;
+       }
+       break;
+   case VGMC_YM3812:
+       break;
+   case VGMC_YM3526:
+       break;
+   case VGMC_Y8950:
+       break;
+   case VGMC_YMF262:
+       switch(attr)
+       {
+       case 0x00:  // is Part of OPL4
+           if (data)
+           {
+               VgmChip[chip_id].ChipType = VGMC_YMF278B;
+               VH->lngHz262 = 0x00;
+           }
+           break;
+       }
+       break;
+   case VGMC_YMF278B:
+       break;
+   case VGMC_YMF271:
+       break;
+   case VGMC_YMZ280B:
+       break;
+   case VGMC_RF5C164:
+       break;
+   case VGMC_PWM:
+       break;
+   case VGMC_AY8910:
+       switch(attr)
+       {
+       case 0x00:  // Device Type
+           VH->lngAYType = data & 0xFF;
+           break;
+       case 0x01:  // Flags
+           VH->lngAYFlags = data & 0xFF;
+           break;
+       case 0x10:  // Resistor Loads
+       case 0x11:
+       case 0x12:
+           logerror("AY8910: Resistor Load %hu = %u\n", attr & 0x0F, data);
+           break;
+       }
+       break;
+   case VGMC_GBSOUND:
+       break;
+   case VGMC_NESAPU:
+       break;
+   case VGMC_MULTIPCM:
+       break;
+   case VGMC_UPD7759:
+       switch(attr)
+       {
+       case 0x00:  // Chip Type (set master/slave mode)
+           VH->lngHzUPD7759 = (VH->lngHzUPD7759 & 0x7FFFFFFF) | (data << 31);
+           break;
+       }
+       break;
+   case VGMC_OKIM6258:
+       switch(attr)
+       {
+       case 0x00:  // Reserved
+           break;
+       case 0x01:  // Clock Divider
+           VH->bytOKI6258Flags &= ~(0x03 << 0);
+           VH->bytOKI6258Flags |= (data & 0x03) << 0;
+           break;
+       case 0x02:  // ADPCM Type
+           VH->bytOKI6258Flags &= ~(0x01 << 2);
+           VH->bytOKI6258Flags |= (data & 0x01) << 2;
+           break;
+       case 0x03:  // 12-Bit Output
+           VH->bytOKI6258Flags &= ~(0x01 << 3);
+           VH->bytOKI6258Flags |= (data & 0x01) << 3;
+           break;
+       }
+       break;
+   case VGMC_OKIM6295:
+       switch(attr)
+       {
+       case 0x00:  // Chip Type (pin 7 state)
+           VH->lngHzOKIM6295 = (VH->lngHzOKIM6295 & 0x7FFFFFFF) | (data << 31);
+           break;
+       }
+       break;
+   case VGMC_K051649:
+       break;
+// case VGMC_OKIM6376:
+//     break;
+   }
+
+   return;
+}
+
+void vgm_close(UINT16 vgm_id)
+{
+   VGM_INF* VI;
+   VGM_HEADER* Header;
+
+   if (! LOG_VGM_FILE || vgm_id == 0xFFFF)
+       return;
+
+   VI = &VgmFile[vgm_id];
+   Header = &VI->Header;
+
+   vgm_write_delay(vgm_id);
+   fputc(0x66, VI->hFile); // Write EOF Command
+   VI->BytesWrt ++;
+
+   // GD3 Tag
+   Header->lngGD3Offset = VI->BytesWrt - 0x00000014;
+   fwrite(&VgmTag.fccGD3, 0x04, 0x01, VI->hFile);
+   fwrite(&VgmTag.lngVersion, 0x04, 0x01, VI->hFile);
+   fwrite(&VgmTag.lngTagLength, 0x04, 0x01, VI->hFile);
+   fwrite(VgmTag.strTrackNameE, sizeof(wchar_t), wcslen(VgmTag.strTrackNameE) + 0x01, VI->hFile);
+   fwrite(VgmTag.strTrackNameJ, sizeof(wchar_t), wcslen(VgmTag.strTrackNameJ) + 0x01, VI->hFile);
+   fwrite(VgmTag.strGameNameE, sizeof(wchar_t), wcslen(VgmTag.strGameNameE) + 0x01, VI->hFile);
+   fwrite(VgmTag.strGameNameJ, sizeof(wchar_t), wcslen(VgmTag.strGameNameJ) + 0x01, VI->hFile);
+   fwrite(VgmTag.strSystemNameE, sizeof(wchar_t), wcslen(VgmTag.strSystemNameE) + 0x01, VI->hFile);
+   fwrite(VgmTag.strSystemNameJ, sizeof(wchar_t), wcslen(VgmTag.strSystemNameJ) + 0x01, VI->hFile);
+   fwrite(VgmTag.strAuthorNameE, sizeof(wchar_t), wcslen(VgmTag.strAuthorNameE) + 0x01, VI->hFile);
+   fwrite(VgmTag.strAuthorNameJ, sizeof(wchar_t), wcslen(VgmTag.strAuthorNameJ) + 0x01, VI->hFile);
+   fwrite(VgmTag.strReleaseDate, sizeof(wchar_t), wcslen(VgmTag.strReleaseDate) + 0x01, VI->hFile);
+   fwrite(VgmTag.strCreator, sizeof(wchar_t), wcslen(VgmTag.strCreator) + 0x01, VI->hFile);
+   fwrite(VgmTag.strNotes, sizeof(wchar_t), wcslen(VgmTag.strNotes) + 0x01, VI->hFile);
+   VI->BytesWrt += 0x0C + VgmTag.lngTagLength;
+
+   // Rewrite Header
+   Header->lngTotalSamples = VI->SmplsWrt;
+   Header->lngEOFOffset = VI->BytesWrt - 0x00000004;
+   Header->lngDataOffset = VI->HeaderBytes - 0x34;
+
+   fseek(VI->hFile, 0x00, SEEK_SET);
+   fwrite(Header, 0x01, 0x34 + Header->lngDataOffset, VI->hFile);
+
+   fclose(VI->hFile);
+   VI->hFile = NULL;
+
+   logerror("VGM %02hX closed.\t%u Bytes, %u Samples written\n", vgm_id, VI->BytesWrt, VI->SmplsWrt);
+
+   return;
+}
+
+static void vgm_write_delay(UINT16 vgm_id)
+{
+   VGM_INF* VI;
+   UINT16 delaywrite;
+
+   VI = &VgmFile[vgm_id];
+   if (! VI->WroteHeader && VI->EvtDelay)
+       vgm_header_postwrite(vgm_id);   // write post-header data
+
+   while(VI->EvtDelay)
+   {
+       if (VI->EvtDelay > 0x0000FFFF)
+           delaywrite = 0xFFFF;
+       else
+           delaywrite = (UINT16)VI->EvtDelay;
+
+       if (delaywrite <= 0x0010)
+       {
+           fputc(0x6F + delaywrite, VI->hFile);
+           VI->BytesWrt += 0x01;
+       }
+       else
+       {
+           fputc(0x61, VI->hFile);
+           fwrite(&delaywrite, 0x02, 0x01, VI->hFile);
+           VI->BytesWrt += 0x03;
+       }
+       VI->SmplsWrt += delaywrite;
+
+       VI->EvtDelay -= delaywrite;
+   }
+
+   return;
+}
+
+void vgm_write(UINT16 chip_id, UINT8 port, UINT16 r, UINT8 v)
+{
+   VGM_CHIP* VC;
+   VGM_INF* VI;
+   INT8 cm;    // "Cheat Mode" to support 2 instances of 1 chip within 1 file
+   UINT16 curchip;
+   VGM_INIT_CMD WriteCmd;
+
+   if (! LOG_VGM_FILE || chip_id == 0xFFFF)
+       return;
+   if (VgmChip[chip_id].ChipType == 0xFF)
+       return;
+
+   VC = &VgmChip[chip_id];
+   VI = &VgmFile[VC->VgmID];
+   if (! VI->hFile)
+       return;
+
+   if (! VC->HadWrite)
+   {
+       VC->HadWrite = 0x01;
+       if (VC->ChipType & 0x80)
+       {
+           for (curchip = 0x00; curchip < chip_id; curchip ++)
+           {
+               if (VgmChip[curchip].ChipType == (VC->ChipType & 0x7F))
+                   VC->HadWrite = 0x01;
+           }
+       }
+   }
+
+   cm = (VC->ChipType & 0x80) ? 0x50 : 0x00;
+
+   switch(VC->ChipType & 0x7F) // Write the data
+   {
+   case VGMC_T6W28:
+       cm = ~port & 0x01;
+       port = 0x00;
+       // no break
+   case VGMC_SN76496:
+       switch(port)
+       {
+       case 0x00:
+           cm = cm ? -0x20 : 0x00;
+           WriteCmd.Data[0x00] = 0x50 + cm;
+           WriteCmd.Data[0x01] = r;
+           WriteCmd.CmdLen = 0x02;
+           break;
+       case 0x01:
+           cm = cm ? -0x10 : 0x00;
+           WriteCmd.Data[0x00] = 0x4F + cm;
+           WriteCmd.Data[0x01] = r;
+           WriteCmd.CmdLen = 0x02;
+           break;
+       }
+       break;
+   case VGMC_YM2413:
+       WriteCmd.Data[0x00] = 0x51 + cm;
+       WriteCmd.Data[0x01] = r;
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_YM2612:
+       WriteCmd.Data[0x00] = 0x52 + (port & 0x01) + cm;
+       WriteCmd.Data[0x01] = r;
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_YM2151:
+       WriteCmd.Data[0x00] = 0x54 + cm;
+       WriteCmd.Data[0x01] = r;
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_SEGAPCM:
+       WriteCmd.Data[0x00] = 0xC0;     // Write Memory
+       WriteCmd.Data[0x01] = (r >> 0) & 0xFF;  // offset low
+       WriteCmd.Data[0x02] = (r >> 8) & 0xFF;  // offset high
+       WriteCmd.Data[0x03] = v;        // data
+       WriteCmd.CmdLen = 0x04;
+       break;
+   case VGMC_RF5C68:
+       switch(port)
+       {
+       case 0x00:
+           WriteCmd.Data[0x00] = 0xB0; // Write Register
+           WriteCmd.Data[0x01] = r;    // Register
+           WriteCmd.Data[0x02] = v;    // Value
+           WriteCmd.CmdLen = 0x03;
+           break;
+       case 0x01:
+           WriteCmd.Data[0x00] = 0xC1;     // Write Memory
+           WriteCmd.Data[0x01] = (r >> 0) & 0xFF;  // offset low
+           WriteCmd.Data[0x02] = (r >> 8) & 0xFF;  // offset high
+           WriteCmd.Data[0x03] = v;        // Data
+           WriteCmd.CmdLen = 0x04;
+           break;
+       }
+       break;
+   case VGMC_YM2203:
+       WriteCmd.Data[0x00] = 0x55 + cm;
+       WriteCmd.Data[0x01] = r;
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_YM2608:
+       WriteCmd.Data[0x00] = 0x56 + (port & 0x01) + cm;
+       WriteCmd.Data[0x01] = r;
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_YM2610:
+       WriteCmd.Data[0x00] = 0x58 + (port & 0x01) + cm;
+       WriteCmd.Data[0x01] = r;
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_YM3812:
+       WriteCmd.Data[0x00] = 0x5A + cm;
+       WriteCmd.Data[0x01] = r;
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_YM3526:
+       WriteCmd.Data[0x00] = 0x5B + cm;
+       WriteCmd.Data[0x01] = r;
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_Y8950:
+       WriteCmd.Data[0x00] = 0x5C + cm;
+       WriteCmd.Data[0x01] = r;
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_YMF262:
+       WriteCmd.Data[0x00] = 0x5E + (port & 0x01) + cm;
+       WriteCmd.Data[0x01] = r;
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_YMF278B:
+       WriteCmd.Data[0x00] = 0xD0;
+       WriteCmd.Data[0x01] = port | (VC->ChipType & 0x80);
+       WriteCmd.Data[0x02] = r;
+       WriteCmd.Data[0x03] = v;
+       WriteCmd.CmdLen = 0x04;
+       break;
+   case VGMC_YMF271:
+       WriteCmd.Data[0x00] = 0xD1;
+       WriteCmd.Data[0x01] = port | (VC->ChipType & 0x80);
+       WriteCmd.Data[0x02] = r;
+       WriteCmd.Data[0x03] = v;
+       WriteCmd.CmdLen = 0x04;
+       break;
+   case VGMC_YMZ280B:
+       WriteCmd.Data[0x00] = 0x5D + cm;
+       WriteCmd.Data[0x01] = r;
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_RF5C164:
+       switch(port)
+       {
+       case 0x00:
+           WriteCmd.Data[0x00] = 0xB1; // Write Register
+           WriteCmd.Data[0x01] = r;    // Register
+           WriteCmd.Data[0x02] = v;    // Value
+           WriteCmd.CmdLen = 0x03;
+           break;
+       case 0x01:
+           WriteCmd.Data[0x00] = 0xC2;     // Write Memory
+           WriteCmd.Data[0x01] = (r >> 0) & 0xFF;  // offset low
+           WriteCmd.Data[0x02] = (r >> 8) & 0xFF;  // offset high
+           WriteCmd.Data[0x03] = v;        // Data
+           WriteCmd.CmdLen = 0x04;
+           break;
+       }
+       break;
+   case VGMC_PWM:
+       WriteCmd.Data[0x00] = 0xB2;
+       WriteCmd.Data[0x01] = (port << 4) | ((r & 0xF00) >> 8);
+       WriteCmd.Data[0x02] = r & 0xFF;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_AY8910:
+       WriteCmd.Data[0x00] = 0xA0;
+       WriteCmd.Data[0x01] = r | (VC->ChipType & 0x80);
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_GBSOUND:
+       WriteCmd.Data[0x00] = 0xB3;
+       WriteCmd.Data[0x01] = r | (VC->ChipType & 0x80);
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_NESAPU:
+       WriteCmd.Data[0x00] = 0xB4;
+       WriteCmd.Data[0x01] = r | (VC->ChipType & 0x80);
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_MULTIPCM:
+       switch(port)
+       {
+       case 0x00:  // Register Write
+           WriteCmd.Data[0x00] = 0xB5;
+           WriteCmd.Data[0x01] = r | (VC->ChipType & 0x80);
+           WriteCmd.Data[0x02] = v;
+           WriteCmd.CmdLen = 0x03;
+           break;
+       case 0x01:  // Bank Write
+           WriteCmd.Data[0x00] = 0xC3;
+           WriteCmd.Data[0x01] = v | (VC->ChipType & 0x80);    // Both/Left/Right Offset
+           WriteCmd.Data[0x02] = (r >> 0) & 0xFF;  // offset low
+           WriteCmd.Data[0x03] = (r >> 8) & 0xFF;  // offset high
+           WriteCmd.CmdLen = 0x04;
+           break;
+       }
+       break;
+   case VGMC_UPD7759:
+       WriteCmd.Data[0x00] = 0xB6;
+       WriteCmd.Data[0x01] = r | (VC->ChipType & 0x80);
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_OKIM6258:
+       WriteCmd.Data[0x00] = 0xB7;
+       WriteCmd.Data[0x01] = r | (VC->ChipType & 0x80);
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_OKIM6295:
+       WriteCmd.Data[0x00] = 0xB8;
+       WriteCmd.Data[0x01] = r | (VC->ChipType & 0x80);
+       WriteCmd.Data[0x02] = v;
+       WriteCmd.CmdLen = 0x03;
+       break;
+   case VGMC_K051649:
+       WriteCmd.Data[0x00] = 0xD2;
+       WriteCmd.Data[0x01] = port | (VC->ChipType & 0x80);
+       WriteCmd.Data[0x02] = r;
+       WriteCmd.Data[0x03] = v;
+       WriteCmd.CmdLen = 0x04;
+       break;
+// case VGMC_OKIM6376:
+//     WriteCmd.Data[0x00] = 0x31;
+//     WriteCmd.Data[0x01] = v;
+//     WriteCmd.CmdLen = 0x02;
+//     break;
+   }
+
+   vgm_write_delay(VC->VgmID);
+
+   if (! VI->WroteHeader)
+   {
+       /*if (VI->CmdCount >= VI->CmdAlloc)
+       {
+           VI->CmdAlloc += 0x100;
+           VI->Commands = (VGM_INIT_CMD*)realloc(VI->Commands, sizeof(VGM_INIT_CMD) * VI->CmdAlloc);
+       }*/
+
+       // most commands sent at time 0 come from soundchip_reset(),
+       // so I check if the command is "worth" being written
+       cm = 0x00;
+       switch(VC->ChipType & 0x7F)
+       {
+       case VGMC_YM2203:
+       case VGMC_YM2608:   // (not on YM2610 and YM2612)
+           if (r >= 0x2D && r <= 0x2F)
+               cm = 0x01;  // Prescaler Select
+           break;
+       case VGMC_OKIM6258:
+           if (r >= 0x08 && r <= 0x0F)
+               cm = 0x01;  // OKIM6258 clock change
+           break;
+       }
+
+       if (cm && VI->CmdCount < 0x100)
+       {
+           VI->Commands[VI->CmdCount] = WriteCmd;
+           VI->CmdCount ++;
+       }
+       return;
+   }
+
+   if (VI->hFile)
+   {
+       fwrite(WriteCmd.Data, 0x01, WriteCmd.CmdLen, VI->hFile);
+       VI->BytesWrt += WriteCmd.CmdLen;
+   }
+
+   return;
+}
+
+void vgm_write_large_data(UINT16 chip_id, UINT8 type, UINT32 datasize, UINT32 value1, UINT32 value2, const void* data)
+{
+   // datasize - ROM/RAM size
+   // value1 - Start Address
+   // value2 - Bytes to Write (0 -> write from Start Address to end of ROM/RAM)
+
+   VGM_INF* VI;
+   VGM_ROM_DATA* VR;
+   UINT32 finalsize;
+   UINT8 blk_type;
+
+   if (! LOG_VGM_FILE || chip_id == 0xFFFF)
+       return;
+   if (VgmChip[chip_id].ChipType == 0xFF)
+       return;
+
+   VI = &VgmFile[VgmChip[chip_id].VgmID];
+   if (! VI->hFile)
+       return;
+
+   blk_type = 0x00;
+   switch(VgmChip[chip_id].ChipType & 0x7F)    // Write the data
+   {
+   case VGMC_SN76496:
+   case VGMC_T6W28:
+       break;
+   case VGMC_YM2413:
+       break;
+   case VGMC_YM2612:
+       break;
+   case VGMC_YM2151:
+       break;
+   case VGMC_SEGAPCM:
+       switch(type)
+       {
+       case 0x00:
+           break;
+       case 0x01:  // ROM Image
+           blk_type = 0x80;    // Type: SegaPCM ROM Image
+           break;
+       }
+       break;
+   case VGMC_RF5C68:
+       break;
+   case VGMC_YM2203:
+       break;
+   case VGMC_YM2608:
+       switch(type)
+       {
+       case 0x00:
+           break;
+       case 0x01:  // PCM ROM Data
+           blk_type = 0x81;    // Type: YM2608 DELTA-T ROM Data
+           break;
+       }
+       break;
+   case VGMC_YM2610:
+       switch(type)
+       {
+       case 0x00:
+           break;
+       case 0x01:  // PCM ROM Data A
+           blk_type = 0x82;    // Type: YM2610 ADPCM ROM Data
+           break;
+       case 0x02:  // PCM ROM Data B
+           blk_type = 0x83;    // Type: YM2610 DELTA-T ROM Data
+           break;
+       }
+       break;
+   case VGMC_YM3812:
+       break;
+   case VGMC_YM3526:
+       break;
+   case VGMC_Y8950:
+       switch(type)
+       {
+       case 0x00:
+           break;
+       case 0x01:  // DELTA-T Memory
+           blk_type = 0x88;    // Type: Y8950 DELTA-T ROM Data
+           break;
+       }
+       break;
+   case VGMC_YMF262:
+       break;
+   case VGMC_YMF278B:
+       switch(type)
+       {
+       case 0x00:
+           break;
+       case 0x01:  // ROM Data
+           blk_type = 0x84;    // Type: YMF278B ROM Data
+           break;
+       case 0x02:  // RAM Data
+           blk_type = 0x87;    // Type: YMF278B RAM Data
+           break;
+       }
+       break;
+   case VGMC_YMF271:
+       switch(type)
+       {
+       case 0x00:
+           break;
+       case 0x01:  // ROM Data
+           blk_type = 0x85;    // Type: YMF271 ROM Data
+           break;
+       }
+       break;
+   case VGMC_YMZ280B:
+       switch(type)
+       {
+       case 0x00:
+           break;
+       case 0x01:  // ROM Data
+           blk_type = 0x86;    // Type: YMZ280B ROM Data
+           break;
+       }
+       break;
+   case VGMC_RF5C164:
+       break;
+   case VGMC_PWM:
+       break;
+   case VGMC_AY8910:
+       break;
+   case VGMC_GBSOUND:
+       break;
+   case VGMC_NESAPU:
+       switch(type)
+       {
+       case 0x00:
+           break;
+       case 0x01:  // RAM Data
+           if (vgm_nes_ram_check(VI, datasize, &value1, &value2, (UINT8*)data))
+               blk_type = 0xC2;
+           break;
+       }
+       break;
+   case VGMC_MULTIPCM:
+       switch(type)
+       {
+       case 0x00:
+           break;
+       case 0x01:  // ROM Data
+           blk_type = 0x89;    // Type: MultiPCM ROM Data
+           break;
+       }
+       break;
+   case VGMC_UPD7759:
+       switch(type)
+       {
+       case 0x00:
+           break;
+       case 0x01:  // ROM Data
+           blk_type = 0x8A;    // Type: UPD7759 ROM Data
+           break;
+       }
+       break;
+   case VGMC_OKIM6258:
+       break;
+   case VGMC_OKIM6295:
+       switch(type)
+       {
+       case 0x00:
+           break;
+       case 0x01:  // ROM Data
+           blk_type = 0x8B;    // Type: OKIM6295 ROM Data
+           break;
+       }
+       break;
+   case VGMC_K051649:
+       break;
+// case VGMC_OKIM6376:
+//     switch(type)
+//     {
+//     case 0x00:
+//         break;
+//     case 0x01:  // ROM Data
+//         //blk_type = 0x8C;  // Type: OKIM6376 ROM Data
+//         break;
+//     }
+//     break;
+   }
+
+   if (! blk_type)
+       return;
+
+   if (data == NULL)
+       logerror("ROM Data %02X: (0x%x bytes) is NULL!", blk_type, datasize);
+
+   vgm_write_delay(VgmChip[chip_id].VgmID);
+
+   fputc(0x67, VI->hFile);
+   fputc(0x66, VI->hFile);
+   fputc(blk_type, VI->hFile);
+
+   switch(blk_type & 0xC0)
+   {
+   case 0x80:  // ROM Image
+       if (! VI->WroteHeader)
+       {
+           /*VI->DataCount ++;
+           VI->DataBlk = (VGM_ROM_DATA*)realloc(VI->DataBlk, sizeof(VGM_ROM_DATA) * VI->DataCount);*/
+
+           if (VI->DataCount < 0x20)
+           {
+               VR = &VI->DataBlk[VI->DataCount];
+               VI->DataCount ++;
+
+               VR->Type = blk_type;
+               VR->DataSize = datasize | ((VgmChip[chip_id].ChipType & 0x80) << 24);
+               VR->Data = data;
+           }
+           return;
+       }
+
+       // Value 1 & 2 are used to write parts of the image (and save space)
+       if (! value2)
+           value2 = datasize - value1;
+       if (data == NULL)
+       {
+           value1 = 0x00;
+           value2 = 0x00;
+       }
+       finalsize = 0x08 + value2;
+       finalsize |= (VgmChip[chip_id].ChipType & 0x80) << 24;
+
+       fwrite(&finalsize, 0x04, 0x01, VI->hFile);  // Data Block Size
+       fwrite(&datasize, 0x04, 0x01, VI->hFile);   // ROM Size
+       fwrite(&value1, 0x04, 0x01, VI->hFile);     // Data Base Address
+       fwrite(data, 0x01, value2, VI->hFile);
+       VI->BytesWrt += 0x07 + (finalsize & 0x7FFFFFFF);
+       break;
+   case 0xC0:  // RAM Writes
+       if (! value2)
+           value2 = datasize - value1;
+       if (data == NULL)
+       {
+           value1 = 0x00;
+           value2 = 0x00;
+       }
+
+       finalsize = 0x02 + value2;
+       finalsize |= (VgmChip[chip_id].ChipType & 0x80) << 24;
+
+       fwrite(&finalsize, 0x04, 0x01, VI->hFile);  // Data Block Size
+       fwrite(&value1, 0x02, 0x01, VI->hFile);     // Data Address
+       fwrite(data, 0x01, value2, VI->hFile);
+       VI->BytesWrt += 0x07 + (finalsize & 0x7FFFFFFF);
+       break;
+   }
+
+   return;
+}
+
+static UINT8 vgm_nes_ram_check(VGM_INF* VI, UINT32 datasize, UINT32* value1, UINT32* value2, const UINT8* data)
+{
+   UINT16 CurPos;
+   UINT16 DataStart;
+   UINT16 DataEnd;
+
+   if (VI->NesMemEmpty)
+   {
+       VI->NesMemEmpty = 0x00;
+       memcpy(VI->NesMem, data, 0x4000);
+
+       *value1 = 0xC000;
+       *value2 = 0x4000;
+       return 0x02;
+   }
+
+   DataStart = *value1 & 0x3FFF;
+   if (! *value2)
+       DataEnd = 0x4000;
+   else
+       DataEnd = DataStart + *value2;
+
+   for (CurPos = DataStart; CurPos < DataEnd; CurPos ++)
+   {
+       if (VI->NesMem[CurPos] != data[CurPos])
+       {
+           memcpy(VI->NesMem + DataStart, data + DataStart, DataEnd - DataStart);
+           return 0x01;
+       }
+   }
+
+   return 0x00;
+}
